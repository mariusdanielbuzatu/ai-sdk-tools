{"version":3,"sources":["../src/index.ts","../src/debug.ts","../src/hooks.ts","../src/use-chat.ts","../src/use-data-parts.ts"],"sourcesContent":["// Types\r\nexport type { UIMessage } from \"@ai-sdk/react\";\r\nexport { configureDebug, DebugLogger, debug } from \"./debug\";\r\n// Store and hooks\r\nexport {\r\n  type ChatActions,\r\n  ChatStoreContext,\r\n  createChatStoreCreator,\r\n  createChatStore,\r\n  Provider,\r\n  type StoreState,\r\n  useChatActions,\r\n  useChatError,\r\n  useChatId,\r\n  useChatMessages,\r\n  useChatReset,\r\n  useChatStatus,\r\n  useChatStore,\r\n  useChatStoreApi,\r\n  useMessageById,\r\n  useMessageCount,\r\n  useMessageIds,\r\n  useSelector,\r\n  useVirtualMessages,\r\n} from \"./hooks\";\r\n// Enhanced useChat hook\r\nexport {\r\n  type UseChatHelpers,\r\n  type UseChatOptions,\r\n  useChat,\r\n} from \"./use-chat\";\r\n// Data parts hooks\r\nexport {\r\n  type DataPart,\r\n  type UseDataPartOptions,\r\n  type UseDataPartsReturn,\r\n  useDataPart,\r\n  useDataParts,\r\n} from \"./use-data-parts\";\r\n","type LogLevel = \"log\" | \"warn\" | \"error\";\r\n\r\ninterface DebugOptions {\r\n  enabled?: boolean;\r\n  prefix?: string;\r\n  level?: LogLevel;\r\n}\r\n\r\nclass DebugLogger {\r\n  private enabled: boolean;\r\n  private prefix: string;\r\n  private level: LogLevel;\r\n\r\n  constructor(options: DebugOptions = {}) {\r\n    this.enabled = options.enabled ?? process.env.DEBUG === \"true\";\r\n    this.prefix = options.prefix ?? \"[Store]\";\r\n    this.level = options.level ?? \"warn\";\r\n  }\r\n\r\n  private shouldLog(level: LogLevel): boolean {\r\n    if (!this.enabled) return false;\r\n\r\n    const levels = [\"log\", \"warn\", \"error\"];\r\n    return levels.indexOf(level) >= levels.indexOf(this.level);\r\n  }\r\n\r\n  log(...args: any[]): void {\r\n    if (this.shouldLog(\"log\")) {\r\n      console.log(this.prefix, ...args);\r\n    }\r\n  }\r\n\r\n  warn(...args: any[]): void {\r\n    if (this.shouldLog(\"warn\")) {\r\n      console.warn(this.prefix, ...args);\r\n    }\r\n  }\r\n\r\n  error(...args: any[]): void {\r\n    if (this.shouldLog(\"error\")) {\r\n      console.error(this.prefix, ...args);\r\n    }\r\n  }\r\n\r\n  setEnabled(enabled: boolean): void {\r\n    this.enabled = enabled;\r\n  }\r\n\r\n  setLevel(level: LogLevel): void {\r\n    this.level = level;\r\n  }\r\n}\r\n\r\n// Create default logger instance\r\nexport const debug = new DebugLogger();\r\n\r\n// Export for external configuration\r\nexport function configureDebug(options: DebugOptions): void {\r\n  if (options.enabled !== undefined) {\r\n    debug.setEnabled(options.enabled);\r\n  }\r\n  if (options.level !== undefined) {\r\n    debug.setLevel(options.level);\r\n  }\r\n}\r\n\r\n// Export the class for custom loggers\r\nexport { DebugLogger };\r\n","\"use client\";\r\n\r\nimport type { UIMessage, UseChatHelpers } from \"@ai-sdk/react\";\r\nimport type { ChatStatus } from \"ai\";\r\nimport * as React from \"react\";\r\nimport { createContext, useCallback, useContext, useRef } from \"react\";\r\nimport { useStore } from \"zustand\";\r\nimport { devtools, subscribeWithSelector } from \"zustand/middleware\";\r\nimport { useShallow } from \"zustand/shallow\";\r\nimport { createStore, type StateCreator } from \"zustand/vanilla\";\r\nimport { debug } from \"./debug\";\r\n\r\n// --- Performance monitoring and batching ---\r\nlet __freezeDetectorStarted = false;\r\nlet __freezeRafId = 0;\r\nlet __freezeLastTs = 0;\r\nlet __lastActionLabel: string | undefined;\r\nlet __clearLastActionTimer: ReturnType<typeof setTimeout> | null = null;\r\n\r\n// Batched updates queue with priority\r\nconst __updateQueue: Array<{ callback: () => void; priority: number }> = [];\r\nlet __batchedUpdateScheduled = false;\r\n\r\nfunction markLastAction(label: string) {\r\n  __lastActionLabel = label;\r\n  if (typeof window !== \"undefined\") {\r\n    if (__clearLastActionTimer) clearTimeout(__clearLastActionTimer);\r\n    __clearLastActionTimer = setTimeout(() => {\r\n      if (__lastActionLabel === label) __lastActionLabel = undefined;\r\n    }, 250);\r\n  }\r\n}\r\n\r\nfunction batchUpdates(callback: () => void, priority = 0) {\r\n  if (typeof window === \"undefined\") {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  __updateQueue.push({ callback, priority });\r\n\r\n  if (!__batchedUpdateScheduled) {\r\n    __batchedUpdateScheduled = true;\r\n\r\n    // Use scheduler if available, otherwise fallback to rAF\r\n    const scheduler = (window as any).scheduler;\r\n    const schedule = scheduler?.postTask\r\n      ? scheduler.postTask.bind(scheduler)\r\n      : window.requestAnimationFrame?.bind(window) ||\r\n        ((fn: () => void) => setTimeout(fn, 0));\r\n\r\n    schedule(() => {\r\n      const updates = __updateQueue.splice(0);\r\n      __batchedUpdateScheduled = false;\r\n\r\n      // Sort by priority (higher priority first) and execute\r\n      updates.sort((a, b) => b.priority - a.priority);\r\n      updates.forEach((update) => {\r\n        update.callback();\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\nfunction startFreezeDetector({\r\n  thresholdMs = 80,\r\n}: {\r\n  thresholdMs?: number;\r\n} = {}): void {\r\n  if (typeof window === \"undefined\" || __freezeDetectorStarted) return;\r\n  __freezeDetectorStarted = true;\r\n  __freezeLastTs = performance.now();\r\n\r\n  const tick = (now: number) => {\r\n    const expected = __freezeLastTs + 16.7;\r\n    const blockedMs = now - expected;\r\n    if (blockedMs > thresholdMs) {\r\n      debug.warn(\r\n        \"[Freeze]\",\r\n        `${Math.round(blockedMs)}ms`,\r\n        \"lastAction=\",\r\n        __lastActionLabel,\r\n      );\r\n    }\r\n    __freezeLastTs = now;\r\n    if (\r\n      typeof window !== \"undefined\" &&\r\n      typeof window.requestAnimationFrame === \"function\"\r\n    ) {\r\n      __freezeRafId = window.requestAnimationFrame(tick);\r\n    }\r\n  };\r\n\r\n  if (\r\n    typeof window !== \"undefined\" &&\r\n    typeof window.requestAnimationFrame === \"function\"\r\n  ) {\r\n    __freezeRafId = window.requestAnimationFrame(tick);\r\n  }\r\n\r\n  if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\") {\r\n    window.addEventListener(\"beforeunload\", () => {\r\n      if (__freezeRafId && typeof cancelAnimationFrame === \"function\") {\r\n        cancelAnimationFrame(__freezeRafId);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nif (typeof window !== \"undefined\") {\r\n  startFreezeDetector({ thresholdMs: 80 });\r\n}\r\n\r\n// Enhanced throttle with requestIdleCallback support\r\nfunction enhancedThrottle<T extends (...args: any[]) => void>(\r\n  func: T,\r\n  wait: number,\r\n): T {\r\n  let timeout: ReturnType<typeof setTimeout> | null = null;\r\n  let previous = 0;\r\n  let pendingArgs: Parameters<T> | null = null;\r\n\r\n  const execute = () => {\r\n    if (pendingArgs) {\r\n      func.apply(null, pendingArgs);\r\n      pendingArgs = null;\r\n    }\r\n  };\r\n\r\n  return ((...args: Parameters<T>) => {\r\n    const now = Date.now();\r\n    const remaining = wait - (now - previous);\r\n    pendingArgs = args;\r\n\r\n    if (remaining <= 0 || remaining > wait) {\r\n      if (timeout) {\r\n        clearTimeout(timeout);\r\n        timeout = null;\r\n      }\r\n      previous = now;\r\n\r\n      // Use requestIdleCallback if available for better performance\r\n      if (\r\n        typeof window !== \"undefined\" &&\r\n        (window as any).requestIdleCallback\r\n      ) {\r\n        (window as any).requestIdleCallback(execute, { timeout: 50 });\r\n      } else {\r\n        execute();\r\n      }\r\n    } else if (!timeout) {\r\n      timeout = setTimeout(() => {\r\n        previous = Date.now();\r\n        timeout = null;\r\n\r\n        if (\r\n          typeof window !== \"undefined\" &&\r\n          (window as any).requestIdleCallback\r\n        ) {\r\n          (window as any).requestIdleCallback(execute, { timeout: 50 });\r\n        } else {\r\n          execute();\r\n        }\r\n      }, remaining);\r\n    }\r\n  }) as T;\r\n}\r\n\r\n// Message indexing for O(1) lookups\r\nclass MessageIndex<TMessage extends UIMessage> {\r\n  private idToMessage = new Map<string, TMessage>();\r\n  private idToIndex = new Map<string, number>();\r\n\r\n  update(messages: TMessage[]) {\r\n    this.idToMessage.clear();\r\n    this.idToIndex.clear();\r\n\r\n    messages.forEach((message, index) => {\r\n      this.idToMessage.set(message.id, message);\r\n      this.idToIndex.set(message.id, index);\r\n    });\r\n  }\r\n\r\n  getById(id: string): TMessage | undefined {\r\n    return this.idToMessage.get(id);\r\n  }\r\n\r\n  getIndexById(id: string): number | undefined {\r\n    return this.idToIndex.get(id);\r\n  }\r\n\r\n  has(id: string): boolean {\r\n    return this.idToMessage.has(id);\r\n  }\r\n}\r\n\r\nexport interface StoreState<TMessage extends UIMessage = UIMessage> {\r\n  id: string | undefined;\r\n  messages: TMessage[];\r\n  status: ChatStatus;\r\n  error: Error | undefined;\r\n\r\n  // Performance optimizations\r\n  _throttledMessages: TMessage[] | null;\r\n  _messageIndex: MessageIndex<TMessage>;\r\n  _memoizedSelectors: Map<string, { result: any; deps: any[] }>;\r\n\r\n  // Transient data parts (not persisted in messages)\r\n  _transientDataParts: Map<string, any>;\r\n\r\n  // Actions with batching\r\n  setId: (id: string | undefined) => void;\r\n  setMessages: (messages: TMessage[]) => void;\r\n  setStatus: (status: ChatStatus) => void;\r\n  setError: (error: Error | undefined) => void;\r\n  setNewChat: (id: string, messages: TMessage[]) => void;\r\n  pushMessage: (message: TMessage) => void;\r\n  popMessage: () => void;\r\n  replaceMessage: (index: number, message: TMessage) => void;\r\n  replaceMessageById: (id: string, message: TMessage) => void;\r\n\r\n  // Chat helpers\r\n  sendMessage?: UseChatHelpers<TMessage>[\"sendMessage\"];\r\n  regenerate?: UseChatHelpers<TMessage>[\"regenerate\"];\r\n  stop?: UseChatHelpers<TMessage>[\"stop\"];\r\n  resumeStream?: UseChatHelpers<TMessage>[\"resumeStream\"];\r\n  addToolResult?: UseChatHelpers<TMessage>[\"addToolResult\"];\r\n  clearError?: UseChatHelpers<TMessage>[\"clearError\"];\r\n\r\n  // Internal sync method\r\n  _syncState: (newState: Partial<StoreState<TMessage>>) => void;\r\n\r\n  // Reset method\r\n  reset: () => void;\r\n\r\n  // Optimized getters\r\n  getLastMessageId: () => string | null;\r\n  getMessageIds: () => string[];\r\n  getThrottledMessages: () => TMessage[];\r\n  getInternalMessages: () => TMessage[];\r\n  getMessageById: (id: string) => TMessage | undefined;\r\n  getMessageIndexById: (id: string) => number | undefined;\r\n  getMessagesSlice: (start: number, end?: number) => TMessage[];\r\n  getMessageCount: () => number;\r\n\r\n  // Memoized complex selectors\r\n  getMemoizedSelector: <T>(key: string, selector: () => T, deps: any[]) => T;\r\n\r\n  // Effects\r\n  registerThrottledMessagesEffect: (effect: () => void) => () => void;\r\n\r\n  // Transient data methods\r\n  setTransientDataPart: (type: string, data: any) => void;\r\n  getTransientDataPart: (type: string) => any;\r\n  removeTransientDataPart: (type: string) => void;\r\n  clearTransientDataParts: () => void;\r\n}\r\n\r\nconst MESSAGES_THROTTLE_MS = 16; // ~60fps for smooth streaming\r\n\r\nexport function createChatStoreCreator<TMessage extends UIMessage>(\r\n  initialMessages: TMessage[] = [],\r\n): StateCreator<StoreState<TMessage>, [], []> {\r\n  let throttledMessagesUpdater: (() => void) | null = null;\r\n  const messageIndex = new MessageIndex<TMessage>();\r\n  const throttledEffects = new Set<() => void>();\r\n\r\n  messageIndex.update(initialMessages);\r\n  return (set, get) => {\r\n    if (!throttledMessagesUpdater) {\r\n      throttledMessagesUpdater = enhancedThrottle(() => {\r\n        batchUpdates(() => {\r\n          const state = get();\r\n          const newThrottledMessages = [...state.messages];\r\n          state._messageIndex.update(newThrottledMessages);\r\n\r\n          set({\r\n            _throttledMessages: newThrottledMessages,\r\n          });\r\n\r\n          throttledEffects.forEach((cb) => {\r\n            try {\r\n              cb();\r\n            } catch (err) {\r\n              // eslint-disable-next-line no-console\r\n              console.warn(\"[chat-store-base] throttled effect error\", err);\r\n            }\r\n          });\r\n        });\r\n      }, MESSAGES_THROTTLE_MS);\r\n    }\r\n\r\n    return {\r\n      id: undefined,\r\n      messages: initialMessages,\r\n      status: \"ready\" as const,\r\n      error: undefined,\r\n      _throttledMessages: [...initialMessages],\r\n      _messageIndex: messageIndex,\r\n      _memoizedSelectors: new Map(),\r\n      _transientDataParts: new Map(),\r\n\r\n      // Chat helpers\r\n      sendMessage: undefined,\r\n      regenerate: undefined,\r\n      stop: undefined,\r\n      resumeStream: undefined,\r\n      addToolResult: undefined,\r\n      clearError: undefined,\r\n\r\n      setId: (id) => {\r\n        markLastAction(\"chat:setId\");\r\n        batchUpdates(() => set({ id }));\r\n      },\r\n\r\n      setMessages: (messages) => {\r\n        markLastAction(\"chat:setMessages\");\r\n        batchUpdates(() => {\r\n          // Avoid unnecessary work if messages haven't changed\r\n          const currentState = get();\r\n          if (messages === currentState.messages) return;\r\n\r\n          set({\r\n            messages: messages,\r\n            _memoizedSelectors: new Map(), // Clear memoized selectors\r\n          });\r\n\r\n          // During streaming, update immediately for smooth text rendering\r\n          if (currentState.status === \"streaming\") {\r\n            batchUpdates(() => {\r\n              const state = get();\r\n              const newThrottledMessages = [...state.messages];\r\n              state._messageIndex.update(newThrottledMessages);\r\n\r\n              set({\r\n                _throttledMessages: newThrottledMessages,\r\n              });\r\n            }, 1); // High priority for streaming updates\r\n          } else {\r\n            throttledMessagesUpdater?.();\r\n          }\r\n        });\r\n      },\r\n\r\n      setStatus: (status) => {\r\n        markLastAction(\"chat:setStatus\");\r\n        batchUpdates(() => set({ status }));\r\n      },\r\n\r\n      setError: (error) => {\r\n        markLastAction(\"chat:setError\");\r\n        batchUpdates(() => set({ error }));\r\n      },\r\n\r\n      setNewChat: (id, messages) => {\r\n        markLastAction(\"chat:setNewChat\");\r\n        batchUpdates(() => {\r\n          set({\r\n            messages: messages,\r\n            status: \"ready\",\r\n            error: undefined,\r\n            id,\r\n            _memoizedSelectors: new Map(),\r\n          });\r\n          throttledMessagesUpdater?.();\r\n        });\r\n      },\r\n\r\n      pushMessage: (message) => {\r\n        markLastAction(\"chat:pushMessage\");\r\n        batchUpdates(() => {\r\n          const currentState = get();\r\n          set((state) => ({\r\n            messages: [...state.messages, message],\r\n            _memoizedSelectors: new Map(),\r\n          }));\r\n\r\n          // During streaming, update immediately for smooth text rendering\r\n          if (currentState.status === \"streaming\") {\r\n            batchUpdates(() => {\r\n              const state = get();\r\n              const newThrottledMessages = [...state.messages];\r\n              state._messageIndex.update(newThrottledMessages);\r\n\r\n              set({\r\n                _throttledMessages: newThrottledMessages,\r\n              });\r\n            }, 1); // High priority for streaming updates\r\n          } else {\r\n            throttledMessagesUpdater?.();\r\n          }\r\n        });\r\n      },\r\n\r\n      popMessage: () => {\r\n        markLastAction(\"chat:popMessage\");\r\n        batchUpdates(() => {\r\n          set((state) => ({\r\n            messages: state.messages.slice(0, -1),\r\n            _memoizedSelectors: new Map(),\r\n          }));\r\n          throttledMessagesUpdater?.();\r\n        });\r\n      },\r\n\r\n      replaceMessage: (index, message) => {\r\n        markLastAction(\"chat:replaceMessage\");\r\n        batchUpdates(() => {\r\n          const currentState = get();\r\n          set((state) => {\r\n            const newMessages = [...state.messages];\r\n            newMessages[index] = structuredClone(message);\r\n            return {\r\n              messages: newMessages,\r\n              _memoizedSelectors: new Map(),\r\n            };\r\n          });\r\n\r\n          // During streaming, update immediately for smooth text rendering\r\n          if (currentState.status === \"streaming\") {\r\n            batchUpdates(() => {\r\n              const state = get();\r\n              const newThrottledMessages = [...state.messages];\r\n              state._messageIndex.update(newThrottledMessages);\r\n\r\n              set({\r\n                _throttledMessages: newThrottledMessages,\r\n              });\r\n            }, 1); // High priority for streaming updates\r\n          } else {\r\n            throttledMessagesUpdater?.();\r\n          }\r\n        });\r\n      },\r\n\r\n      replaceMessageById: (id, message) => {\r\n        markLastAction(\"chat:replaceMessageById\");\r\n        batchUpdates(() => {\r\n          const currentState = get();\r\n          set((state) => {\r\n            const index = state._messageIndex.getIndexById(id);\r\n            if (index === undefined) return state;\r\n\r\n            const newMessages = [...state.messages];\r\n            newMessages[index] = structuredClone(message);\r\n            return {\r\n              messages: newMessages,\r\n              _memoizedSelectors: new Map(),\r\n            };\r\n          });\r\n\r\n          // During streaming, update immediately for smooth text rendering\r\n          if (currentState.status === \"streaming\") {\r\n            batchUpdates(() => {\r\n              const state = get();\r\n              const newThrottledMessages = [...state.messages];\r\n              state._messageIndex.update(newThrottledMessages);\r\n\r\n              set({\r\n                _throttledMessages: newThrottledMessages,\r\n              });\r\n            }, 1); // High priority for streaming updates\r\n          } else {\r\n            throttledMessagesUpdater?.();\r\n          }\r\n        });\r\n      },\r\n\r\n      _syncState: (newState) => {\r\n        markLastAction(\"chat:_syncState\");\r\n        batchUpdates(() => {\r\n          set(\r\n            {\r\n              ...newState,\r\n              _memoizedSelectors: new Map(), // Clear memoized selectors on sync\r\n            },\r\n            false,\r\n            // 'syncFromUseChat',\r\n          );\r\n          if (newState.messages) {\r\n            throttledMessagesUpdater?.();\r\n          }\r\n        });\r\n      },\r\n\r\n      reset: () => {\r\n        markLastAction(\"chat:reset\");\r\n        batchUpdates(() => {\r\n          const state = get();\r\n          const newMessageIndex = new MessageIndex<TMessage>();\r\n          newMessageIndex.update([]);\r\n\r\n          // Also clear messages via setMessages if available (to sync with chat helpers)\r\n          if (state.setMessages) {\r\n            state.setMessages([]);\r\n          }\r\n\r\n          set({\r\n            id: undefined,\r\n            messages: [],\r\n            status: \"ready\" as const,\r\n            error: undefined,\r\n            _throttledMessages: [],\r\n            _messageIndex: newMessageIndex,\r\n            _memoizedSelectors: new Map(),\r\n            _transientDataParts: new Map(),\r\n          });\r\n        });\r\n      },\r\n\r\n      // Optimized getters\r\n      getLastMessageId: () => {\r\n        const state = get();\r\n        return state.messages.length > 0\r\n          ? state.messages[state.messages.length - 1].id\r\n          : null;\r\n      },\r\n\r\n      getMessageIds: () => {\r\n        const state = get();\r\n        return (state._throttledMessages || state.messages).map((m) => m.id);\r\n      },\r\n\r\n      getThrottledMessages: () => {\r\n        const state = get();\r\n        return state._throttledMessages || state.messages;\r\n      },\r\n\r\n      getInternalMessages: () => {\r\n        const state = get();\r\n        return state.messages;\r\n      },\r\n\r\n      getMessageById: (id) => {\r\n        const state = get();\r\n        return state._messageIndex.getById(id);\r\n      },\r\n\r\n      getMessageIndexById: (id) => {\r\n        const state = get();\r\n        return state._messageIndex.getIndexById(id);\r\n      },\r\n\r\n      getMessagesSlice: (start, end) => {\r\n        const state = get();\r\n        const messages = state._throttledMessages || state.messages;\r\n        return messages.slice(start, end);\r\n      },\r\n\r\n      getMessageCount: () => {\r\n        const state = get();\r\n        const messages = state._throttledMessages || state.messages;\r\n        return messages.length;\r\n      },\r\n\r\n      getMemoizedSelector: <T>(\r\n        key: string,\r\n        selector: () => T,\r\n        deps: any[],\r\n      ): T => {\r\n        const state = get();\r\n        const cached = state._memoizedSelectors.get(key);\r\n\r\n        // Fast dependency comparison using length + JSON for complex objects\r\n        if (\r\n          cached &&\r\n          cached.deps.length === deps.length &&\r\n          (deps.length === 0 ||\r\n            JSON.stringify(cached.deps) === JSON.stringify(deps))\r\n        ) {\r\n          return cached.result;\r\n        }\r\n\r\n        const result = selector();\r\n        state._memoizedSelectors.set(key, { result, deps: [...deps] });\r\n        return result;\r\n      },\r\n\r\n      // Effects\r\n      registerThrottledMessagesEffect: (effect: () => void) => {\r\n        throttledEffects.add(effect);\r\n        return () => {\r\n          throttledEffects.delete(effect);\r\n        };\r\n      },\r\n\r\n      // Transient data methods\r\n      setTransientDataPart: (type, data) => {\r\n        markLastAction(\"chat:setTransientDataPart\");\r\n        batchUpdates(() => {\r\n          set((state) => {\r\n            const newTransientDataParts = new Map(state._transientDataParts);\r\n            newTransientDataParts.set(type, data);\r\n            return { _transientDataParts: newTransientDataParts };\r\n          });\r\n        });\r\n      },\r\n\r\n      getTransientDataPart: (type) => {\r\n        const state = get();\r\n        return state._transientDataParts.get(type);\r\n      },\r\n\r\n      removeTransientDataPart: (type) => {\r\n        markLastAction(\"chat:removeTransientDataPart\");\r\n        batchUpdates(() => {\r\n          set((state) => {\r\n            const newTransientDataParts = new Map(state._transientDataParts);\r\n            newTransientDataParts.delete(type);\r\n            return { _transientDataParts: newTransientDataParts };\r\n          });\r\n        });\r\n      },\r\n\r\n      clearTransientDataParts: () => {\r\n        markLastAction(\"chat:clearTransientDataParts\");\r\n        batchUpdates(() => set({ _transientDataParts: new Map() }));\r\n      },\r\n    };\r\n  };\r\n}\r\n\r\nexport function createChatStore<TMessage extends UIMessage = UIMessage>(\r\n  initialMessages: TMessage[] = [],\r\n) {\r\n  return createStore<StoreState<TMessage>>()(\r\n    devtools(\r\n      subscribeWithSelector(createChatStoreCreator<TMessage>(initialMessages)),\r\n      { name: \"chat-store\" },\r\n    ),\r\n  );\r\n}\r\n\r\ntype ChatStoreApi<TMessage extends UIMessage = UIMessage> = ReturnType<\r\n  typeof createChatStore<TMessage>\r\n>;\r\n\r\nexport const ChatStoreContext = createContext<ChatStoreApi<any> | undefined>(\r\n  undefined,\r\n);\r\n\r\ntype CompatibleChatStoreApi<TMessage extends UIMessage = UIMessage> = Omit<\r\n  ChatStoreApi<TMessage>,\r\n  \"setState\"\r\n> & {\r\n  setState(\r\n    partial:\r\n      | StoreState<TMessage>\r\n      | Partial<StoreState<TMessage>>\r\n      | ((\r\n          state: StoreState<TMessage>,\r\n        ) => StoreState<TMessage> | Partial<StoreState<TMessage>>),\r\n    replace?: boolean,\r\n    action?:\r\n      | (\r\n          | string\r\n          | {\r\n              [x: string]: unknown;\r\n              [x: number]: unknown;\r\n              [x: symbol]: unknown;\r\n              type: string;\r\n            }\r\n        )\r\n      | undefined,\r\n  ): void;\r\n};\r\n\r\nexport function Provider<TMessage extends UIMessage = UIMessage>({\r\n  children,\r\n  initialMessages,\r\n  store,\r\n}: {\r\n  children: React.ReactNode;\r\n  initialMessages?: TMessage[];\r\n  store?: CompatibleChatStoreApi<TMessage>;\r\n}) {\r\n  const storeRef = useRef<CompatibleChatStoreApi<TMessage> | null>(null);\r\n\r\n  if (storeRef.current === null) {\r\n    storeRef.current =\r\n      store || createChatStore<TMessage>(initialMessages || []);\r\n  }\r\n\r\n  return React.createElement(\r\n    ChatStoreContext.Provider,\r\n    { value: storeRef.current },\r\n    children,\r\n  );\r\n}\r\n\r\n// Standard Zustand v5 store hook\r\nexport function useChatStore<T, TMessage extends UIMessage = UIMessage>(\r\n  selector: (store: StoreState<TMessage>) => T,\r\n): T;\r\nexport function useChatStore<\r\n  TMessage extends UIMessage = UIMessage,\r\n>(): StoreState<TMessage>;\r\nexport function useChatStore<\r\n  T = StoreState<UIMessage>,\r\n  TMessage extends UIMessage = UIMessage,\r\n>(selector?: (store: StoreState<TMessage>) => T) {\r\n  const store = useContext(ChatStoreContext);\r\n  if (!store) throw new Error(\"useChatStore must be used within Provider\");\r\n\r\n  const selectorOrIdentity =\r\n    selector || ((s: StoreState<TMessage>) => s as unknown as T);\r\n\r\n  // Use Zustand's built-in useStore\r\n  return useStore(store, selectorOrIdentity as (state: any) => T);\r\n}\r\n\r\nexport function useChatStoreApi<TMessage extends UIMessage = UIMessage>() {\r\n  const store = useContext(ChatStoreContext);\r\n  if (!store) throw new Error(\"useChatStoreApi must be used within Provider\");\r\n  return store as ChatStoreApi<TMessage>;\r\n}\r\n\r\n// Optimized selector hooks with memoization\r\nexport const useChatMessages = <TMessage extends UIMessage = UIMessage>() => {\r\n  return useChatStore(\r\n    useShallow((state: StoreState<TMessage>) => state.getThrottledMessages()),\r\n  );\r\n};\r\n\r\n// Stable selector functions to avoid recreation\r\nconst statusSelector = (state: StoreState<any>) => state.status;\r\nconst errorSelector = (state: StoreState<any>) => state.error;\r\nconst idSelector = (state: StoreState<any>) => state.id;\r\nconst messageCountSelector = (state: StoreState<any>) =>\r\n  state.getMessageCount();\r\n\r\nexport const useChatStatus = () => useChatStore(statusSelector);\r\nexport const useChatError = () => useChatStore(errorSelector);\r\nexport const useChatId = () => useChatStore(idSelector);\r\nexport const useMessageIds = <TMessage extends UIMessage = UIMessage>() =>\r\n  useChatStore(\r\n    useShallow((state: StoreState<TMessage>) => state.getMessageIds()),\r\n  );\r\n\r\n// Optimized message selector with O(1) lookup\r\nexport const useMessageById = <TMessage extends UIMessage = UIMessage>(\r\n  messageId: string,\r\n) => {\r\n  return useChatStore(\r\n    useCallback(\r\n      (state: StoreState<TMessage>) => {\r\n        const message = state.getMessageById(messageId);\r\n        if (!message) throw new Error(`Message not found for id: ${messageId}`);\r\n        return message;\r\n      },\r\n      [messageId],\r\n    ),\r\n  );\r\n};\r\n\r\n// Virtualization helper for large message lists\r\nexport const useVirtualMessages = <TMessage extends UIMessage = UIMessage>(\r\n  start: number,\r\n  end?: number,\r\n) => {\r\n  return useChatStore(\r\n    useCallback(\r\n      (state: StoreState<TMessage>) => state.getMessagesSlice(start, end),\r\n      [start, end],\r\n    ),\r\n  );\r\n};\r\n\r\nexport const useMessageCount = () => useChatStore(messageCountSelector);\r\n\r\n// Reset hook for convenience\r\nexport const useChatReset = () => useChatStore((state) => state.reset);\r\n// Stable fallback functions to prevent infinite loops\r\nconst fallbackSendMessage = async () => {\r\n  debug.warn(\r\n    \"sendMessage not configured - make sure useChat is called with transport\",\r\n  );\r\n};\r\nconst fallbackRegenerate = async () => {\r\n  debug.warn(\r\n    \"regenerate not configured - make sure useChat is called with transport\",\r\n  );\r\n};\r\nconst fallbackStop = async () => {\r\n  debug.warn(\r\n    \"stop not configured - make sure useChat is called with transport\",\r\n  );\r\n};\r\nconst fallbackResumeStream = async () => {\r\n  debug.warn(\r\n    \"resumeStream not configured - make sure useChat is called with transport\",\r\n  );\r\n};\r\nconst fallbackAddToolResult = async () => {\r\n  debug.warn(\r\n    \"addToolResult not configured - make sure useChat is called with transport\",\r\n  );\r\n};\r\nconst fallbackClearError = () => {\r\n  debug.warn(\r\n    \"clearError not configured - make sure useChat is called with transport\",\r\n  );\r\n};\r\n\r\nexport type ChatActions<TMessage extends UIMessage = UIMessage> = {\r\n  setMessages: (messages: TMessage[]) => void;\r\n  pushMessage: (message: TMessage) => void;\r\n  popMessage: () => void;\r\n  replaceMessage: (index: number, message: TMessage) => void;\r\n  replaceMessageById: (id: string, message: TMessage) => void;\r\n  setStatus: (status: ChatStatus) => void;\r\n  setError: (error: Error | undefined) => void;\r\n  setId: (id: string | undefined) => void;\r\n  setNewChat: (id: string, messages: TMessage[]) => void;\r\n  reset: () => void;\r\n  sendMessage: UseChatHelpers<TMessage>[\"sendMessage\"];\r\n  regenerate: UseChatHelpers<TMessage>[\"regenerate\"];\r\n  stop: UseChatHelpers<TMessage>[\"stop\"];\r\n  resumeStream: UseChatHelpers<TMessage>[\"resumeStream\"];\r\n  addToolResult: UseChatHelpers<TMessage>[\"addToolResult\"];\r\n  clearError: UseChatHelpers<TMessage>[\"clearError\"];\r\n};\r\n\r\nexport const useChatActions = <\r\n  TMessage extends UIMessage = UIMessage,\r\n>(): ChatActions<TMessage> =>\r\n  useChatStore(\r\n    useShallow((state: StoreState<TMessage>) => ({\r\n      setMessages: state.setMessages,\r\n      pushMessage: state.pushMessage,\r\n      popMessage: state.popMessage,\r\n      replaceMessage: state.replaceMessage,\r\n      replaceMessageById: state.replaceMessageById,\r\n      setStatus: state.setStatus,\r\n      setError: state.setError,\r\n      setId: state.setId,\r\n      setNewChat: state.setNewChat,\r\n      reset: state.reset,\r\n      sendMessage: state.sendMessage || fallbackSendMessage,\r\n      regenerate: state.regenerate || fallbackRegenerate,\r\n      stop: state.stop || fallbackStop,\r\n      resumeStream: state.resumeStream || fallbackResumeStream,\r\n      addToolResult: state.addToolResult || fallbackAddToolResult,\r\n      clearError: state.clearError || fallbackClearError,\r\n    })),\r\n  );\r\n\r\n// Memoized complex selector hook\r\nexport const useSelector = <TMessage extends UIMessage = UIMessage, T = any>(\r\n  key: string,\r\n  selector: (messages: TMessage[]) => T,\r\n  deps: any[] = [],\r\n) => {\r\n  return useChatStore(\r\n    useCallback(\r\n      (state: StoreState<TMessage>) =>\r\n        state.getMemoizedSelector(\r\n          key,\r\n          () => selector(state.getThrottledMessages()),\r\n          [state.getMessageCount(), ...deps],\r\n        ),\r\n      [key, selector, deps],\r\n    ),\r\n  );\r\n};\r\n","import {\r\n  type UIMessage,\r\n  type UseChatHelpers,\r\n  type UseChatOptions,\r\n  useChat as useOriginalChat,\r\n} from \"@ai-sdk/react\";\r\nimport { useCallback, useEffect, useRef } from \"react\";\r\nimport { useStore } from \"zustand\";\r\nimport { type StoreState, useChatStoreApi } from \"./hooks\";\r\n\r\nexport type { UseChatOptions, UseChatHelpers };\r\n\r\nfunction mergeMessages<TMessage extends UIMessage = UIMessage>(\r\n  base: TMessage[],\r\n  incoming: TMessage[],\r\n): TMessage[] {\r\n  if (base.length == 0) return incoming;\r\n  if (incoming.length == 0) return base;\r\n\r\n  const seen = new Set<string>();\r\n  for (const msg of base) {\r\n    const id = (msg as any)?.id;\r\n    if (typeof id === \"string\") seen.add(id);\r\n  }\r\n\r\n  const merged = base.slice();\r\n  for (const msg of incoming) {\r\n    const id = (msg as any)?.id;\r\n    if (typeof id !== \"string\" || !seen.has(id)) {\r\n      merged.push(msg);\r\n      if (typeof id === \"string\") seen.add(id);\r\n    }\r\n  }\r\n\r\n  return merged;\r\n}\r\n\r\n// Type for a compatible chat store\r\nexport interface CompatibleChatStore<TMessage extends UIMessage = UIMessage> {\r\n  <T>(selector: (state: StoreState<TMessage>) => T): T;\r\n  setState?: (partial: Partial<StoreState<TMessage>>) => void;\r\n  _syncState?: (partial: Partial<StoreState<TMessage>>) => void;\r\n}\r\n\r\nexport type UseChatOptionsWithPerformance<\r\n  TMessage extends UIMessage = UIMessage,\r\n> = UseChatOptions<TMessage> & {\r\n  store?: CompatibleChatStore<TMessage>;\r\n  // Additional performance options\r\n  enableBatching?: boolean;\r\n};\r\n\r\nexport function useChat<TMessage extends UIMessage = UIMessage>(\r\n  options: UseChatOptionsWithPerformance<TMessage> = {} as UseChatOptionsWithPerformance<TMessage>,\r\n): UseChatHelpers<TMessage> {\r\n  const {\r\n    store: customStore,\r\n    enableBatching = true,\r\n    ...originalOptions\r\n  } = options;\r\n\r\n  const originalOnData = (options as any).onData;\r\n\r\n  // Use custom store if provided, otherwise use the context store\r\n  const contextStore = useChatStoreApi<TMessage>();\r\n  const store = customStore || contextStore;\r\n\r\n  // Wrap onData to capture transient data parts\r\n  const wrappedOnData = useCallback(\r\n    (dataPart: any) => {\r\n      // Check if it's a data part (starts with 'data-')\r\n      if (dataPart.type?.startsWith(\"data-\")) {\r\n        // Store transient data parts in the store\r\n        if (typeof (store as any).getState === \"function\") {\r\n          const storeState = (store as any).getState();\r\n          // If data is null or undefined, remove the transient data part\r\n          if (dataPart.data === null || dataPart.data === undefined) {\r\n            if (storeState.removeTransientDataPart) {\r\n              storeState.removeTransientDataPart(dataPart.type);\r\n            }\r\n          } else if (storeState.setTransientDataPart) {\r\n            storeState.setTransientDataPart(dataPart.type, dataPart.data);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Call original onData handler if provided\r\n      if (originalOnData) {\r\n        originalOnData(dataPart);\r\n      }\r\n    },\r\n    [store, originalOnData],\r\n  );\r\n\r\n  const chatHelpers = useOriginalChat<TMessage>({\r\n    ...originalOptions,\r\n    onData: wrappedOnData,\r\n  });\r\n\r\n  const storeRef = useRef<CompatibleChatStore<TMessage> | typeof contextStore>(\r\n    store,\r\n  );\r\n\r\n  // Memoize the sync function to avoid recreating it on every render\r\n  const syncState = useCallback((chatState: Partial<StoreState<TMessage>>) => {\r\n    if (!storeRef.current) return;\r\n\r\n    // Check if store has _syncState method (our internal stores)\r\n    if (typeof (storeRef.current as any).getState === \"function\") {\r\n      // For vanilla Zustand stores\r\n      const vanillaStore = storeRef.current as any;\r\n      vanillaStore.getState()._syncState(chatState);\r\n    } else if (typeof (storeRef.current as any)._syncState === \"function\") {\r\n      (storeRef.current as any)._syncState(chatState);\r\n    } else if (typeof (storeRef.current as any).setState === \"function\") {\r\n      // For standard Zustand stores\r\n      (storeRef.current as any).setState(chatState);\r\n    }\r\n  }, []);\r\n\r\n  // Simple sync - merge messages to avoid overwriting existing history\r\n  useEffect(() => {\r\n    const currentStoreState = (store as any).getState?.() || { messages: [] };\r\n    const storeMessages = currentStoreState.messages ?? [];\r\n    const chatMessages = chatHelpers.messages ?? [];\r\n\r\n    let nextMessages = chatMessages as any;\r\n    if (storeMessages.length > 0) {\r\n      if (chatMessages.length === 0) {\r\n        nextMessages = storeMessages;\r\n      } else if (chatMessages.length < storeMessages.length) {\r\n        nextMessages = mergeMessages(storeMessages, chatMessages);\r\n      }\r\n    }\r\n\r\n    // Only sync state data\r\n    const stateData: any = {\r\n      id: chatHelpers.id,\r\n      error: chatHelpers.error,\r\n      status: chatHelpers.status,\r\n      messages: nextMessages,\r\n    };\r\n\r\n    // Sync functions separately and only once\r\n    const functionsData = {\r\n      sendMessage: chatHelpers.sendMessage,\r\n      regenerate: chatHelpers.regenerate,\r\n      stop: chatHelpers.stop,\r\n      resumeStream: chatHelpers.resumeStream,\r\n      addToolResult: chatHelpers.addToolResult,\r\n      setMessages: chatHelpers.setMessages,\r\n      clearError: chatHelpers.clearError,\r\n    };\r\n\r\n    const chatState = { ...stateData, ...functionsData };\r\n\r\n    if (enableBatching) {\r\n      // Use requestAnimationFrame for batching if available\r\n    if (\r\n      typeof window !== \"undefined\" &&\r\n      typeof window.requestAnimationFrame === \"function\"\r\n    ) {\r\n      window.requestAnimationFrame(() => syncState(chatState));\r\n    } else {\r\n      syncState(chatState);\r\n    }\r\n    } else {\r\n      syncState(chatState);\r\n    }\r\n  }, [\r\n    // Only depend on data that actually changes, not function references\r\n    chatHelpers.id,\r\n    chatHelpers.messages,\r\n    chatHelpers.error,\r\n    chatHelpers.status,\r\n    syncState,\r\n    enableBatching,\r\n    chatHelpers.resumeStream,\r\n    chatHelpers.clearError,\r\n    chatHelpers.sendMessage,\r\n    store,\r\n    chatHelpers.setMessages,\r\n    chatHelpers.stop,\r\n    chatHelpers.regenerate,\r\n    chatHelpers.addToolResult,\r\n  ]);\r\n\r\n  // Return the store's messages as the source of truth, not chatHelpers.messages\r\n  // Subscribe to store messages so this is reactive\r\n  const storeMessages = useStore(\r\n    store as any,\r\n    (state: any) => state.messages as TMessage[],\r\n  );\r\n\r\n  return {\r\n    ...chatHelpers,\r\n    messages: storeMessages || chatHelpers.messages,\r\n  };\r\n}\r\n","\"use client\";\r\n\r\nimport type { UIMessage } from \"@ai-sdk/react\";\r\nimport { useCallback, useEffect, useMemo } from \"react\";\r\nimport { useChatMessages, useChatStore } from \"./hooks\";\r\n\r\n/**\r\n * Interface for a data part extracted from messages\r\n */\r\nexport interface DataPart<T = unknown> {\r\n  type: string;\r\n  data: T;\r\n  timestamp?: number;\r\n}\r\n\r\n/**\r\n * Result of useDataParts hook\r\n */\r\nexport interface UseDataPartsReturn {\r\n  /** All data parts grouped by type (without 'data-' prefix) */\r\n  byType: Record<string, DataPart<unknown>>;\r\n  /** Array of all data parts */\r\n  all: DataPart<unknown>[];\r\n}\r\n\r\n/**\r\n * Options for useDataPart hook\r\n */\r\nexport interface UseDataPartOptions<T = unknown> {\r\n  /** Include callback fired when the data part updates */\r\n  onData?: (data: DataPart<T>) => void;\r\n}\r\n\r\n/**\r\n * Hook to extract and access all data parts from messages.\r\n * Returns the latest value for each data part type.\r\n *\r\n * @example\r\n * ```tsx\r\n * function MyComponent() {\r\n *   const { byType, all } = useDataParts();\r\n *\r\n *   const agentStatus = byType['agent-status'];\r\n *   const rateLimit = byType['rate-limit'];\r\n *\r\n *   return (\r\n *     <div>\r\n *       {agentStatus && <p>Status: {agentStatus.data.status}</p>}\r\n *       {rateLimit && <p>Remaining: {rateLimit.data.remaining}</p>}\r\n *     </div>\r\n *   );\r\n * }\r\n * ```\r\n */\r\nexport function useDataParts(): UseDataPartsReturn {\r\n  const messages = useChatMessages();\r\n\r\n  return useMemo(() => {\r\n    const dataParts = extractDataPartsFromMessages(messages);\r\n\r\n    // Group by type, keeping only the latest for each type\r\n    // Strip 'data-' prefix from keys for cleaner API\r\n    const byType: Record<string, DataPart<unknown>> = {};\r\n\r\n    for (const dataPart of dataParts) {\r\n      const key = dataPart.type.replace(/^data-/, \"\");\r\n      const existing = byType[key];\r\n      if (\r\n        !existing ||\r\n        (dataPart.timestamp &&\r\n          existing.timestamp &&\r\n          dataPart.timestamp > existing.timestamp)\r\n      ) {\r\n        byType[key] = dataPart;\r\n      }\r\n    }\r\n\r\n    return {\r\n      byType,\r\n      all: Object.values(byType),\r\n    };\r\n  }, [messages]);\r\n}\r\n\r\n/**\r\n * Hook to extract and access a specific data part by type.\r\n * Returns a tuple with the data and a clear function, similar to useState.\r\n *\r\n * @template T - The type of the data part's data property\r\n * @param type - The data part type without 'data-' prefix (e.g., 'agent-status', 'rate-limit')\r\n * @param options - Optional configuration including onData callback\r\n * @returns Tuple of [data, clearFunction] - data is the latest value, clearFunction removes the data part\r\n *\r\n * @example\r\n * ```tsx\r\n * function AgentStatusIndicator() {\r\n *   const [agentStatus, clearStatus] = useDataPart<{ status: string; agent: string }>('agent-status');\r\n *\r\n *   if (!agentStatus) return null;\r\n *\r\n *   return (\r\n *     <div>\r\n *       <p>Agent {agentStatus.agent} is {agentStatus.status}</p>\r\n *       <button onClick={clearStatus}>Clear</button>\r\n *     </div>\r\n *   );\r\n * }\r\n * ```\r\n *\r\n * @example With callback\r\n * ```tsx\r\n * function RateLimitMonitor() {\r\n *   const [rateLimit] = useDataPart('rate-limit', {\r\n *     onData: (data) => {\r\n *       if (data.data.remaining < 10) {\r\n *         toast.warning('Rate limit running low!');\r\n *       }\r\n *     }\r\n *   });\r\n *\r\n *   return rateLimit ? <p>{rateLimit.remaining} requests remaining</p> : null;\r\n * }\r\n * ```\r\n */\r\nexport function useDataPart<T = unknown>(\r\n  type: string,\r\n  options?: UseDataPartOptions<T>,\r\n): [T | null, () => void] {\r\n  const messages = useChatMessages();\r\n  const { onData } = options || {};\r\n  \r\n  // Subscribe to the transient data map directly so we re-render when it changes\r\n  const transientDataParts = useChatStore((state) => state._transientDataParts);\r\n  const removeTransientDataPart = useChatStore((state) => state.removeTransientDataPart);\r\n\r\n  const result = useMemo(() => {\r\n    const dataParts = extractDataPartsFromMessages(messages);\r\n\r\n    // Find the latest data part of the specified type\r\n    // Automatically prepend 'data-' prefix for matching\r\n    const fullType = type.startsWith(\"data-\") ? type : `data-${type}`;\r\n    let latest: DataPart<T> | null = null;\r\n\r\n    for (const dataPart of dataParts) {\r\n      if (dataPart.type === fullType) {\r\n        if (\r\n          !latest ||\r\n          (dataPart.timestamp &&\r\n            latest.timestamp &&\r\n            dataPart.timestamp > latest.timestamp)\r\n        ) {\r\n          latest = dataPart as DataPart<T>;\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Check transient data parts if not found in messages\r\n    if (!latest) {\r\n      const transientData = transientDataParts.get(fullType);\r\n      if (transientData !== undefined) {\r\n        latest = {\r\n          type: fullType,\r\n          data: transientData,\r\n        };\r\n      }\r\n    }\r\n\r\n    return latest;\r\n  }, [messages, type, transientDataParts]);\r\n\r\n  // Call onData callback when data changes\r\n  useEffect(() => {\r\n    if (result && onData) {\r\n      onData(result);\r\n    }\r\n  }, [result, onData]);\r\n\r\n  // Memoize clear function to maintain referential equality\r\n  const clear = useCallback(() => {\r\n    const fullType = type.startsWith(\"data-\") ? type : `data-${type}`;\r\n    removeTransientDataPart(fullType);\r\n  }, [type, removeTransientDataPart]);\r\n\r\n  return [result ? result.data : null, clear];\r\n}\r\n\r\n/**\r\n * Extract all data parts from messages.\r\n * Data parts are identified by types starting with \"data-\".\r\n */\r\nfunction extractDataPartsFromMessages(\r\n  messages: UIMessage[],\r\n): DataPart<unknown>[] {\r\n  const dataParts: DataPart<unknown>[] = [];\r\n\r\n  for (const message of messages) {\r\n    // Check message parts for data parts\r\n    if (message.parts && Array.isArray(message.parts)) {\r\n      for (const part of message.parts) {\r\n        // Check if this part is a data part (starts with \"data-\")\r\n        if (part.type.startsWith(\"data-\") && \"data\" in part) {\r\n          const dataPart = part as {\r\n            type: string;\r\n            data: unknown;\r\n            timestamp?: number;\r\n          };\r\n          if (dataPart.data !== undefined) {\r\n            dataParts.push({\r\n              type: dataPart.type,\r\n              data: dataPart.data,\r\n              timestamp: dataPart.timestamp || Date.now(),\r\n            });\r\n          }\r\n        }\r\n\r\n        // Also check tool call results that might contain data parts\r\n        if (part.type.startsWith(\"tool-\") && \"result\" in part && part.result) {\r\n          const result = part.result;\r\n          if (typeof result === \"object\" && result && \"parts\" in result) {\r\n            const parts = (result as { parts?: unknown[] }).parts;\r\n            if (Array.isArray(parts)) {\r\n              for (const nestedPart of parts) {\r\n                const typedPart = nestedPart as {\r\n                  type?: string;\r\n                  data?: unknown;\r\n                  timestamp?: number;\r\n                };\r\n                if (\r\n                  typedPart.type?.startsWith(\"data-\") &&\r\n                  typedPart.data !== undefined\r\n                ) {\r\n                  dataParts.push({\r\n                    type: typedPart.type,\r\n                    data: typedPart.data,\r\n                    timestamp: typedPart.timestamp || Date.now(),\r\n                  });\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return dataParts;\r\n}\r\n"],"mappings":"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","names":["import_react","import_zustand","useOriginalChat","storeMessages","import_react"]}