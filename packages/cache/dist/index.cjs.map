{"version":3,"sources":["../../artifacts/src/utils.ts","../../artifacts/src/artifact.ts","../../artifacts/src/context.ts","../../artifacts/src/streaming.ts","../../artifacts/src/types.ts","../src/cache-store.ts","../src/backends/memory.ts","../src/backends/redis.ts","../src/backends/factory.ts","../src/cache.ts"],"names":["generateIdAi","cached","writer","getWriter","result"],"mappings":"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","file":"index.cjs","sourcesContent":["import { generateId as generateIdAi } from \"ai\";\r\nimport type { z } from \"zod\";\r\n\r\nexport function generateId(): string {\r\n  return `artifact_${Date.now()}_${generateIdAi()}`;\r\n}\r\n\r\nexport function getDefaults<T>(schema: z.ZodSchema<T>): Partial<T> {\r\n  try {\r\n    return schema.parse({});\r\n  } catch {\r\n    return {};\r\n  }\r\n}\r\n","import type { UIMessageStreamWriter } from \"ai\";\r\nimport type { z } from \"zod\";\r\nimport { StreamingArtifact } from \"./streaming\";\r\nimport type { ArtifactConfig, ArtifactData } from \"./types\";\r\nimport { generateId, getDefaults } from \"./utils\";\r\n\r\nexport function artifact<T>(id: string, schema: z.ZodSchema<T>) {\r\n  const config: ArtifactConfig<T> = { id, schema };\r\n\r\n  return {\r\n    id,\r\n    schema,\r\n\r\n    create(data: Partial<T> = {}): ArtifactData<T> {\r\n      const defaults = getDefaults(schema);\r\n      const validated = schema.parse({ ...defaults, ...data });\r\n\r\n      return {\r\n        id: generateId(),\r\n        type: id,\r\n        status: \"idle\",\r\n        payload: validated,\r\n        version: 1,\r\n        createdAt: Date.now(),\r\n        updatedAt: Date.now(),\r\n      };\r\n    },\r\n\r\n    stream(\r\n      data: Partial<T>,\r\n      writer: UIMessageStreamWriter,\r\n    ): StreamingArtifact<T> {\r\n      const instance = this.create(data);\r\n      instance.status = \"loading\";\r\n      return new StreamingArtifact(config, instance, writer);\r\n    },\r\n\r\n    validate(data: unknown): T {\r\n      return schema.parse(data);\r\n    },\r\n\r\n    isValid(data: unknown): data is T {\r\n      try {\r\n        schema.parse(data);\r\n        return true;\r\n      } catch {\r\n        return false;\r\n      }\r\n    },\r\n  };\r\n}\r\n","/**\r\n * Artifacts Writer Access\r\n *\r\n * Provides access to the stream writer from tool executionOptions.\r\n * The writer is needed to stream artifact updates to the client.\r\n *\r\n */\r\n\r\nimport type { UIMessageStreamWriter } from \"ai\";\r\n\r\n/**\r\n * Get writer from execution context\r\n *\r\n * @param executionOptions - Tool execution options from AI SDK\r\n * @returns The stream writer\r\n *\r\n * @example\r\n * ```typescript\r\n * export const myTool = tool({\r\n *   execute: async (params, executionOptions) => {\r\n *     const writer = getWriter(executionOptions);\r\n *     const artifact = MyArtifact.stream(data, writer);\r\n *   }\r\n * });\r\n * ```\r\n */\r\nexport function getWriter(executionOptions?: any): UIMessageStreamWriter {\r\n  // AI SDK passes context via experimental_context\r\n  const writer = executionOptions?.experimental_context?.writer;\r\n\r\n  if (!writer) {\r\n    throw new Error(\r\n      \"Writer not available. Make sure you're passing executionOptions: getWriter(executionOptions)\",\r\n    );\r\n  }\r\n\r\n  return writer;\r\n}\r\n","import type { UIMessageStreamWriter } from \"ai\";\r\nimport type { ArtifactConfig, ArtifactData } from \"./types\";\r\n\r\nexport class StreamingArtifact<T> {\r\n  private config: ArtifactConfig<T>;\r\n  private instance: ArtifactData<T>;\r\n  private writer: UIMessageStreamWriter;\r\n\r\n  constructor(\r\n    config: ArtifactConfig<T>,\r\n    instance: ArtifactData<T>,\r\n    writer: UIMessageStreamWriter,\r\n  ) {\r\n    this.config = config;\r\n    this.instance = instance;\r\n    this.writer = writer;\r\n\r\n    // Send initial state\r\n    this.stream();\r\n  }\r\n\r\n  get data(): T {\r\n    return this.instance.payload;\r\n  }\r\n\r\n  get id(): string {\r\n    return this.instance.id;\r\n  }\r\n\r\n  get progress(): number | undefined {\r\n    return this.instance.progress;\r\n  }\r\n\r\n  set progress(value: number | undefined) {\r\n    this.instance.progress = value;\r\n    this.instance.updatedAt = Date.now();\r\n    this.stream();\r\n  }\r\n\r\n  async update(updates: Partial<T> & { progress?: number }): Promise<void> {\r\n    if (\"progress\" in updates) {\r\n      this.instance.progress = updates.progress;\r\n      delete (updates as Record<string, unknown>).progress; // Remove progress from payload updates\r\n    }\r\n\r\n    this.instance.payload = { ...this.instance.payload, ...updates };\r\n    this.instance.status = \"streaming\";\r\n    this.instance.version++;\r\n    this.instance.updatedAt = Date.now();\r\n    this.stream();\r\n  }\r\n\r\n  async complete(finalData?: T): Promise<void> {\r\n    if (finalData) {\r\n      this.instance.payload = finalData;\r\n    }\r\n    this.instance.status = \"complete\";\r\n    this.instance.progress = 1;\r\n    this.instance.version++;\r\n    this.instance.updatedAt = Date.now();\r\n    this.stream();\r\n  }\r\n\r\n  async error(message: string): Promise<void> {\r\n    this.instance.status = \"error\";\r\n    this.instance.error = message;\r\n    this.instance.version++;\r\n    this.instance.updatedAt = Date.now();\r\n    this.stream();\r\n  }\r\n\r\n  async cancel(): Promise<void> {\r\n    this.instance.status = \"error\";\r\n    this.instance.error = \"Artifact was cancelled\";\r\n    this.instance.version++;\r\n    this.instance.updatedAt = Date.now();\r\n    this.stream();\r\n  }\r\n\r\n  timeout(ms: number): void {\r\n    setTimeout(() => {\r\n      if (\r\n        this.instance.status === \"loading\" ||\r\n        this.instance.status === \"streaming\"\r\n      ) {\r\n        this.error(`Artifact timed out after ${ms}ms`);\r\n      }\r\n    }, ms);\r\n  }\r\n\r\n  private stream(): void {\r\n    this.writer.write({\r\n      type: `data-artifact-${this.config.id}`,\r\n      id: this.instance.id,\r\n      data: this.instance,\r\n    });\r\n  }\r\n}\r\n","import type { z } from \"zod\";\r\n\r\nexport type ArtifactStatus =\r\n  | \"idle\"\r\n  | \"loading\"\r\n  | \"streaming\"\r\n  | \"complete\"\r\n  | \"error\";\r\n\r\nexport class ArtifactError extends Error {\r\n  constructor(\r\n    public code: string,\r\n    message: string,\r\n  ) {\r\n    super(message);\r\n    this.name = \"ArtifactError\";\r\n  }\r\n}\r\n\r\nexport interface ArtifactData<T = unknown> {\r\n  id: string;\r\n  type: string;\r\n  status: ArtifactStatus;\r\n  payload: T;\r\n  version: number;\r\n  progress?: number;\r\n  error?: string;\r\n  createdAt: number;\r\n  updatedAt: number;\r\n}\r\n\r\nexport interface ArtifactConfig<T = unknown> {\r\n  id: string;\r\n  schema: z.ZodSchema<T>;\r\n}\r\n\r\nexport interface ArtifactStreamPart<T = unknown> {\r\n  type: `data-artifact-${string}`;\r\n  id: string;\r\n  data: ArtifactData<T>;\r\n}\r\n\r\nexport interface ArtifactCallbacks<T = unknown> {\r\n  onUpdate?: (data: T, prevData: T | null) => void;\r\n  onComplete?: (data: T) => void;\r\n  onError?: (error: string, data: T | null) => void;\r\n  onProgress?: (progress: number, data: T) => void;\r\n  onStatusChange?: (status: ArtifactStatus, prevStatus: ArtifactStatus) => void;\r\n}\r\n\r\nexport interface UseArtifactOptions<T = unknown> extends ArtifactCallbacks<T> {\r\n  version?: number;\r\n}\r\n\r\nexport interface UseArtifactReturn<T = unknown> {\r\n  data: T | null;\r\n  status: ArtifactStatus;\r\n  progress?: number;\r\n  error?: string;\r\n  isActive: boolean;\r\n  hasData: boolean;\r\n  versions: ArtifactData<T>[];\r\n  currentIndex?: number;\r\n}\r\n\r\nexport interface UseArtifactActions {\r\n  delete: (artifactId: string) => void;\r\n}\r\n\r\nexport interface UseArtifactsOptions {\r\n  onData?: (artifactType: string, data: ArtifactData<unknown>) => void;\r\n  storeId?: string;\r\n  include?: string[]; // Only listen to these artifact types\r\n  exclude?: string[]; // Ignore these artifact types\r\n  value?: string | null; // Optional: externally controlled active type\r\n  onChange?: (value: string | null) => void; // Optional: callback when active type changes\r\n  dismissed?: string[]; // Optional: externally controlled dismissed types\r\n  onDismissedChange?: (dismissed: string[]) => void; // Optional: callback when dismissed types change\r\n}\r\n\r\nexport interface UseArtifactsReturn {\r\n  byType: Record<string, ArtifactData<unknown>[]>;\r\n  latestByType: Record<string, ArtifactData<unknown>>;\r\n  artifacts: ArtifactData<unknown>[];\r\n  current: ArtifactData<unknown> | null;\r\n  activeType: string | null;\r\n  activeArtifacts: ArtifactData<unknown>[];\r\n  types: string[];\r\n  latestArtifactType: string | null;\r\n  available: string[];\r\n  dismissed: string[];\r\n}\r\n\r\nexport interface UseArtifactsActions {\r\n  setValue: (value: string | null) => void;\r\n  dismiss: (type: string) => void;\r\n  restore: (type: string) => void;\r\n}\r\n","import type { CacheEntry, CacheStore } from \"./types\";\r\n\r\n/**\r\n * LRU (Least Recently Used) cache implementation\r\n */\r\nexport class LRUCacheStore<T = any> implements CacheStore<T> {\r\n  private cache = new Map<string, CacheEntry<T>>();\r\n  private maxSize: number;\r\n\r\n  constructor(maxSize = 1000) {\r\n    this.maxSize = maxSize;\r\n  }\r\n\r\n  get(key: string): CacheEntry<T> | undefined {\r\n    const entry = this.cache.get(key);\r\n    if (entry) {\r\n      // Move to end (most recently used)\r\n      this.cache.delete(key);\r\n      this.cache.set(key, entry);\r\n    }\r\n    return entry;\r\n  }\r\n\r\n  set(key: string, entry: CacheEntry<T>): void {\r\n    // Remove if already exists\r\n    if (this.cache.has(key)) {\r\n      this.cache.delete(key);\r\n    }\r\n    // Evict oldest if at capacity\r\n    else if (this.cache.size >= this.maxSize) {\r\n      const firstKey = this.cache.keys().next().value;\r\n      if (firstKey) {\r\n        this.cache.delete(firstKey);\r\n      }\r\n    }\r\n\r\n    this.cache.set(key, entry);\r\n  }\r\n\r\n  delete(key: string): boolean {\r\n    return this.cache.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.cache.clear();\r\n  }\r\n\r\n  has(key: string): boolean {\r\n    return this.cache.has(key);\r\n  }\r\n\r\n  size(): number {\r\n    return this.cache.size;\r\n  }\r\n\r\n  keys(): string[] {\r\n    return Array.from(this.cache.keys());\r\n  }\r\n\r\n  getDefaultTTL?(): number | undefined {\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * Simple Map-based cache store (no LRU eviction)\r\n */\r\nexport class SimpleCacheStore<T = any> implements CacheStore<T> {\r\n  private cache = new Map<string, CacheEntry<T>>();\r\n  private maxSize: number;\r\n\r\n  constructor(maxSize = 1000) {\r\n    this.maxSize = maxSize;\r\n  }\r\n\r\n  get(key: string): CacheEntry<T> | undefined {\r\n    return this.cache.get(key);\r\n  }\r\n\r\n  set(key: string, entry: CacheEntry<T>): void {\r\n    // Simple eviction: clear all if at capacity\r\n    if (this.cache.size >= this.maxSize) {\r\n      this.cache.clear();\r\n    }\r\n    this.cache.set(key, entry);\r\n  }\r\n\r\n  delete(key: string): boolean {\r\n    return this.cache.delete(key);\r\n  }\r\n\r\n  clear(): void {\r\n    this.cache.clear();\r\n  }\r\n\r\n  has(key: string): boolean {\r\n    return this.cache.has(key);\r\n  }\r\n\r\n  size(): number {\r\n    return this.cache.size;\r\n  }\r\n\r\n  keys(): string[] {\r\n    return Array.from(this.cache.keys());\r\n  }\r\n\r\n  getDefaultTTL?(): number | undefined {\r\n    return undefined;\r\n  }\r\n}\r\n","import type { CacheEntry, CacheStore } from \"../types\";\r\n\r\n/**\r\n * Enhanced memory cache store with better performance characteristics\r\n */\r\nexport class MemoryCacheStore<T = any> implements CacheStore<T> {\r\n  private cache = new Map<string, CacheEntry<T>>();\r\n  private accessOrder = new Map<string, number>();\r\n  private maxSize: number;\r\n  private accessCounter = 0;\r\n\r\n  constructor(maxSize = 1000) {\r\n    this.maxSize = maxSize;\r\n  }\r\n\r\n  get(key: string): CacheEntry<T> | undefined {\r\n    const entry = this.cache.get(key);\r\n    if (entry) {\r\n      // Update access order for LRU\r\n      this.accessOrder.set(key, ++this.accessCounter);\r\n    }\r\n    return entry;\r\n  }\r\n\r\n  set(key: string, entry: CacheEntry<T>): void {\r\n    // If key already exists, just update it\r\n    if (this.cache.has(key)) {\r\n      this.cache.set(key, entry);\r\n      this.accessOrder.set(key, ++this.accessCounter);\r\n      return;\r\n    }\r\n\r\n    // If at capacity, evict least recently used\r\n    if (this.cache.size >= this.maxSize) {\r\n      this.evictLRU();\r\n    }\r\n\r\n    this.cache.set(key, entry);\r\n    this.accessOrder.set(key, ++this.accessCounter);\r\n  }\r\n\r\n  delete(key: string): boolean {\r\n    const deleted = this.cache.delete(key);\r\n    if (deleted) {\r\n      this.accessOrder.delete(key);\r\n    }\r\n    return deleted;\r\n  }\r\n\r\n  clear(): void {\r\n    this.cache.clear();\r\n    this.accessOrder.clear();\r\n    this.accessCounter = 0;\r\n  }\r\n\r\n  has(key: string): boolean {\r\n    return this.cache.has(key);\r\n  }\r\n\r\n  size(): number {\r\n    return this.cache.size;\r\n  }\r\n\r\n  keys(): string[] {\r\n    return Array.from(this.cache.keys());\r\n  }\r\n\r\n  getDefaultTTL?(): number | undefined {\r\n    return undefined;\r\n  }\r\n\r\n  private evictLRU(): void {\r\n    let oldestKey: string | undefined;\r\n    let oldestAccess = Infinity;\r\n\r\n    for (const [key, accessTime] of this.accessOrder) {\r\n      if (accessTime < oldestAccess) {\r\n        oldestAccess = accessTime;\r\n        oldestKey = key;\r\n      }\r\n    }\r\n\r\n    if (oldestKey) {\r\n      this.cache.delete(oldestKey);\r\n      this.accessOrder.delete(oldestKey);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   */\r\n  getStats() {\r\n    return {\r\n      size: this.cache.size,\r\n      maxSize: this.maxSize,\r\n      utilization: this.cache.size / this.maxSize,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clean up expired entries based on TTL\r\n   */\r\n  cleanup(ttl: number): number {\r\n    const now = Date.now();\r\n    let cleaned = 0;\r\n\r\n    for (const [key, entry] of this.cache) {\r\n      if (now - entry.timestamp > ttl) {\r\n        this.cache.delete(key);\r\n        this.accessOrder.delete(key);\r\n        cleaned++;\r\n      }\r\n    }\r\n\r\n    return cleaned;\r\n  }\r\n}\r\n","import type { CacheEntry, CacheStore } from \"../types\";\r\n\r\n/**\r\n * Redis cache store implementation\r\n * Requires redis client to be provided\r\n */\r\nexport class RedisCacheStore<T = any> implements CacheStore<T> {\r\n  private redis: any;\r\n  private keyPrefix: string;\r\n\r\n  constructor(redisClient: any, keyPrefix = \"ai-tools-cache:\") {\r\n    this.redis = redisClient;\r\n    this.keyPrefix = keyPrefix;\r\n  }\r\n\r\n  private getKey(key: string): string {\r\n    return `${this.keyPrefix}${key}`;\r\n  }\r\n\r\n  async get(key: string): Promise<CacheEntry<T> | undefined> {\r\n    try {\r\n      const data = await this.redis.get(this.getKey(key));\r\n      if (!data) return undefined;\r\n      \r\n      // Handle different Redis client return types\r\n      let jsonString: string;\r\n      if (typeof data === 'string') {\r\n        jsonString = data;\r\n      } else if (typeof data === 'object') {\r\n        // Some Redis clients return objects directly\r\n        return {\r\n          result: data.result,\r\n          timestamp: data.timestamp,\r\n          key: data.key,\r\n        };\r\n      } else {\r\n        // Convert other types to string\r\n        jsonString = String(data);\r\n      }\r\n      \r\n      const parsed = JSON.parse(jsonString);\r\n      return {\r\n        result: parsed.result,\r\n        timestamp: parsed.timestamp,\r\n        key: parsed.key,\r\n      };\r\n    } catch (error) {\r\n      console.warn(`Redis cache get error for key ${key}:`, error);\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  async set(key: string, entry: CacheEntry<T>): Promise<void> {\r\n    try {\r\n      const data = JSON.stringify({\r\n        result: entry.result,\r\n        timestamp: entry.timestamp,\r\n        key: entry.key,\r\n      });\r\n      \r\n      await this.redis.set(this.getKey(key), data);\r\n    } catch (error) {\r\n      console.warn(`Redis cache set error for key ${key}:`, error);\r\n    }\r\n  }\r\n\r\n  async setWithTTL(key: string, entry: CacheEntry<T>, ttlSeconds: number): Promise<void> {\r\n    try {\r\n      const data = JSON.stringify({\r\n        result: entry.result,\r\n        timestamp: entry.timestamp,\r\n        key: entry.key,\r\n      });\r\n      \r\n      await this.redis.setex(this.getKey(key), ttlSeconds, data);\r\n    } catch (error) {\r\n      console.warn(`Redis cache setex error for key ${key}:`, error);\r\n    }\r\n  }\r\n\r\n  async delete(key: string): Promise<boolean> {\r\n    try {\r\n      const result = await this.redis.del(this.getKey(key));\r\n      return result > 0;\r\n    } catch (error) {\r\n      console.warn(`Redis cache delete error for key ${key}:`, error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    try {\r\n      const keys = await this.redis.keys(`${this.keyPrefix}*`);\r\n      if (keys.length > 0) {\r\n        await this.redis.del(...keys);\r\n      }\r\n    } catch (error) {\r\n      console.warn(\"Redis cache clear error:\", error);\r\n    }\r\n  }\r\n\r\n  async has(key: string): Promise<boolean> {\r\n    try {\r\n      const exists = await this.redis.exists(this.getKey(key));\r\n      return exists > 0;\r\n    } catch (error) {\r\n      console.warn(`Redis cache exists error for key ${key}:`, error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async size(): Promise<number> {\r\n    try {\r\n      const keys = await this.redis.keys(`${this.keyPrefix}*`);\r\n      return keys.length;\r\n    } catch (error) {\r\n      console.warn(\"Redis cache size error:\", error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  async keys(): Promise<string[]> {\r\n    try {\r\n      const keys = await this.redis.keys(`${this.keyPrefix}*`);\r\n      return keys.map((key: string) => key.replace(this.keyPrefix, \"\"));\r\n    } catch (error) {\r\n      console.warn(\"Redis cache keys error:\", error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  getDefaultTTL?(): number | undefined {\r\n    return undefined;\r\n  }\r\n}\r\n","import type { CacheStore } from \"../types\";\r\nimport { LRUCacheStore, SimpleCacheStore } from \"../cache-store\";\r\nimport { MemoryCacheStore } from \"./memory\";\r\nimport { RedisCacheStore } from \"./redis\";\r\n\r\n/**\r\n * Cache backend configuration\r\n */\r\nexport interface CacheBackendConfig {\r\n  type: \"memory\" | \"lru\" | \"simple\" | \"redis\";\r\n  maxSize?: number;\r\n  defaultTTL?: number;\r\n  redis?: {\r\n    client: any;\r\n    keyPrefix?: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Factory function to create cache backends\r\n */\r\nexport function createCacheBackend<T = any>(config: CacheBackendConfig): CacheStore<T> {\r\n  let store: CacheStore<T>;\r\n  \r\n  switch (config.type) {\r\n    case \"memory\":\r\n      store = new MemoryCacheStore<T>(config.maxSize);\r\n      break;\r\n    \r\n    case \"lru\":\r\n      store = new LRUCacheStore<T>(config.maxSize);\r\n      break;\r\n    \r\n    case \"simple\":\r\n      store = new SimpleCacheStore<T>(config.maxSize);\r\n      break;\r\n    \r\n    case \"redis\":\r\n      if (!config.redis?.client) {\r\n        throw new Error(\"Redis client is required for redis cache backend\");\r\n      }\r\n      store = new RedisCacheStore<T>(config.redis.client, config.redis.keyPrefix);\r\n      break;\r\n    \r\n    default:\r\n      throw new Error(`Unknown cache backend type: ${(config as any).type}`);\r\n  }\r\n  \r\n  // Add default TTL support if configured\r\n  if (config.defaultTTL) {\r\n    (store as any).getDefaultTTL = () => config.defaultTTL;\r\n  }\r\n  \r\n  return store;\r\n}\r\n\r\n/**\r\n * Global cache backend configuration\r\n */\r\nlet globalCacheBackend: CacheStore | null = null;\r\n\r\n/**\r\n * Configure global cache backend\r\n */\r\nexport function configureCacheBackend(config: CacheBackendConfig): void {\r\n  globalCacheBackend = createCacheBackend(config);\r\n}\r\n\r\n/**\r\n * Get the global cache backend\r\n */\r\nexport function getGlobalCacheBackend<T = any>(): CacheStore<T> | null {\r\n  return globalCacheBackend as CacheStore<T> | null;\r\n}\r\n\r\n/**\r\n * Reset global cache backend\r\n */\r\nexport function resetCacheBackend(): void {\r\n  globalCacheBackend = null;\r\n}\r\n","import type { Tool } from \"ai\";\r\nimport { createCacheBackend } from \"./backends/factory\";\r\nimport { LRUCacheStore } from \"./cache-store\";\r\nimport type { CachedTool, CacheOptions, CacheStats, CacheStore } from \"./types\";\r\n\r\n/**\r\n * Default cache key generator - stable and deterministic\r\n */\r\nfunction defaultKeyGenerator(params: any, context?: any): string {\r\n  const paramsKey = serializeValue(params);\r\n\r\n  if (context) {\r\n    return `${paramsKey}|${context}`;\r\n  }\r\n\r\n  return paramsKey;\r\n}\r\n\r\n/**\r\n * Serialize a value to a stable string representation\r\n */\r\nfunction serializeValue(value: any): string {\r\n  // Handle different parameter types like React Query\r\n  if (value === null || value === undefined) {\r\n    return \"null\";\r\n  }\r\n\r\n  if (\r\n    typeof value === \"string\" ||\r\n    typeof value === \"number\" ||\r\n    typeof value === \"boolean\"\r\n  ) {\r\n    return String(value);\r\n  }\r\n\r\n  if (value instanceof Date) {\r\n    return value.toISOString();\r\n  }\r\n\r\n  if (Array.isArray(value)) {\r\n    return `[${value.map(serializeValue).join(\",\")}]`;\r\n  }\r\n\r\n  if (typeof value === \"object\") {\r\n    // Sort keys for deterministic serialization (like React Query)\r\n    const sortedKeys = Object.keys(value).sort();\r\n    const pairs = sortedKeys.map(\r\n      (key) => `${key}:${serializeValue(value[key])}`,\r\n    );\r\n    return `{${pairs.join(\",\")}}`;\r\n  }\r\n\r\n  return String(value);\r\n}\r\n\r\n/**\r\n * Simple streaming tool cache - just adds cache API methods without interfering\r\n */\r\nfunction createStreamingCachedTool<T extends Tool>(\r\n  tool: T,\r\n  options: CacheOptions,\r\n): CachedTool<T> {\r\n  const {\r\n    ttl = 5 * 60 * 1000,\r\n    maxSize = 1000,\r\n    store,\r\n    keyGenerator = defaultKeyGenerator,\r\n    cacheKey,\r\n    shouldCache = () => true,\r\n    onHit,\r\n    onMiss,\r\n    debug = false,\r\n  } = options;\r\n\r\n  const cacheStore = store || new LRUCacheStore(maxSize);\r\n  let hits = 0;\r\n  let misses = 0;\r\n\r\n  // Add cache API methods and override execute with caching logic\r\n  return {\r\n    ...tool,\r\n    execute: async function* (...args: any[]) {\r\n      const [params, executionOptions] = args;\r\n      // Get context from cacheKey function\r\n      const context = cacheKey?.();\r\n      const key = keyGenerator(params, context);\r\n      const now = Date.now();\r\n\r\n      // Check cache first\r\n      const cached = await cacheStore.get(key);\r\n      if (cached && now - cached.timestamp < ttl) {\r\n        hits++;\r\n        onHit?.(key);\r\n\r\n        const result = cached.result;\r\n\r\n        if (debug) {\r\n          const yields = result?.streamResults?.length || 0;\r\n          const artifacts = result?.messages?.length || 0;\r\n          const hasReturn = result?.returnValue !== undefined;\r\n\r\n          console.log(`\\n Cache HIT - Streaming Tool`);\r\n          console.log(\r\n            ` Key: ${key.slice(0, 60)}${key.length > 60 ? \"...\" : \"\"}`,\r\n          );\r\n          console.log(` Streaming yields: ${yields}`);\r\n          console.log(` Artifact messages: ${artifacts}`);\r\n          console.log(` Return value: ${hasReturn ? \"yes\" : \"no\"}`);\r\n          console.log(` Restoring cached results...\\n`);\r\n        }\r\n\r\n        // Replay artifact messages first\r\n        if (result?.messages?.length > 0) {\r\n          let writer =\r\n            executionOptions?.writer ||\r\n            (executionOptions as any)?.experimental_context?.writer;\r\n\r\n          // Writer comes from AI SDK's experimental_context\r\n          if (!writer) {\r\n            try {\r\n              const { getWriter } = await import(\"@ai-sdk-tools/artifacts\");\r\n              writer = getWriter(executionOptions);\r\n            } catch {\r\n              // Artifacts package not available or writer not available\r\n            }\r\n          }\r\n\r\n          if (writer) {\r\n            if (debug)\r\n              console.log(\r\n                `   Replaying ${result.messages.length} artifact messages...`,\r\n              );\r\n            for (const msg of result.messages) {\r\n              writer.write(msg);\r\n            }\r\n            if (debug) console.log(`   Artifacts restored`);\r\n          }\r\n        }\r\n\r\n        // Replay streaming yields\r\n        if (result?.streamResults) {\r\n          if (debug)\r\n            console.log(\r\n              `   Replaying ${result.streamResults.length} streaming yields...`,\r\n            );\r\n          for (const item of result.streamResults) {\r\n            yield item;\r\n          }\r\n          if (debug) console.log(`   Streaming content restored`);\r\n        }\r\n\r\n        return result.returnValue;\r\n      }\r\n\r\n      // Cache miss - execute original and capture\r\n      misses++;\r\n      onMiss?.(key);\r\n      if (debug) {\r\n        console.log(`\\n Cache MISS - Streaming Tool`);\r\n        console.log(\r\n          ` Key: ${key.slice(0, 60)}${key.length > 60 ? \"...\" : \"\"}`,\r\n        );\r\n        console.log(\r\n          ` Will capture: streaming yields + artifact messages + return value`,\r\n        );\r\n        console.log(` Executing tool and capturing results...\\n`);\r\n      }\r\n\r\n      // Capture writer messages\r\n      let writer =\r\n        executionOptions?.writer ||\r\n        (executionOptions as any)?.experimental_context?.writer;\r\n\r\n      // Writer comes from AI SDK's experimental_context\r\n      if (!writer) {\r\n        try {\r\n          const { getWriter } = await import(\"@ai-sdk-tools/artifacts\");\r\n          writer = getWriter(executionOptions);\r\n        } catch {\r\n          // Artifacts package not available or writer not available\r\n        }\r\n      }\r\n\r\n      const capturedMessages: any[] = [];\r\n\r\n      if (writer) {\r\n        const originalWrite = writer.write;\r\n        writer.write = (data: any) => {\r\n          capturedMessages.push(data);\r\n          return originalWrite.call(writer, data);\r\n        };\r\n      }\r\n\r\n      // Execute original tool\r\n      const originalResult = await tool.execute?.(params, executionOptions);\r\n\r\n      // Create tee generator that streams and caches\r\n      let lastChunk: any = null;\r\n      let finalReturnValue: any;\r\n      let chunkCount = 0;\r\n\r\n      if (\r\n        originalResult &&\r\n        typeof originalResult[Symbol.asyncIterator] === \"function\"\r\n      ) {\r\n        const iterator = originalResult[Symbol.asyncIterator]();\r\n        let iterResult = await iterator.next();\r\n\r\n        while (!iterResult.done) {\r\n          lastChunk = iterResult.value; // Just keep the last chunk (it has full text)\r\n          chunkCount++;\r\n\r\n          // Debug logging only for first few yields to avoid spam\r\n          if (debug && chunkCount <= 3) {\r\n            console.log(\r\n              `   Capturing yield #${chunkCount}:`,\r\n              `${lastChunk?.text?.slice(0, 40)}...`,\r\n            );\r\n          }\r\n          yield iterResult.value; // Stream immediately\r\n          iterResult = await iterator.next();\r\n        }\r\n\r\n        finalReturnValue = iterResult.value;\r\n      }\r\n\r\n      queueMicrotask(() => {\r\n        // This runs after all current synchronous operations and promises\r\n        queueMicrotask(async () => {\r\n          try {\r\n            // Store only the final chunk (it already has the complete text)\r\n            const completeResult = {\r\n              streamResults: lastChunk ? [lastChunk] : [], // Only final chunk\r\n              messages: capturedMessages,\r\n              returnValue: finalReturnValue,\r\n              type: \"streaming\",\r\n            };\r\n\r\n            if (shouldCache(params, completeResult)) {\r\n              await cacheStore.set(key, {\r\n                result: completeResult,\r\n                timestamp: now,\r\n                key,\r\n              });\r\n              if (debug) {\r\n                const cacheItems =\r\n                  typeof cacheStore.size === \"function\"\r\n                    ? await cacheStore.size()\r\n                    : \"unknown\";\r\n\r\n                // Calculate approximate memory usage\r\n                const estimatedSize = JSON.stringify(completeResult).length;\r\n                const sizeKB = Math.round((estimatedSize / 1024) * 100) / 100;\r\n\r\n                console.log(`\\n Cache STORED - Streaming Tool`);\r\n                console.log(` Streaming yields: ${chunkCount}`);\r\n                console.log(` Artifact messages: ${capturedMessages.length}`);\r\n                console.log(\r\n                  ` Return value: ${finalReturnValue !== undefined ? \"yes\" : \"no\"}`,\r\n                );\r\n                console.log(` Entry size: ~${sizeKB}KB`);\r\n                console.log(` Cache items: ${cacheItems}/${maxSize}`);\r\n                console.log(` Ready for instant replay!\\n`);\r\n              }\r\n            }\r\n          } catch (error) {\r\n            if (debug) console.log(`[Cache] Microtask caching failed:`, error);\r\n          }\r\n        });\r\n      });\r\n\r\n      return finalReturnValue;\r\n    },\r\n    getStats() {\r\n      const total = hits + misses;\r\n      return {\r\n        hits,\r\n        misses,\r\n        hitRate: total > 0 ? hits / total : 0,\r\n        size:\r\n          typeof cacheStore.size === \"function\"\r\n            ? (cacheStore.size() as any)\r\n            : 0,\r\n        maxSize,\r\n      };\r\n    },\r\n    clearCache(key?: string) {\r\n      if (key) {\r\n        cacheStore.delete(key);\r\n      } else {\r\n        cacheStore.clear();\r\n      }\r\n    },\r\n    async isCached(params: any) {\r\n      const context = cacheKey?.();\r\n      const key = keyGenerator(params, context);\r\n      const cached = await cacheStore.get(key);\r\n      if (!cached) return false;\r\n\r\n      const now = Date.now();\r\n      const isValid = now - cached.timestamp < ttl;\r\n\r\n      if (!isValid) {\r\n        await cacheStore.delete(key);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    },\r\n    getCacheKey(params: any) {\r\n      const context = cacheKey?.();\r\n      return keyGenerator(params, context);\r\n    },\r\n  } as unknown as CachedTool<T>;\r\n}\r\n\r\nexport function cached<T extends Tool>(\r\n  tool: T,\r\n  options?: CacheOptions,\r\n): CachedTool<T> {\r\n  // For streaming tools, implement proper caching\r\n  if (tool.execute?.constructor?.name === \"AsyncGeneratorFunction\") {\r\n    return createStreamingCachedTool(tool, options || {});\r\n  }\r\n  const {\r\n    ttl = 5 * 60 * 1000,\r\n    maxSize = 1000,\r\n    store,\r\n    keyGenerator = defaultKeyGenerator,\r\n    cacheKey,\r\n    shouldCache = () => true,\r\n    onHit,\r\n    onMiss,\r\n    debug = false,\r\n  } = options || {};\r\n\r\n  const cacheStore = store || new LRUCacheStore(maxSize);\r\n  const effectiveTTL = ttl ?? cacheStore.getDefaultTTL?.() ?? 5 * 60 * 1000;\r\n  let hits = 0;\r\n  let misses = 0;\r\n\r\n  const log = debug ? console.log : () => {};\r\n\r\n  const cacheApi = {\r\n    getStats(): CacheStats {\r\n      const total = hits + misses;\r\n      return {\r\n        hits,\r\n        misses,\r\n        hitRate: total > 0 ? hits / total : 0,\r\n        size:\r\n          typeof cacheStore.size === \"function\"\r\n            ? (cacheStore.size() as any)\r\n            : 0,\r\n        maxSize,\r\n      };\r\n    },\r\n\r\n    clearCache(key?: string): void {\r\n      if (key) {\r\n        cacheStore.delete(key);\r\n      } else {\r\n        cacheStore.clear();\r\n      }\r\n    },\r\n\r\n    async isCached(params: any): Promise<boolean> {\r\n      const context = cacheKey?.();\r\n      const key = keyGenerator(params, context);\r\n      const cached = await cacheStore.get(key);\r\n      if (!cached) return false;\r\n\r\n      const now = Date.now();\r\n      const isValid = now - cached.timestamp < effectiveTTL;\r\n\r\n      if (!isValid) {\r\n        await cacheStore.delete(key);\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    },\r\n\r\n    getCacheKey(params: any): string {\r\n      const context = cacheKey?.();\r\n      return keyGenerator(params, context);\r\n    },\r\n  };\r\n\r\n  const cachedTool = new Proxy(tool, {\r\n    get(target, prop) {\r\n      if (prop === \"execute\") {\r\n        // Preserve the original function type\r\n        if (target.execute?.constructor?.name === \"AsyncGeneratorFunction\") {\r\n          return async function* (...args: any[]) {\r\n            const [params, executionOptions] = args;\r\n            const context = cacheKey?.();\r\n            const key = keyGenerator(params, context);\r\n            const now = Date.now();\r\n\r\n            // Check cache\r\n            const cached = await cacheStore.get(key);\r\n            if (cached && now - cached.timestamp < effectiveTTL) {\r\n              hits++;\r\n              onHit?.(key);\r\n              log(`[Cache] HIT`);\r\n\r\n              const result = cached.result;\r\n\r\n              // For streaming tools, replay messages immediately then return generator\r\n              if (\r\n                target.execute?.constructor?.name === \"AsyncGeneratorFunction\"\r\n              ) {\r\n                // Replay messages IMMEDIATELY to restore artifact data\r\n                if (result?.messages?.length > 0) {\r\n                  const writer =\r\n                    executionOptions?.writer ||\r\n                    (executionOptions as any)?.experimental_context?.writer;\r\n\r\n                  if (writer) {\r\n                    log(`[Cache] Replaying ${result.messages.length} messages`);\r\n                    for (const msg of result.messages) {\r\n                      writer.write(msg);\r\n                    }\r\n                  }\r\n                }\r\n\r\n                // Then return generator that yields stream results\r\n                return (async function* () {\r\n                  if (result?.streamResults) {\r\n                    for (const item of result.streamResults) {\r\n                      yield item;\r\n                    }\r\n                  } else if (Array.isArray(result)) {\r\n                    for (const item of result) {\r\n                      yield item;\r\n                    }\r\n                  } else {\r\n                    yield result;\r\n                  }\r\n                })();\r\n              }\r\n\r\n              return result;\r\n            }\r\n\r\n            // Execute original\r\n            misses++;\r\n            onMiss?.(key);\r\n            log(`[Cache] MISS`);\r\n\r\n            // Capture messages if writer available\r\n            const writer =\r\n              executionOptions?.writer ||\r\n              (executionOptions as any)?.experimental_context?.writer;\r\n\r\n            const capturedMessages: any[] = [];\r\n\r\n            if (writer) {\r\n              const originalWrite = writer.write;\r\n              writer.write = (data: any) => {\r\n                capturedMessages.push(data);\r\n                return originalWrite.call(writer, data);\r\n              };\r\n            }\r\n\r\n            const result = await target.execute?.(params, executionOptions);\r\n\r\n            // Handle streaming tools\r\n            if (\r\n              result &&\r\n              typeof (result as any)[Symbol.asyncIterator] === \"function\"\r\n            ) {\r\n              const streamResults: any[] = [];\r\n              let lastChunk: any = null;\r\n\r\n              // Stream to user immediately while capturing\r\n              const streamGenerator = (async function* () {\r\n                for await (const chunk of result as any) {\r\n                  streamResults.push(chunk);\r\n                  lastChunk = chunk;\r\n                  yield chunk; // Stream immediately to user\r\n                }\r\n\r\n                // After streaming completes, cache only the final chunk\r\n                queueMicrotask(async () => {\r\n                  const completeResult = {\r\n                    streamResults: lastChunk ? [lastChunk] : [], // Only store final chunk\r\n                    messages: capturedMessages,\r\n                    type: \"streaming\",\r\n                  };\r\n\r\n                  if (shouldCache(params, completeResult)) {\r\n                    await cacheStore.set(key, {\r\n                      result: completeResult,\r\n                      timestamp: now,\r\n                      key,\r\n                    });\r\n                    log(\r\n                      `[Cache] STORED streaming result with ${capturedMessages.length} messages`,\r\n                    );\r\n                  }\r\n                });\r\n              })();\r\n\r\n              return streamGenerator;\r\n            }\r\n\r\n            // Regular tool\r\n            if (shouldCache(params, result)) {\r\n              await cacheStore.set(key, {\r\n                result,\r\n                timestamp: now,\r\n                key,\r\n              });\r\n              log(`[Cache] STORED result`);\r\n            }\r\n\r\n            return result;\r\n          };\r\n        } else {\r\n          // Regular async function\r\n          return async (...args: any[]) => {\r\n            const [params, executionOptions] = args;\r\n            const context = cacheKey?.();\r\n            const key = keyGenerator(params, context);\r\n            const now = Date.now();\r\n\r\n            // Check cache\r\n            const cached = await cacheStore.get(key);\r\n            if (cached && now - cached.timestamp < effectiveTTL) {\r\n              hits++;\r\n              onHit?.(key);\r\n              log(`[Cache] HIT`);\r\n              return cached.result;\r\n            }\r\n\r\n            // Execute original\r\n            misses++;\r\n            onMiss?.(key);\r\n            log(`[Cache] MISS`);\r\n\r\n            const result = await target.execute?.(params, executionOptions);\r\n\r\n            if (shouldCache(params, result)) {\r\n              await cacheStore.set(key, {\r\n                result,\r\n                timestamp: now,\r\n                key,\r\n              });\r\n              log(`[Cache] STORED result`);\r\n            }\r\n\r\n            return result;\r\n          };\r\n        }\r\n      }\r\n\r\n      if (prop in cacheApi) {\r\n        return cacheApi[prop as keyof typeof cacheApi];\r\n      }\r\n\r\n      return target[prop as keyof typeof target];\r\n    },\r\n  }) as unknown as CachedTool<T>;\r\n\r\n  return cachedTool;\r\n}\r\n\r\n/**\r\n * Creates a pre-configured cached function with default options\r\n */\r\nexport function createCachedFunction(\r\n  store: CacheStore,\r\n  defaultOptions: Omit<CacheOptions, \"store\"> = {},\r\n) {\r\n  return <T extends Tool>(\r\n    tool: T,\r\n    options: Omit<CacheOptions, \"store\"> = {},\r\n  ): CachedTool<T> => {\r\n    return cached(tool, { ...defaultOptions, ...options, store });\r\n  };\r\n}\r\n\r\n/**\r\n * Cache multiple tools with the same configuration\r\n */\r\nexport function cacheTools<T extends Tool, TTools extends Record<string, T>>(\r\n  tools: T,\r\n  options: CacheOptions = {},\r\n): { [K in keyof TTools]: CachedTool<TTools[K]> } {\r\n  const cachedTools = {} as { [K in keyof TTools]: CachedTool<TTools[K]> };\r\n\r\n  for (const [name, tool] of Object.entries(tools)) {\r\n    cachedTools[name as keyof TTools] = cached(tool, options);\r\n  }\r\n\r\n  return cachedTools;\r\n}\r\n\r\n/**\r\n * Create a cached function with Redis client or default LRU\r\n *\r\n * Example usage:\r\n * ```ts\r\n * import { Redis } from \"@upstash/redis\";\r\n * import { createCached } from \"@ai-sdk-tools/cache\";\r\n *\r\n * // Upstash Redis\r\n * const cached = createCached({ cache: Redis.fromEnv() });\r\n *\r\n * // Standard Redis\r\n * const cached = createCached({ cache: Redis.createClient() });\r\n *\r\n * // Default LRU (no cache client)\r\n * const cached = createCached();\r\n * ```\r\n */\r\nexport function createCached(\r\n  options: {\r\n    cache?: any; // User's Redis client - we pass it directly\r\n    keyPrefix?: string;\r\n    ttl?: number;\r\n    debug?: boolean;\r\n    cacheKey?: () => string;\r\n    onHit?: (key: string) => void;\r\n    onMiss?: (key: string) => void;\r\n  } = {},\r\n) {\r\n  // If no cache provided, use default LRU\r\n  if (!options.cache) {\r\n    const lruStore = createCacheBackend({\r\n      type: \"lru\",\r\n      maxSize: 100,\r\n      defaultTTL: options.ttl || 10 * 60 * 1000, // 10 minutes default\r\n    });\r\n\r\n    return createCachedFunction(lruStore, {\r\n      debug: options.debug || false,\r\n      cacheKey: options.cacheKey,\r\n      onHit: options.onHit,\r\n      onMiss: options.onMiss,\r\n    });\r\n  }\r\n\r\n  // Use Redis client directly - no adapter needed!\r\n  const redisStore = createCacheBackend({\r\n    type: \"redis\",\r\n    defaultTTL: options.ttl || 30 * 60 * 1000, // 30 minutes default\r\n    redis: {\r\n      client: options.cache, // Pass user's Redis client directly\r\n      keyPrefix: options.keyPrefix || \"ai-tools-cache:\",\r\n    },\r\n  });\r\n\r\n  return createCachedFunction(redisStore, {\r\n    debug: options.debug || false,\r\n    cacheKey: options.cacheKey,\r\n    onHit: options.onHit,\r\n    onMiss: options.onMiss,\r\n  });\r\n}\r\n"]}