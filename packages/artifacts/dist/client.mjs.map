{"version":3,"sources":["../src/streaming.ts","../src/utils.ts","../src/artifact.ts","../src/context.ts","../src/hooks.ts","../src/types.ts"],"sourcesContent":["import type { UIMessageStreamWriter } from \"ai\";\r\nimport type { ArtifactConfig, ArtifactData } from \"./types\";\r\n\r\nexport class StreamingArtifact<T> {\r\n  private config: ArtifactConfig<T>;\r\n  private instance: ArtifactData<T>;\r\n  private writer: UIMessageStreamWriter;\r\n\r\n  constructor(\r\n    config: ArtifactConfig<T>,\r\n    instance: ArtifactData<T>,\r\n    writer: UIMessageStreamWriter,\r\n  ) {\r\n    this.config = config;\r\n    this.instance = instance;\r\n    this.writer = writer;\r\n\r\n    // Send initial state\r\n    this.stream();\r\n  }\r\n\r\n  get data(): T {\r\n    return this.instance.payload;\r\n  }\r\n\r\n  get id(): string {\r\n    return this.instance.id;\r\n  }\r\n\r\n  get progress(): number | undefined {\r\n    return this.instance.progress;\r\n  }\r\n\r\n  set progress(value: number | undefined) {\r\n    this.instance.progress = value;\r\n    this.instance.updatedAt = Date.now();\r\n    this.stream();\r\n  }\r\n\r\n  async update(updates: Partial<T> & { progress?: number }): Promise<void> {\r\n    if (\"progress\" in updates) {\r\n      this.instance.progress = updates.progress;\r\n      delete (updates as Record<string, unknown>).progress; // Remove progress from payload updates\r\n    }\r\n\r\n    this.instance.payload = { ...this.instance.payload, ...updates };\r\n    this.instance.status = \"streaming\";\r\n    this.instance.version++;\r\n    this.instance.updatedAt = Date.now();\r\n    this.stream();\r\n  }\r\n\r\n  async complete(finalData?: T): Promise<void> {\r\n    if (finalData) {\r\n      this.instance.payload = finalData;\r\n    }\r\n    this.instance.status = \"complete\";\r\n    this.instance.progress = 1;\r\n    this.instance.version++;\r\n    this.instance.updatedAt = Date.now();\r\n    this.stream();\r\n  }\r\n\r\n  async error(message: string): Promise<void> {\r\n    this.instance.status = \"error\";\r\n    this.instance.error = message;\r\n    this.instance.version++;\r\n    this.instance.updatedAt = Date.now();\r\n    this.stream();\r\n  }\r\n\r\n  async cancel(): Promise<void> {\r\n    this.instance.status = \"error\";\r\n    this.instance.error = \"Artifact was cancelled\";\r\n    this.instance.version++;\r\n    this.instance.updatedAt = Date.now();\r\n    this.stream();\r\n  }\r\n\r\n  timeout(ms: number): void {\r\n    setTimeout(() => {\r\n      if (\r\n        this.instance.status === \"loading\" ||\r\n        this.instance.status === \"streaming\"\r\n      ) {\r\n        this.error(`Artifact timed out after ${ms}ms`);\r\n      }\r\n    }, ms);\r\n  }\r\n\r\n  private stream(): void {\r\n    this.writer.write({\r\n      type: `data-artifact-${this.config.id}`,\r\n      id: this.instance.id,\r\n      data: this.instance,\r\n    });\r\n  }\r\n}\r\n","import { generateId as generateIdAi } from \"ai\";\r\nimport type { z } from \"zod\";\r\n\r\nexport function generateId(): string {\r\n  return `artifact_${Date.now()}_${generateIdAi()}`;\r\n}\r\n\r\nexport function getDefaults<T>(schema: z.ZodSchema<T>): Partial<T> {\r\n  try {\r\n    return schema.parse({});\r\n  } catch {\r\n    return {};\r\n  }\r\n}\r\n","import type { UIMessageStreamWriter } from \"ai\";\r\nimport type { z } from \"zod\";\r\nimport { StreamingArtifact } from \"./streaming\";\r\nimport type { ArtifactConfig, ArtifactData } from \"./types\";\r\nimport { generateId, getDefaults } from \"./utils\";\r\n\r\nexport function artifact<T>(id: string, schema: z.ZodSchema<T>) {\r\n  const config: ArtifactConfig<T> = { id, schema };\r\n\r\n  return {\r\n    id,\r\n    schema,\r\n\r\n    create(data: Partial<T> = {}): ArtifactData<T> {\r\n      const defaults = getDefaults(schema);\r\n      const validated = schema.parse({ ...defaults, ...data });\r\n\r\n      return {\r\n        id: generateId(),\r\n        type: id,\r\n        status: \"idle\",\r\n        payload: validated,\r\n        version: 1,\r\n        createdAt: Date.now(),\r\n        updatedAt: Date.now(),\r\n      };\r\n    },\r\n\r\n    stream(\r\n      data: Partial<T>,\r\n      writer: UIMessageStreamWriter,\r\n    ): StreamingArtifact<T> {\r\n      const instance = this.create(data);\r\n      instance.status = \"loading\";\r\n      return new StreamingArtifact(config, instance, writer);\r\n    },\r\n\r\n    validate(data: unknown): T {\r\n      return schema.parse(data);\r\n    },\r\n\r\n    isValid(data: unknown): data is T {\r\n      try {\r\n        schema.parse(data);\r\n        return true;\r\n      } catch {\r\n        return false;\r\n      }\r\n    },\r\n  };\r\n}\r\n","/**\r\n * Artifacts Writer Access\r\n *\r\n * Provides access to the stream writer from tool executionOptions.\r\n * The writer is needed to stream artifact updates to the client.\r\n *\r\n */\r\n\r\nimport type { UIMessageStreamWriter } from \"ai\";\r\n\r\n/**\r\n * Get writer from execution context\r\n *\r\n * @param executionOptions - Tool execution options from AI SDK\r\n * @returns The stream writer\r\n *\r\n * @example\r\n * ```typescript\r\n * export const myTool = tool({\r\n *   execute: async (params, executionOptions) => {\r\n *     const writer = getWriter(executionOptions);\r\n *     const artifact = MyArtifact.stream(data, writer);\r\n *   }\r\n * });\r\n * ```\r\n */\r\nexport function getWriter(executionOptions?: any): UIMessageStreamWriter {\r\n  // AI SDK passes context via experimental_context\r\n  const writer = executionOptions?.experimental_context?.writer;\r\n\r\n  if (!writer) {\r\n    throw new Error(\r\n      \"Writer not available. Make sure you're passing executionOptions: getWriter(executionOptions)\",\r\n    );\r\n  }\r\n\r\n  return writer;\r\n}\r\n","import type { UIMessage } from \"@ai-sdk/react\";\r\nimport { useChatActions, useChatMessages } from \"@ai-sdk-tools/store\";\r\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\r\nimport type { z } from \"zod\";\r\nimport type {\r\n  ArtifactData,\r\n  ArtifactStatus,\r\n  UseArtifactActions,\r\n  UseArtifactOptions,\r\n  UseArtifactReturn,\r\n  UseArtifactsActions,\r\n  UseArtifactsOptions,\r\n  UseArtifactsReturn,\r\n} from \"./types\";\r\n\r\n// Type to extract the inferred type from an artifact definition\r\ntype InferArtifactType<T> = T extends { schema: z.ZodSchema<infer U> }\r\n  ? U\r\n  : never;\r\n\r\n// Types for message parts that might contain artifacts\r\ninterface ArtifactPart<T = unknown> {\r\n  type: string;\r\n  data?: ArtifactData<T>;\r\n}\r\n\r\n/**\r\n * Remove artifact part from a message by artifact ID\r\n */\r\nfunction removeArtifactFromMessage(\r\n  message: UIMessage,\r\n  artifactId: string,\r\n): UIMessage | null {\r\n  if (!message.parts || !Array.isArray(message.parts)) {\r\n    return message;\r\n  }\r\n\r\n  const updatedParts = message.parts.filter((part) => {\r\n    // Check if this part is an artifact part\r\n    if (part.type.startsWith(\"data-artifact-\") && \"data\" in part) {\r\n      const artifactPart = part as { type: string; data?: { id?: string } };\r\n      if (artifactPart.data?.id === artifactId) {\r\n        return false; // Remove this part\r\n      }\r\n    }\r\n\r\n    // Check tool call results that might contain artifacts\r\n    if (part.type.startsWith(\"tool-\") && \"result\" in part && part.result) {\r\n      const result = part.result;\r\n      if (typeof result === \"object\" && result && \"parts\" in result) {\r\n        const parts = (result as { parts?: unknown[] }).parts;\r\n        if (Array.isArray(parts)) {\r\n          const filteredParts = parts.filter((nestedPart: unknown) => {\r\n            const part = nestedPart as {\r\n              type?: string;\r\n              data?: { id?: string };\r\n            };\r\n            if (\r\n              part.type?.startsWith(\"data-artifact-\") &&\r\n              part.data?.id === artifactId\r\n            ) {\r\n              return false; // Remove this nested part\r\n            }\r\n            return true;\r\n          });\r\n\r\n          // If we removed parts, update the result\r\n          if (filteredParts.length !== parts.length) {\r\n            const toolPart = part as {\r\n              type: string;\r\n              result?: unknown;\r\n            };\r\n            toolPart.result = {\r\n              ...(result as Record<string, unknown>),\r\n              parts: filteredParts,\r\n            };\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  });\r\n\r\n  // If no parts remain, return null to indicate message should be removed\r\n  if (updatedParts.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  return {\r\n    ...message,\r\n    parts: updatedParts,\r\n  };\r\n}\r\n\r\nexport function useArtifact<\r\n  T extends { id: string; schema: z.ZodSchema<unknown> },\r\n>(\r\n  artifactDef: T,\r\n  options?: UseArtifactOptions<InferArtifactType<T>>,\r\n): [UseArtifactReturn<InferArtifactType<T>>, UseArtifactActions] {\r\n  // Get messages from the chat store\r\n  const messages = useChatMessages();\r\n  const { replaceMessageById } = useChatActions();\r\n  const { version: versionIndex } = options || {};\r\n  const includeVersions = versionIndex !== undefined;\r\n\r\n  // Store callbacks in ref to avoid dependency issues\r\n  const callbacksRef = useRef(options);\r\n  useEffect(() => {\r\n    callbacksRef.current = options;\r\n  }, [options]);\r\n\r\n  const [currentArtifact, setCurrentArtifact] = useState<ArtifactData<\r\n    InferArtifactType<T>\r\n  > | null>(null);\r\n\r\n  // Get all artifacts (needed for both version selection and latest tracking)\r\n  const allArtifacts = useMemo(\r\n    () =>\r\n      extractArtifactsFromMessages<InferArtifactType<T>>(\r\n        messages,\r\n        artifactDef.id,\r\n      ),\r\n    [messages, artifactDef.id],\r\n  );\r\n  const latest = allArtifacts[0] || null;\r\n\r\n  useEffect(() => {\r\n    if (\r\n      latest &&\r\n      (!currentArtifact ||\r\n        latest.version > currentArtifact.version ||\r\n        (latest.version === currentArtifact.version &&\r\n          latest.createdAt > currentArtifact.createdAt))\r\n    ) {\r\n      const prevData = currentArtifact?.payload || null;\r\n      const currentCallbacks = callbacksRef.current;\r\n\r\n      // Fire callbacks only for latest artifact (when not using version selection)\r\n      if (!includeVersions) {\r\n        if (\r\n          currentCallbacks &&\r\n          \"onUpdate\" in currentCallbacks &&\r\n          currentCallbacks.onUpdate &&\r\n          latest.payload !== prevData\r\n        ) {\r\n          currentCallbacks.onUpdate(latest.payload, prevData);\r\n        }\r\n\r\n        if (\r\n          currentCallbacks &&\r\n          \"onComplete\" in currentCallbacks &&\r\n          currentCallbacks.onComplete &&\r\n          latest.status === \"complete\" &&\r\n          currentArtifact?.status !== \"complete\"\r\n        ) {\r\n          currentCallbacks.onComplete(latest.payload);\r\n        }\r\n\r\n        if (\r\n          currentCallbacks &&\r\n          \"onError\" in currentCallbacks &&\r\n          currentCallbacks.onError &&\r\n          latest.status === \"error\" &&\r\n          currentArtifact?.status !== \"error\"\r\n        ) {\r\n          currentCallbacks.onError(\r\n            latest.error || \"Unknown error\",\r\n            latest.payload,\r\n          );\r\n        }\r\n\r\n        if (\r\n          currentCallbacks &&\r\n          \"onProgress\" in currentCallbacks &&\r\n          currentCallbacks.onProgress &&\r\n          latest.progress !== currentArtifact?.progress\r\n        ) {\r\n          currentCallbacks.onProgress(latest.progress || 0, latest.payload);\r\n        }\r\n\r\n        if (\r\n          currentCallbacks &&\r\n          \"onStatusChange\" in currentCallbacks &&\r\n          currentCallbacks.onStatusChange &&\r\n          latest.status !== currentArtifact?.status\r\n        ) {\r\n          currentCallbacks.onStatusChange(\r\n            latest.status,\r\n            currentArtifact?.status || \"idle\",\r\n          );\r\n        }\r\n      }\r\n\r\n      setCurrentArtifact(latest);\r\n    }\r\n  }, [latest, currentArtifact, includeVersions]);\r\n\r\n  // Memoize stable empty versions array for default case\r\n  const emptyVersions = useMemo(\r\n    () => [] as ArtifactData<InferArtifactType<T>>[],\r\n    [],\r\n  );\r\n\r\n  // Create delete function\r\n  const deleteArtifact = useCallback(\r\n    (artifactId: string) => {\r\n      // Find the message containing this artifact\r\n      for (const message of messages) {\r\n        if (!message.parts || !Array.isArray(message.parts)) continue;\r\n\r\n        // Check message parts\r\n        for (const part of message.parts) {\r\n          if (part.type.startsWith(\"data-artifact-\") && \"data\" in part) {\r\n            const artifactPart = part as {\r\n              type: string;\r\n              data?: { id?: string };\r\n            };\r\n            if (artifactPart.data?.id === artifactId) {\r\n              const updatedMessage = removeArtifactFromMessage(\r\n                message,\r\n                artifactId,\r\n              );\r\n              if (updatedMessage) {\r\n                replaceMessageById(message.id, updatedMessage);\r\n              }\r\n              return;\r\n            }\r\n          }\r\n\r\n          // Check tool call results\r\n          if (\r\n            part.type.startsWith(\"tool-\") &&\r\n            \"result\" in part &&\r\n            part.result\r\n          ) {\r\n            const result = part.result;\r\n            if (typeof result === \"object\" && result && \"parts\" in result) {\r\n              const parts = (result as { parts?: unknown[] }).parts;\r\n              if (Array.isArray(parts)) {\r\n                const hasArtifact = parts.some((p: unknown) => {\r\n                  const part = p as { type?: string; data?: { id?: string } };\r\n                  return (\r\n                    part.type?.startsWith(\"data-artifact-\") &&\r\n                    part.data?.id === artifactId\r\n                  );\r\n                });\r\n                if (hasArtifact) {\r\n                  const updatedMessage = removeArtifactFromMessage(\r\n                    message,\r\n                    artifactId,\r\n                  );\r\n                  if (updatedMessage) {\r\n                    replaceMessageById(message.id, updatedMessage);\r\n                  }\r\n                  return;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    },\r\n    [messages, replaceMessageById],\r\n  );\r\n\r\n  // Memoize actions object\r\n  const actions = useMemo(\r\n    (): UseArtifactActions => ({\r\n      delete: deleteArtifact,\r\n    }),\r\n    [deleteArtifact],\r\n  );\r\n\r\n  // Memoize return value - handle both version selection and latest artifact cases\r\n  const artifactData = useMemo(() => {\r\n    // If version index is provided, return that specific version\r\n    if (includeVersions && versionIndex !== undefined) {\r\n      // Clamp version index to valid range\r\n      const clampedIndex = Math.max(\r\n        0,\r\n        Math.min(versionIndex, allArtifacts.length - 1),\r\n      );\r\n      const selectedArtifact =\r\n        allArtifacts[clampedIndex] || allArtifacts[0] || null;\r\n\r\n      const status: ArtifactStatus = selectedArtifact?.status || \"idle\";\r\n      const isActive = status === \"loading\" || status === \"streaming\";\r\n\r\n      return {\r\n        data: selectedArtifact?.payload || null,\r\n        status,\r\n        progress: selectedArtifact?.progress,\r\n        error: selectedArtifact?.error,\r\n        isActive,\r\n        hasData: selectedArtifact !== null,\r\n        versions: allArtifacts,\r\n        currentIndex: clampedIndex,\r\n      };\r\n    }\r\n\r\n    // Default behavior: return latest artifact\r\n    const status: ArtifactStatus = currentArtifact?.status || \"idle\";\r\n    const isActive = status === \"loading\" || status === \"streaming\";\r\n\r\n    return {\r\n      data: currentArtifact?.payload || null,\r\n      status,\r\n      progress: currentArtifact?.progress,\r\n      error: currentArtifact?.error,\r\n      isActive,\r\n      hasData: currentArtifact !== null,\r\n      versions: emptyVersions,\r\n    };\r\n  }, [\r\n    includeVersions,\r\n    versionIndex,\r\n    allArtifacts,\r\n    currentArtifact,\r\n    emptyVersions,\r\n  ]);\r\n\r\n  return [artifactData, actions] as [\r\n    UseArtifactReturn<InferArtifactType<T>>,\r\n    UseArtifactActions,\r\n  ];\r\n}\r\n\r\n// Listening to all artifacts with filtering options\r\n\r\nexport function useArtifacts(\r\n  options: UseArtifactsOptions = {},\r\n): [UseArtifactsReturn, UseArtifactsActions] {\r\n  const {\r\n    onData,\r\n    include,\r\n    exclude,\r\n    value: externalValue,\r\n    onChange,\r\n    dismissed: externalDismissed,\r\n    onDismissedChange,\r\n  } = options;\r\n  const messages = useChatMessages();\r\n\r\n  // Track if we've had artifacts before to detect first appearance (for auto-open)\r\n  const hadArtifactsRef = useRef(false);\r\n  // Track the previous latest artifact type to detect when a new artifact type appears\r\n  const prevLatestTypeRef = useRef<string | null>(null);\r\n  // Track if value has ever been set (to distinguish initial null from user-closed null)\r\n  const valueWasSetRef = useRef(false);\r\n\r\n  // Internal dismissed types state (for uncontrolled mode)\r\n  const [internalDismissed, setInternalDismissed] = useState<Set<string>>(\r\n    new Set(),\r\n  );\r\n\r\n  // Internal value state (for uncontrolled mode)\r\n  const [internalValue, setInternalValue] = useState<string | null>(null);\r\n\r\n  // Use external dismissed if provided, otherwise use internal\r\n  const dismissedSet = useMemo(() => {\r\n    if (externalDismissed) {\r\n      return new Set(externalDismissed);\r\n    }\r\n    return internalDismissed;\r\n  }, [externalDismissed, internalDismissed]);\r\n\r\n  // Use external value if provided (controlled), otherwise use internal (uncontrolled)\r\n  const currentValue = useMemo(() => {\r\n    if (externalValue !== undefined) {\r\n      return externalValue;\r\n    }\r\n    return internalValue;\r\n  }, [externalValue, internalValue]);\r\n\r\n  const setValue = useCallback(\r\n    (value: string | null) => {\r\n      // Mark that value has been set (to distinguish initial null from user-closed null)\r\n      valueWasSetRef.current = true;\r\n\r\n      if (onChange) {\r\n        // Controlled mode - notify parent\r\n        onChange(value);\r\n      } else {\r\n        // Uncontrolled mode - update internal state\r\n        setInternalValue(value);\r\n      }\r\n    },\r\n    [onChange],\r\n  );\r\n\r\n  const dismiss = useCallback(\r\n    (type: string) => {\r\n      const newDismissed = new Set(dismissedSet);\r\n      newDismissed.add(type);\r\n\r\n      if (externalDismissed) {\r\n        // Controlled mode - notify parent\r\n        onDismissedChange?.(Array.from(newDismissed));\r\n      } else {\r\n        // Uncontrolled mode - update internal state\r\n        setInternalDismissed(newDismissed);\r\n      }\r\n    },\r\n    [dismissedSet, externalDismissed, onDismissedChange],\r\n  );\r\n\r\n  const restore = useCallback(\r\n    (type: string) => {\r\n      const newDismissed = new Set(dismissedSet);\r\n      newDismissed.delete(type);\r\n\r\n      if (externalDismissed) {\r\n        // Controlled mode - notify parent\r\n        onDismissedChange?.(Array.from(newDismissed));\r\n      } else {\r\n        // Uncontrolled mode - update internal state\r\n        setInternalDismissed(newDismissed);\r\n      }\r\n    },\r\n    [dismissedSet, externalDismissed, onDismissedChange],\r\n  );\r\n\r\n  // Store onData in ref to avoid dependency issues\r\n  const onDataRef = useRef(onData);\r\n  useEffect(() => {\r\n    onDataRef.current = onData;\r\n  }, [onData]);\r\n\r\n  const artifactsData = useMemo(() => {\r\n    const allArtifacts = extractAllArtifactsFromMessages(messages);\r\n\r\n    // Filter artifacts based on include/exclude options\r\n    const filteredArtifacts = allArtifacts.filter((artifact) => {\r\n      if (include && include.length > 0) return include.includes(artifact.type);\r\n      if (exclude && exclude.length > 0)\r\n        return !exclude.includes(artifact.type);\r\n      return true;\r\n    });\r\n\r\n    // Group by type\r\n    const byType: Record<string, ArtifactData<unknown>[]> = {};\r\n    const latestByType: Record<string, ArtifactData<unknown>> = {};\r\n\r\n    for (const artifact of filteredArtifacts) {\r\n      if (!byType[artifact.type]) {\r\n        byType[artifact.type] = [];\r\n      }\r\n      byType[artifact.type].push(artifact);\r\n\r\n      // Track latest version for each type\r\n      if (\r\n        !latestByType[artifact.type] ||\r\n        artifact.version > latestByType[artifact.type].version ||\r\n        (artifact.version === latestByType[artifact.type].version &&\r\n          artifact.createdAt > latestByType[artifact.type].createdAt)\r\n      ) {\r\n        const prevLatest = latestByType[artifact.type];\r\n        latestByType[artifact.type] = artifact;\r\n\r\n        // Fire callback if this is a new or updated artifact\r\n        const currentOnData = onDataRef.current;\r\n        if (\r\n          currentOnData &&\r\n          (!prevLatest ||\r\n            artifact.version > prevLatest.version ||\r\n            (artifact.version === prevLatest.version &&\r\n              artifact.createdAt > prevLatest.createdAt))\r\n        ) {\r\n          currentOnData(artifact.type, artifact);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Sort each type by creation time (newest first)\r\n    for (const type in byType) {\r\n      byType[type].sort((a, b) => b.createdAt - a.createdAt);\r\n    }\r\n\r\n    // Determine active type\r\n    const types = Object.keys(byType).filter(\r\n      (type) => byType[type] && byType[type].length > 0,\r\n    );\r\n\r\n    const hasArtifacts = types.length > 0;\r\n    const hadArtifacts = hadArtifactsRef.current;\r\n\r\n    // Update ref for next render\r\n    hadArtifactsRef.current = hasArtifacts;\r\n\r\n    // Find the most recently created artifact across all types\r\n    let latestArtifact: ArtifactData<unknown> | null = null;\r\n    for (const type in latestByType) {\r\n      const artifact = latestByType[type];\r\n      if (!latestArtifact || artifact.createdAt > latestArtifact.createdAt) {\r\n        latestArtifact = artifact;\r\n      }\r\n    }\r\n    const latestArtifactType = latestArtifact\r\n      ? latestArtifact.type\r\n      : types[0] || null;\r\n\r\n    // Determine activeType - simple derivation from currentValue:\r\n    // 1. If currentValue is a valid type string → use it (canvas open)\r\n    // 2. If currentValue is null/undefined AND artifacts just appeared (first time) → auto-open to latest\r\n    // 3. Otherwise → null (closed)\r\n    let activeType: string | null = null;\r\n\r\n    if (currentValue && types.includes(currentValue)) {\r\n      // Valid type provided - use it\r\n      activeType = currentValue;\r\n    } else if (\r\n      (currentValue === null || currentValue === undefined) &&\r\n      hasArtifacts &&\r\n      !hadArtifacts &&\r\n      types.length > 0\r\n    ) {\r\n      // Artifacts first appeared and no query param - auto-open to latest\r\n      activeType = latestArtifactType;\r\n    }\r\n\r\n    const activeArtifacts = activeType ? byType[activeType] || [] : [];\r\n\r\n    // Filter available types (non-dismissed)\r\n    const available = types.filter((type) => !dismissedSet.has(type));\r\n    const dismissed = Array.from(dismissedSet).filter((type) =>\r\n      types.includes(type),\r\n    );\r\n\r\n    return {\r\n      byType,\r\n      latestByType,\r\n      artifacts: filteredArtifacts,\r\n      current: filteredArtifacts[0] || null,\r\n      activeType,\r\n      activeArtifacts,\r\n      types,\r\n      latestArtifactType,\r\n      available,\r\n      dismissed,\r\n    };\r\n  }, [messages, include, exclude, currentValue, dismissedSet]);\r\n\r\n  // Auto-switch to latest artifact: when a new artifact appears, switch to it\r\n  useEffect(() => {\r\n    const currentLatestType = artifactsData.latestArtifactType;\r\n    const prevLatestType = prevLatestTypeRef.current;\r\n\r\n    // Update ref for next render\r\n    prevLatestTypeRef.current = currentLatestType;\r\n\r\n    if (!currentLatestType) {\r\n      return;\r\n    }\r\n\r\n    // Only auto-switch when:\r\n    // 1. A NEW artifact type appears (latestArtifactType changed from something to something else)\r\n    // 2. OR first artifact appears and no query param set (initial auto-open)\r\n    if (\r\n      prevLatestType !== null &&\r\n      currentLatestType !== prevLatestType &&\r\n      artifactsData.types.includes(currentLatestType)\r\n    ) {\r\n      // A new artifact appeared - auto-switch to it\r\n      if (onChange) {\r\n        onChange(currentLatestType);\r\n      } else {\r\n        setInternalValue(currentLatestType);\r\n      }\r\n    } else if (\r\n      prevLatestType === null &&\r\n      currentLatestType !== null &&\r\n      (currentValue === null || currentValue === undefined) &&\r\n      artifactsData.activeType !== null\r\n    ) {\r\n      // First artifact appeared and no query param - sync to open it\r\n      if (onChange) {\r\n        onChange(currentLatestType);\r\n      } else {\r\n        setInternalValue(currentLatestType);\r\n      }\r\n    }\r\n  }, [\r\n    artifactsData.activeType,\r\n    artifactsData.latestArtifactType,\r\n    artifactsData.types,\r\n    currentValue,\r\n    onChange,\r\n  ]);\r\n\r\n  // Auto-restore when a type becomes active (un-dismiss it)\r\n  useEffect(() => {\r\n    if (\r\n      artifactsData.activeType &&\r\n      dismissedSet.has(artifactsData.activeType)\r\n    ) {\r\n      restore(artifactsData.activeType);\r\n    }\r\n  }, [artifactsData.activeType, dismissedSet, restore]);\r\n\r\n  // Auto-activate first available tab when there's no valid activeType\r\n  // But don't auto-activate if user explicitly closed the canvas\r\n  useEffect(() => {\r\n    // Skip auto-activation if:\r\n    // 1. Controlled mode: user explicitly set externalValue to null\r\n    // 2. Uncontrolled mode: value was previously set and is now null (user closed it)\r\n    const shouldSkipAutoActivate =\r\n      (externalValue !== undefined && externalValue === null) ||\r\n      (externalValue === undefined &&\r\n        valueWasSetRef.current &&\r\n        currentValue === null);\r\n\r\n    if (\r\n      artifactsData.available.length > 0 &&\r\n      (!artifactsData.activeType ||\r\n        !artifactsData.available.includes(artifactsData.activeType)) &&\r\n      !shouldSkipAutoActivate\r\n    ) {\r\n      // Set the first available tab as active (use setValue to mark ref)\r\n      setValue(artifactsData.available[0]);\r\n    }\r\n  }, [\r\n    artifactsData.available,\r\n    artifactsData.activeType,\r\n    externalValue,\r\n    currentValue,\r\n    setValue,\r\n  ]);\r\n\r\n  // Create actions\r\n  const actions = useMemo(\r\n    (): UseArtifactsActions => ({\r\n      setValue,\r\n      dismiss,\r\n      restore,\r\n    }),\r\n    [setValue, dismiss, restore],\r\n  );\r\n\r\n  return [artifactsData, actions] as [UseArtifactsReturn, UseArtifactsActions];\r\n}\r\n\r\nfunction extractAllArtifactsFromMessages(\r\n  messages: UIMessage[],\r\n): ArtifactData<unknown>[] {\r\n  const artifacts = new Map<string, ArtifactData<unknown>>();\r\n\r\n  for (const message of messages) {\r\n    // Check message parts for artifact data\r\n    if (message.parts && Array.isArray(message.parts)) {\r\n      for (const part of message.parts) {\r\n        // Check if this part is any artifact type\r\n        if (part.type.startsWith(\"data-artifact-\") && \"data\" in part) {\r\n          const artifactPart = part as ArtifactPart<unknown>;\r\n          if (artifactPart.data) {\r\n            const existing = artifacts.get(artifactPart.data.id);\r\n            if (\r\n              !existing ||\r\n              artifactPart.data.version > existing.version ||\r\n              (artifactPart.data.version === existing.version &&\r\n                artifactPart.data.createdAt > existing.createdAt)\r\n            ) {\r\n              artifacts.set(artifactPart.data.id, artifactPart.data);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Also check tool call results that might contain artifacts\r\n        if (part.type.startsWith(\"tool-\") && \"result\" in part && part.result) {\r\n          const result = part.result;\r\n          if (typeof result === \"object\" && result && \"parts\" in result) {\r\n            const parts = (result as { parts?: ArtifactPart<unknown>[] }).parts;\r\n            if (Array.isArray(parts)) {\r\n              for (const nestedPart of parts) {\r\n                if (\r\n                  nestedPart.type.startsWith(\"data-artifact-\") &&\r\n                  nestedPart.data\r\n                ) {\r\n                  const existing = artifacts.get(nestedPart.data.id);\r\n                  if (\r\n                    !existing ||\r\n                    nestedPart.data.version > existing.version ||\r\n                    (nestedPart.data.version === existing.version &&\r\n                      nestedPart.data.createdAt > existing.createdAt)\r\n                  ) {\r\n                    artifacts.set(nestedPart.data.id, nestedPart.data);\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return Array.from(artifacts.values()).sort(\r\n    (a, b) => b.createdAt - a.createdAt,\r\n  );\r\n}\r\n\r\nfunction extractArtifactsFromMessages<T>(\r\n  messages: UIMessage[],\r\n  artifactType: string,\r\n): ArtifactData<T>[] {\r\n  const artifacts = new Map<string, ArtifactData<T>>();\r\n\r\n  for (const message of messages) {\r\n    // Check message parts for artifact data\r\n    if (message.parts && Array.isArray(message.parts)) {\r\n      for (const part of message.parts) {\r\n        // Check if this part is an artifact of the type we're looking for\r\n        if (part.type === `data-artifact-${artifactType}` && \"data\" in part) {\r\n          const artifactPart = part as ArtifactPart<T>;\r\n          if (artifactPart.data) {\r\n            const existing = artifacts.get(artifactPart.data.id);\r\n            if (\r\n              !existing ||\r\n              artifactPart.data.version > existing.version ||\r\n              (artifactPart.data.version === existing.version &&\r\n                artifactPart.data.createdAt > existing.createdAt)\r\n            ) {\r\n              artifacts.set(artifactPart.data.id, artifactPart.data);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Also check tool call results that might contain artifacts\r\n        if (part.type.startsWith(\"tool-\") && \"result\" in part && part.result) {\r\n          const result = part.result;\r\n          if (typeof result === \"object\" && result && \"parts\" in result) {\r\n            const parts = (result as { parts?: ArtifactPart<T>[] }).parts;\r\n            if (Array.isArray(parts)) {\r\n              for (const nestedPart of parts) {\r\n                if (\r\n                  nestedPart.type === `data-artifact-${artifactType}` &&\r\n                  nestedPart.data\r\n                ) {\r\n                  const existing = artifacts.get(nestedPart.data.id);\r\n                  if (\r\n                    !existing ||\r\n                    nestedPart.data.version > existing.version ||\r\n                    (nestedPart.data.version === existing.version &&\r\n                      nestedPart.data.createdAt > existing.createdAt)\r\n                  ) {\r\n                    artifacts.set(nestedPart.data.id, nestedPart.data);\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return Array.from(artifacts.values()).sort(\r\n    (a, b) => b.createdAt - a.createdAt,\r\n  );\r\n}\r\n","import type { z } from \"zod\";\r\n\r\nexport type ArtifactStatus =\r\n  | \"idle\"\r\n  | \"loading\"\r\n  | \"streaming\"\r\n  | \"complete\"\r\n  | \"error\";\r\n\r\nexport class ArtifactError extends Error {\r\n  constructor(\r\n    public code: string,\r\n    message: string,\r\n  ) {\r\n    super(message);\r\n    this.name = \"ArtifactError\";\r\n  }\r\n}\r\n\r\nexport interface ArtifactData<T = unknown> {\r\n  id: string;\r\n  type: string;\r\n  status: ArtifactStatus;\r\n  payload: T;\r\n  version: number;\r\n  progress?: number;\r\n  error?: string;\r\n  createdAt: number;\r\n  updatedAt: number;\r\n}\r\n\r\nexport interface ArtifactConfig<T = unknown> {\r\n  id: string;\r\n  schema: z.ZodSchema<T>;\r\n}\r\n\r\nexport interface ArtifactStreamPart<T = unknown> {\r\n  type: `data-artifact-${string}`;\r\n  id: string;\r\n  data: ArtifactData<T>;\r\n}\r\n\r\nexport interface ArtifactCallbacks<T = unknown> {\r\n  onUpdate?: (data: T, prevData: T | null) => void;\r\n  onComplete?: (data: T) => void;\r\n  onError?: (error: string, data: T | null) => void;\r\n  onProgress?: (progress: number, data: T) => void;\r\n  onStatusChange?: (status: ArtifactStatus, prevStatus: ArtifactStatus) => void;\r\n}\r\n\r\nexport interface UseArtifactOptions<T = unknown> extends ArtifactCallbacks<T> {\r\n  version?: number;\r\n}\r\n\r\nexport interface UseArtifactReturn<T = unknown> {\r\n  data: T | null;\r\n  status: ArtifactStatus;\r\n  progress?: number;\r\n  error?: string;\r\n  isActive: boolean;\r\n  hasData: boolean;\r\n  versions: ArtifactData<T>[];\r\n  currentIndex?: number;\r\n}\r\n\r\nexport interface UseArtifactActions {\r\n  delete: (artifactId: string) => void;\r\n}\r\n\r\nexport interface UseArtifactsOptions {\r\n  onData?: (artifactType: string, data: ArtifactData<unknown>) => void;\r\n  storeId?: string;\r\n  include?: string[]; // Only listen to these artifact types\r\n  exclude?: string[]; // Ignore these artifact types\r\n  value?: string | null; // Optional: externally controlled active type\r\n  onChange?: (value: string | null) => void; // Optional: callback when active type changes\r\n  dismissed?: string[]; // Optional: externally controlled dismissed types\r\n  onDismissedChange?: (dismissed: string[]) => void; // Optional: callback when dismissed types change\r\n}\r\n\r\nexport interface UseArtifactsReturn {\r\n  byType: Record<string, ArtifactData<unknown>[]>;\r\n  latestByType: Record<string, ArtifactData<unknown>>;\r\n  artifacts: ArtifactData<unknown>[];\r\n  current: ArtifactData<unknown> | null;\r\n  activeType: string | null;\r\n  activeArtifacts: ArtifactData<unknown>[];\r\n  types: string[];\r\n  latestArtifactType: string | null;\r\n  available: string[];\r\n  dismissed: string[];\r\n}\r\n\r\nexport interface UseArtifactsActions {\r\n  setValue: (value: string | null) => void;\r\n  dismiss: (type: string) => void;\r\n  restore: (type: string) => void;\r\n}\r\n"],"mappings":";AAGO,IAAM,oBAAN,MAA2B;AAAA,EAKhC,YACE,QACA,UACA,QACA;AACA,SAAK,SAAS;AACd,SAAK,WAAW;AAChB,SAAK,SAAS;AAGd,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,IAAI,OAAU;AACZ,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA,EAEA,IAAI,KAAa;AACf,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA,EAEA,IAAI,WAA+B;AACjC,WAAO,KAAK,SAAS;AAAA,EACvB;AAAA,EAEA,IAAI,SAAS,OAA2B;AACtC,SAAK,SAAS,WAAW;AACzB,SAAK,SAAS,YAAY,KAAK,IAAI;AACnC,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,MAAM,OAAO,SAA4D;AACvE,QAAI,cAAc,SAAS;AACzB,WAAK,SAAS,WAAW,QAAQ;AACjC,aAAQ,QAAoC;AAAA,IAC9C;AAEA,SAAK,SAAS,UAAU,EAAE,GAAG,KAAK,SAAS,SAAS,GAAG,QAAQ;AAC/D,SAAK,SAAS,SAAS;AACvB,SAAK,SAAS;AACd,SAAK,SAAS,YAAY,KAAK,IAAI;AACnC,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,MAAM,SAAS,WAA8B;AAC3C,QAAI,WAAW;AACb,WAAK,SAAS,UAAU;AAAA,IAC1B;AACA,SAAK,SAAS,SAAS;AACvB,SAAK,SAAS,WAAW;AACzB,SAAK,SAAS;AACd,SAAK,SAAS,YAAY,KAAK,IAAI;AACnC,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,MAAM,MAAM,SAAgC;AAC1C,SAAK,SAAS,SAAS;AACvB,SAAK,SAAS,QAAQ;AACtB,SAAK,SAAS;AACd,SAAK,SAAS,YAAY,KAAK,IAAI;AACnC,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,MAAM,SAAwB;AAC5B,SAAK,SAAS,SAAS;AACvB,SAAK,SAAS,QAAQ;AACtB,SAAK,SAAS;AACd,SAAK,SAAS,YAAY,KAAK,IAAI;AACnC,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,QAAQ,IAAkB;AACxB,eAAW,MAAM;AACf,UACE,KAAK,SAAS,WAAW,aACzB,KAAK,SAAS,WAAW,aACzB;AACA,aAAK,MAAM,4BAA4B,EAAE,IAAI;AAAA,MAC/C;AAAA,IACF,GAAG,EAAE;AAAA,EACP;AAAA,EAEQ,SAAe;AACrB,SAAK,OAAO,MAAM;AAAA,MAChB,MAAM,iBAAiB,KAAK,OAAO,EAAE;AAAA,MACrC,IAAI,KAAK,SAAS;AAAA,MAClB,MAAM,KAAK;AAAA,IACb,CAAC;AAAA,EACH;AACF;;;ACjGA,SAAS,cAAc,oBAAoB;AAGpC,SAAS,aAAqB;AACnC,SAAO,YAAY,KAAK,IAAI,CAAC,IAAI,aAAa,CAAC;AACjD;AAEO,SAAS,YAAe,QAAoC;AACjE,MAAI;AACF,WAAO,OAAO,MAAM,CAAC,CAAC;AAAA,EACxB,QAAQ;AACN,WAAO,CAAC;AAAA,EACV;AACF;;;ACPO,SAAS,SAAY,IAAY,QAAwB;AAC9D,QAAM,SAA4B,EAAE,IAAI,OAAO;AAE/C,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IAEA,OAAO,OAAmB,CAAC,GAAoB;AAC7C,YAAM,WAAW,YAAY,MAAM;AACnC,YAAM,YAAY,OAAO,MAAM,EAAE,GAAG,UAAU,GAAG,KAAK,CAAC;AAEvD,aAAO;AAAA,QACL,IAAI,WAAW;AAAA,QACf,MAAM;AAAA,QACN,QAAQ;AAAA,QACR,SAAS;AAAA,QACT,SAAS;AAAA,QACT,WAAW,KAAK,IAAI;AAAA,QACpB,WAAW,KAAK,IAAI;AAAA,MACtB;AAAA,IACF;AAAA,IAEA,OACE,MACA,QACsB;AACtB,YAAM,WAAW,KAAK,OAAO,IAAI;AACjC,eAAS,SAAS;AAClB,aAAO,IAAI,kBAAkB,QAAQ,UAAU,MAAM;AAAA,IACvD;AAAA,IAEA,SAAS,MAAkB;AACzB,aAAO,OAAO,MAAM,IAAI;AAAA,IAC1B;AAAA,IAEA,QAAQ,MAA0B;AAChC,UAAI;AACF,eAAO,MAAM,IAAI;AACjB,eAAO;AAAA,MACT,QAAQ;AACN,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACF;;;ACxBO,SAAS,UAAU,kBAA+C;AAEvE,QAAM,SAAS,kBAAkB,sBAAsB;AAEvD,MAAI,CAAC,QAAQ;AACX,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;;;ACpCA,SAAS,gBAAgB,uBAAuB;AAChD,SAAS,aAAa,WAAW,SAAS,QAAQ,gBAAgB;AA2BlE,SAAS,0BACP,SACA,YACkB;AAClB,MAAI,CAAC,QAAQ,SAAS,CAAC,MAAM,QAAQ,QAAQ,KAAK,GAAG;AACnD,WAAO;AAAA,EACT;AAEA,QAAM,eAAe,QAAQ,MAAM,OAAO,CAAC,SAAS;AAElD,QAAI,KAAK,KAAK,WAAW,gBAAgB,KAAK,UAAU,MAAM;AAC5D,YAAM,eAAe;AACrB,UAAI,aAAa,MAAM,OAAO,YAAY;AACxC,eAAO;AAAA,MACT;AAAA,IACF;AAGA,QAAI,KAAK,KAAK,WAAW,OAAO,KAAK,YAAY,QAAQ,KAAK,QAAQ;AACpE,YAAM,SAAS,KAAK;AACpB,UAAI,OAAO,WAAW,YAAY,UAAU,WAAW,QAAQ;AAC7D,cAAM,QAAS,OAAiC;AAChD,YAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,gBAAM,gBAAgB,MAAM,OAAO,CAAC,eAAwB;AAC1D,kBAAMA,QAAO;AAIb,gBACEA,MAAK,MAAM,WAAW,gBAAgB,KACtCA,MAAK,MAAM,OAAO,YAClB;AACA,qBAAO;AAAA,YACT;AACA,mBAAO;AAAA,UACT,CAAC;AAGD,cAAI,cAAc,WAAW,MAAM,QAAQ;AACzC,kBAAM,WAAW;AAIjB,qBAAS,SAAS;AAAA,cAChB,GAAI;AAAA,cACJ,OAAO;AAAA,YACT;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT,CAAC;AAGD,MAAI,aAAa,WAAW,GAAG;AAC7B,WAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACL,GAAG;AAAA,IACH,OAAO;AAAA,EACT;AACF;AAEO,SAAS,YAGd,aACA,SAC+D;AAE/D,QAAM,WAAW,gBAAgB;AACjC,QAAM,EAAE,mBAAmB,IAAI,eAAe;AAC9C,QAAM,EAAE,SAAS,aAAa,IAAI,WAAW,CAAC;AAC9C,QAAM,kBAAkB,iBAAiB;AAGzC,QAAM,eAAe,OAAO,OAAO;AACnC,YAAU,MAAM;AACd,iBAAa,UAAU;AAAA,EACzB,GAAG,CAAC,OAAO,CAAC;AAEZ,QAAM,CAAC,iBAAiB,kBAAkB,IAAI,SAEpC,IAAI;AAGd,QAAM,eAAe;AAAA,IACnB,MACE;AAAA,MACE;AAAA,MACA,YAAY;AAAA,IACd;AAAA,IACF,CAAC,UAAU,YAAY,EAAE;AAAA,EAC3B;AACA,QAAM,SAAS,aAAa,CAAC,KAAK;AAElC,YAAU,MAAM;AACd,QACE,WACC,CAAC,mBACA,OAAO,UAAU,gBAAgB,WAChC,OAAO,YAAY,gBAAgB,WAClC,OAAO,YAAY,gBAAgB,YACvC;AACA,YAAM,WAAW,iBAAiB,WAAW;AAC7C,YAAM,mBAAmB,aAAa;AAGtC,UAAI,CAAC,iBAAiB;AACpB,YACE,oBACA,cAAc,oBACd,iBAAiB,YACjB,OAAO,YAAY,UACnB;AACA,2BAAiB,SAAS,OAAO,SAAS,QAAQ;AAAA,QACpD;AAEA,YACE,oBACA,gBAAgB,oBAChB,iBAAiB,cACjB,OAAO,WAAW,cAClB,iBAAiB,WAAW,YAC5B;AACA,2BAAiB,WAAW,OAAO,OAAO;AAAA,QAC5C;AAEA,YACE,oBACA,aAAa,oBACb,iBAAiB,WACjB,OAAO,WAAW,WAClB,iBAAiB,WAAW,SAC5B;AACA,2BAAiB;AAAA,YACf,OAAO,SAAS;AAAA,YAChB,OAAO;AAAA,UACT;AAAA,QACF;AAEA,YACE,oBACA,gBAAgB,oBAChB,iBAAiB,cACjB,OAAO,aAAa,iBAAiB,UACrC;AACA,2BAAiB,WAAW,OAAO,YAAY,GAAG,OAAO,OAAO;AAAA,QAClE;AAEA,YACE,oBACA,oBAAoB,oBACpB,iBAAiB,kBACjB,OAAO,WAAW,iBAAiB,QACnC;AACA,2BAAiB;AAAA,YACf,OAAO;AAAA,YACP,iBAAiB,UAAU;AAAA,UAC7B;AAAA,QACF;AAAA,MACF;AAEA,yBAAmB,MAAM;AAAA,IAC3B;AAAA,EACF,GAAG,CAAC,QAAQ,iBAAiB,eAAe,CAAC;AAG7C,QAAM,gBAAgB;AAAA,IACpB,MAAM,CAAC;AAAA,IACP,CAAC;AAAA,EACH;AAGA,QAAM,iBAAiB;AAAA,IACrB,CAAC,eAAuB;AAEtB,iBAAW,WAAW,UAAU;AAC9B,YAAI,CAAC,QAAQ,SAAS,CAAC,MAAM,QAAQ,QAAQ,KAAK,EAAG;AAGrD,mBAAW,QAAQ,QAAQ,OAAO;AAChC,cAAI,KAAK,KAAK,WAAW,gBAAgB,KAAK,UAAU,MAAM;AAC5D,kBAAM,eAAe;AAIrB,gBAAI,aAAa,MAAM,OAAO,YAAY;AACxC,oBAAM,iBAAiB;AAAA,gBACrB;AAAA,gBACA;AAAA,cACF;AACA,kBAAI,gBAAgB;AAClB,mCAAmB,QAAQ,IAAI,cAAc;AAAA,cAC/C;AACA;AAAA,YACF;AAAA,UACF;AAGA,cACE,KAAK,KAAK,WAAW,OAAO,KAC5B,YAAY,QACZ,KAAK,QACL;AACA,kBAAM,SAAS,KAAK;AACpB,gBAAI,OAAO,WAAW,YAAY,UAAU,WAAW,QAAQ;AAC7D,oBAAM,QAAS,OAAiC;AAChD,kBAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,sBAAM,cAAc,MAAM,KAAK,CAAC,MAAe;AAC7C,wBAAMA,QAAO;AACb,yBACEA,MAAK,MAAM,WAAW,gBAAgB,KACtCA,MAAK,MAAM,OAAO;AAAA,gBAEtB,CAAC;AACD,oBAAI,aAAa;AACf,wBAAM,iBAAiB;AAAA,oBACrB;AAAA,oBACA;AAAA,kBACF;AACA,sBAAI,gBAAgB;AAClB,uCAAmB,QAAQ,IAAI,cAAc;AAAA,kBAC/C;AACA;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA,CAAC,UAAU,kBAAkB;AAAA,EAC/B;AAGA,QAAM,UAAU;AAAA,IACd,OAA2B;AAAA,MACzB,QAAQ;AAAA,IACV;AAAA,IACA,CAAC,cAAc;AAAA,EACjB;AAGA,QAAM,eAAe,QAAQ,MAAM;AAEjC,QAAI,mBAAmB,iBAAiB,QAAW;AAEjD,YAAM,eAAe,KAAK;AAAA,QACxB;AAAA,QACA,KAAK,IAAI,cAAc,aAAa,SAAS,CAAC;AAAA,MAChD;AACA,YAAM,mBACJ,aAAa,YAAY,KAAK,aAAa,CAAC,KAAK;AAEnD,YAAMC,UAAyB,kBAAkB,UAAU;AAC3D,YAAMC,YAAWD,YAAW,aAAaA,YAAW;AAEpD,aAAO;AAAA,QACL,MAAM,kBAAkB,WAAW;AAAA,QACnC,QAAAA;AAAA,QACA,UAAU,kBAAkB;AAAA,QAC5B,OAAO,kBAAkB;AAAA,QACzB,UAAAC;AAAA,QACA,SAAS,qBAAqB;AAAA,QAC9B,UAAU;AAAA,QACV,cAAc;AAAA,MAChB;AAAA,IACF;AAGA,UAAM,SAAyB,iBAAiB,UAAU;AAC1D,UAAM,WAAW,WAAW,aAAa,WAAW;AAEpD,WAAO;AAAA,MACL,MAAM,iBAAiB,WAAW;AAAA,MAClC;AAAA,MACA,UAAU,iBAAiB;AAAA,MAC3B,OAAO,iBAAiB;AAAA,MACxB;AAAA,MACA,SAAS,oBAAoB;AAAA,MAC7B,UAAU;AAAA,IACZ;AAAA,EACF,GAAG;AAAA,IACD;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAED,SAAO,CAAC,cAAc,OAAO;AAI/B;AAIO,SAAS,aACd,UAA+B,CAAC,GACW;AAC3C,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAO;AAAA,IACP;AAAA,IACA,WAAW;AAAA,IACX;AAAA,EACF,IAAI;AACJ,QAAM,WAAW,gBAAgB;AAGjC,QAAM,kBAAkB,OAAO,KAAK;AAEpC,QAAM,oBAAoB,OAAsB,IAAI;AAEpD,QAAM,iBAAiB,OAAO,KAAK;AAGnC,QAAM,CAAC,mBAAmB,oBAAoB,IAAI;AAAA,IAChD,oBAAI,IAAI;AAAA,EACV;AAGA,QAAM,CAAC,eAAe,gBAAgB,IAAI,SAAwB,IAAI;AAGtE,QAAM,eAAe,QAAQ,MAAM;AACjC,QAAI,mBAAmB;AACrB,aAAO,IAAI,IAAI,iBAAiB;AAAA,IAClC;AACA,WAAO;AAAA,EACT,GAAG,CAAC,mBAAmB,iBAAiB,CAAC;AAGzC,QAAM,eAAe,QAAQ,MAAM;AACjC,QAAI,kBAAkB,QAAW;AAC/B,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,GAAG,CAAC,eAAe,aAAa,CAAC;AAEjC,QAAM,WAAW;AAAA,IACf,CAAC,UAAyB;AAExB,qBAAe,UAAU;AAEzB,UAAI,UAAU;AAEZ,iBAAS,KAAK;AAAA,MAChB,OAAO;AAEL,yBAAiB,KAAK;AAAA,MACxB;AAAA,IACF;AAAA,IACA,CAAC,QAAQ;AAAA,EACX;AAEA,QAAM,UAAU;AAAA,IACd,CAAC,SAAiB;AAChB,YAAM,eAAe,IAAI,IAAI,YAAY;AACzC,mBAAa,IAAI,IAAI;AAErB,UAAI,mBAAmB;AAErB,4BAAoB,MAAM,KAAK,YAAY,CAAC;AAAA,MAC9C,OAAO;AAEL,6BAAqB,YAAY;AAAA,MACnC;AAAA,IACF;AAAA,IACA,CAAC,cAAc,mBAAmB,iBAAiB;AAAA,EACrD;AAEA,QAAM,UAAU;AAAA,IACd,CAAC,SAAiB;AAChB,YAAM,eAAe,IAAI,IAAI,YAAY;AACzC,mBAAa,OAAO,IAAI;AAExB,UAAI,mBAAmB;AAErB,4BAAoB,MAAM,KAAK,YAAY,CAAC;AAAA,MAC9C,OAAO;AAEL,6BAAqB,YAAY;AAAA,MACnC;AAAA,IACF;AAAA,IACA,CAAC,cAAc,mBAAmB,iBAAiB;AAAA,EACrD;AAGA,QAAM,YAAY,OAAO,MAAM;AAC/B,YAAU,MAAM;AACd,cAAU,UAAU;AAAA,EACtB,GAAG,CAAC,MAAM,CAAC;AAEX,QAAM,gBAAgB,QAAQ,MAAM;AAClC,UAAM,eAAe,gCAAgC,QAAQ;AAG7D,UAAM,oBAAoB,aAAa,OAAO,CAACC,cAAa;AAC1D,UAAI,WAAW,QAAQ,SAAS,EAAG,QAAO,QAAQ,SAASA,UAAS,IAAI;AACxE,UAAI,WAAW,QAAQ,SAAS;AAC9B,eAAO,CAAC,QAAQ,SAASA,UAAS,IAAI;AACxC,aAAO;AAAA,IACT,CAAC;AAGD,UAAM,SAAkD,CAAC;AACzD,UAAM,eAAsD,CAAC;AAE7D,eAAWA,aAAY,mBAAmB;AACxC,UAAI,CAAC,OAAOA,UAAS,IAAI,GAAG;AAC1B,eAAOA,UAAS,IAAI,IAAI,CAAC;AAAA,MAC3B;AACA,aAAOA,UAAS,IAAI,EAAE,KAAKA,SAAQ;AAGnC,UACE,CAAC,aAAaA,UAAS,IAAI,KAC3BA,UAAS,UAAU,aAAaA,UAAS,IAAI,EAAE,WAC9CA,UAAS,YAAY,aAAaA,UAAS,IAAI,EAAE,WAChDA,UAAS,YAAY,aAAaA,UAAS,IAAI,EAAE,WACnD;AACA,cAAM,aAAa,aAAaA,UAAS,IAAI;AAC7C,qBAAaA,UAAS,IAAI,IAAIA;AAG9B,cAAM,gBAAgB,UAAU;AAChC,YACE,kBACC,CAAC,cACAA,UAAS,UAAU,WAAW,WAC7BA,UAAS,YAAY,WAAW,WAC/BA,UAAS,YAAY,WAAW,YACpC;AACA,wBAAcA,UAAS,MAAMA,SAAQ;AAAA,QACvC;AAAA,MACF;AAAA,IACF;AAGA,eAAW,QAAQ,QAAQ;AACzB,aAAO,IAAI,EAAE,KAAK,CAAC,GAAG,MAAM,EAAE,YAAY,EAAE,SAAS;AAAA,IACvD;AAGA,UAAM,QAAQ,OAAO,KAAK,MAAM,EAAE;AAAA,MAChC,CAAC,SAAS,OAAO,IAAI,KAAK,OAAO,IAAI,EAAE,SAAS;AAAA,IAClD;AAEA,UAAM,eAAe,MAAM,SAAS;AACpC,UAAM,eAAe,gBAAgB;AAGrC,oBAAgB,UAAU;AAG1B,QAAI,iBAA+C;AACnD,eAAW,QAAQ,cAAc;AAC/B,YAAMA,YAAW,aAAa,IAAI;AAClC,UAAI,CAAC,kBAAkBA,UAAS,YAAY,eAAe,WAAW;AACpE,yBAAiBA;AAAA,MACnB;AAAA,IACF;AACA,UAAM,qBAAqB,iBACvB,eAAe,OACf,MAAM,CAAC,KAAK;AAMhB,QAAI,aAA4B;AAEhC,QAAI,gBAAgB,MAAM,SAAS,YAAY,GAAG;AAEhD,mBAAa;AAAA,IACf,YACG,iBAAiB,QAAQ,iBAAiB,WAC3C,gBACA,CAAC,gBACD,MAAM,SAAS,GACf;AAEA,mBAAa;AAAA,IACf;AAEA,UAAM,kBAAkB,aAAa,OAAO,UAAU,KAAK,CAAC,IAAI,CAAC;AAGjE,UAAM,YAAY,MAAM,OAAO,CAAC,SAAS,CAAC,aAAa,IAAI,IAAI,CAAC;AAChE,UAAM,YAAY,MAAM,KAAK,YAAY,EAAE;AAAA,MAAO,CAAC,SACjD,MAAM,SAAS,IAAI;AAAA,IACrB;AAEA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,WAAW;AAAA,MACX,SAAS,kBAAkB,CAAC,KAAK;AAAA,MACjC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF,GAAG,CAAC,UAAU,SAAS,SAAS,cAAc,YAAY,CAAC;AAG3D,YAAU,MAAM;AACd,UAAM,oBAAoB,cAAc;AACxC,UAAM,iBAAiB,kBAAkB;AAGzC,sBAAkB,UAAU;AAE5B,QAAI,CAAC,mBAAmB;AACtB;AAAA,IACF;AAKA,QACE,mBAAmB,QACnB,sBAAsB,kBACtB,cAAc,MAAM,SAAS,iBAAiB,GAC9C;AAEA,UAAI,UAAU;AACZ,iBAAS,iBAAiB;AAAA,MAC5B,OAAO;AACL,yBAAiB,iBAAiB;AAAA,MACpC;AAAA,IACF,WACE,mBAAmB,QACnB,sBAAsB,SACrB,iBAAiB,QAAQ,iBAAiB,WAC3C,cAAc,eAAe,MAC7B;AAEA,UAAI,UAAU;AACZ,iBAAS,iBAAiB;AAAA,MAC5B,OAAO;AACL,yBAAiB,iBAAiB;AAAA,MACpC;AAAA,IACF;AAAA,EACF,GAAG;AAAA,IACD,cAAc;AAAA,IACd,cAAc;AAAA,IACd,cAAc;AAAA,IACd;AAAA,IACA;AAAA,EACF,CAAC;AAGD,YAAU,MAAM;AACd,QACE,cAAc,cACd,aAAa,IAAI,cAAc,UAAU,GACzC;AACA,cAAQ,cAAc,UAAU;AAAA,IAClC;AAAA,EACF,GAAG,CAAC,cAAc,YAAY,cAAc,OAAO,CAAC;AAIpD,YAAU,MAAM;AAId,UAAM,yBACH,kBAAkB,UAAa,kBAAkB,QACjD,kBAAkB,UACjB,eAAe,WACf,iBAAiB;AAErB,QACE,cAAc,UAAU,SAAS,MAChC,CAAC,cAAc,cACd,CAAC,cAAc,UAAU,SAAS,cAAc,UAAU,MAC5D,CAAC,wBACD;AAEA,eAAS,cAAc,UAAU,CAAC,CAAC;AAAA,IACrC;AAAA,EACF,GAAG;AAAA,IACD,cAAc;AAAA,IACd,cAAc;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAGD,QAAM,UAAU;AAAA,IACd,OAA4B;AAAA,MAC1B;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,IACA,CAAC,UAAU,SAAS,OAAO;AAAA,EAC7B;AAEA,SAAO,CAAC,eAAe,OAAO;AAChC;AAEA,SAAS,gCACP,UACyB;AACzB,QAAM,YAAY,oBAAI,IAAmC;AAEzD,aAAW,WAAW,UAAU;AAE9B,QAAI,QAAQ,SAAS,MAAM,QAAQ,QAAQ,KAAK,GAAG;AACjD,iBAAW,QAAQ,QAAQ,OAAO;AAEhC,YAAI,KAAK,KAAK,WAAW,gBAAgB,KAAK,UAAU,MAAM;AAC5D,gBAAM,eAAe;AACrB,cAAI,aAAa,MAAM;AACrB,kBAAM,WAAW,UAAU,IAAI,aAAa,KAAK,EAAE;AACnD,gBACE,CAAC,YACD,aAAa,KAAK,UAAU,SAAS,WACpC,aAAa,KAAK,YAAY,SAAS,WACtC,aAAa,KAAK,YAAY,SAAS,WACzC;AACA,wBAAU,IAAI,aAAa,KAAK,IAAI,aAAa,IAAI;AAAA,YACvD;AAAA,UACF;AAAA,QACF;AAGA,YAAI,KAAK,KAAK,WAAW,OAAO,KAAK,YAAY,QAAQ,KAAK,QAAQ;AACpE,gBAAM,SAAS,KAAK;AACpB,cAAI,OAAO,WAAW,YAAY,UAAU,WAAW,QAAQ;AAC7D,kBAAM,QAAS,OAA+C;AAC9D,gBAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,yBAAW,cAAc,OAAO;AAC9B,oBACE,WAAW,KAAK,WAAW,gBAAgB,KAC3C,WAAW,MACX;AACA,wBAAM,WAAW,UAAU,IAAI,WAAW,KAAK,EAAE;AACjD,sBACE,CAAC,YACD,WAAW,KAAK,UAAU,SAAS,WAClC,WAAW,KAAK,YAAY,SAAS,WACpC,WAAW,KAAK,YAAY,SAAS,WACvC;AACA,8BAAU,IAAI,WAAW,KAAK,IAAI,WAAW,IAAI;AAAA,kBACnD;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO,MAAM,KAAK,UAAU,OAAO,CAAC,EAAE;AAAA,IACpC,CAAC,GAAG,MAAM,EAAE,YAAY,EAAE;AAAA,EAC5B;AACF;AAEA,SAAS,6BACP,UACA,cACmB;AACnB,QAAM,YAAY,oBAAI,IAA6B;AAEnD,aAAW,WAAW,UAAU;AAE9B,QAAI,QAAQ,SAAS,MAAM,QAAQ,QAAQ,KAAK,GAAG;AACjD,iBAAW,QAAQ,QAAQ,OAAO;AAEhC,YAAI,KAAK,SAAS,iBAAiB,YAAY,MAAM,UAAU,MAAM;AACnE,gBAAM,eAAe;AACrB,cAAI,aAAa,MAAM;AACrB,kBAAM,WAAW,UAAU,IAAI,aAAa,KAAK,EAAE;AACnD,gBACE,CAAC,YACD,aAAa,KAAK,UAAU,SAAS,WACpC,aAAa,KAAK,YAAY,SAAS,WACtC,aAAa,KAAK,YAAY,SAAS,WACzC;AACA,wBAAU,IAAI,aAAa,KAAK,IAAI,aAAa,IAAI;AAAA,YACvD;AAAA,UACF;AAAA,QACF;AAGA,YAAI,KAAK,KAAK,WAAW,OAAO,KAAK,YAAY,QAAQ,KAAK,QAAQ;AACpE,gBAAM,SAAS,KAAK;AACpB,cAAI,OAAO,WAAW,YAAY,UAAU,WAAW,QAAQ;AAC7D,kBAAM,QAAS,OAAyC;AACxD,gBAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,yBAAW,cAAc,OAAO;AAC9B,oBACE,WAAW,SAAS,iBAAiB,YAAY,MACjD,WAAW,MACX;AACA,wBAAM,WAAW,UAAU,IAAI,WAAW,KAAK,EAAE;AACjD,sBACE,CAAC,YACD,WAAW,KAAK,UAAU,SAAS,WAClC,WAAW,KAAK,YAAY,SAAS,WACpC,WAAW,KAAK,YAAY,SAAS,WACvC;AACA,8BAAU,IAAI,WAAW,KAAK,IAAI,WAAW,IAAI;AAAA,kBACnD;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO,MAAM,KAAK,UAAU,OAAO,CAAC,EAAE;AAAA,IACpC,CAAC,GAAG,MAAM,EAAE,YAAY,EAAE;AAAA,EAC5B;AACF;;;AC/uBO,IAAM,gBAAN,cAA4B,MAAM;AAAA,EACvC,YACS,MACP,SACA;AACA,UAAM,OAAO;AAHN;AAIP,SAAK,OAAO;AAAA,EACd;AACF;","names":["part","status","isActive","artifact"]}