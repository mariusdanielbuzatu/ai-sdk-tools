{"version":3,"sources":["../src/context.ts","../../debug/src/index.ts","../../memory/src/utils.ts","../src/agent.ts","../src/handoff.ts","../src/handoff-prompt.ts","../src/run-context.ts","../src/streaming.ts","../src/tool-result-extractor.ts","../src/utils.ts","../src/index.ts","../src/guardrails.ts","../src/permissions.ts","../src/routing.ts"],"sourcesContent":["/**\r\n * Context Management using AI SDK's experimental_context\r\n *\r\n * This provides type-safe context that flows through tools via AI SDK's\r\n * built-in experimental_context parameter.\r\n *\r\n * Key features:\r\n * - Uses AI SDK's official context mechanism\r\n * - Fully flexible user context - pass ANY type you want (object, string, class instance, etc.)\r\n * - Stream writer for artifacts and real-time updates\r\n * - Type-safe with full TypeScript support\r\n * - Available in all tools via executionOptions.experimental_context\r\n */\r\n\r\nimport type { MemoryConfig } from \"@ai-sdk-tools/memory\";\r\nimport type { UIMessageStreamWriter } from \"ai\";\r\n\r\n/**\r\n * Core execution context that flows through tools via AI SDK\r\n *\r\n * This merges your custom context with required system fields.\r\n * Your context fields are available at the top level alongside writer and metadata.\r\n *\r\n * @template TContext - Your custom context type (must be an object)\r\n */\r\nexport type ExecutionContext<\r\n  TContext extends Record<string, unknown> = Record<string, unknown>,\r\n> = TContext & {\r\n  /** Stream writer for real-time updates and artifacts */\r\n  writer: UIMessageStreamWriter;\r\n\r\n  /** Metadata about the current execution */\r\n  metadata?: {\r\n    /** Current agent name */\r\n    agent?: string;\r\n    /** Execution start time */\r\n    startTime?: Date;\r\n    /** Request ID for tracing */\r\n    requestId?: string;\r\n    /** Chat ID for memory scope */\r\n    chatId?: string;\r\n    /** User ID for memory scope */\r\n    userId?: string;\r\n    /** Any custom metadata */\r\n    [key: string]: unknown;\r\n  };\r\n\r\n  /** Memory configuration for persistent context */\r\n  memory?: MemoryConfig;\r\n};\r\n\r\n/**\r\n * Type-safe context creator options\r\n *\r\n * @template TContext - Your custom context type (must be an object)\r\n */\r\nexport interface ContextOptions<\r\n  TContext extends Record<string, unknown> = Record<string, unknown>,\r\n> {\r\n  /** Your custom application context - spread at the top level */\r\n  context: TContext;\r\n\r\n  /** Stream writer (required in streaming mode) */\r\n  writer: UIMessageStreamWriter;\r\n\r\n  /** Metadata */\r\n  metadata?: ExecutionContext<TContext>[\"metadata\"];\r\n}\r\n\r\n/**\r\n * Create an execution context to pass to AI SDK's experimental_context\r\n *\r\n * Your context object is spread at the top level, merged with writer and metadata.\r\n * This means you can access your fields directly without a wrapper.\r\n *\r\n * @template TContext - Your custom context type (must be an object)\r\n *\r\n * @example Basic usage\r\n * ```typescript\r\n * const context = createExecutionContext({\r\n *   context: { userId: '123', db: database, permissions: ['read', 'write'] },\r\n *   writer: streamWriter\r\n * });\r\n * // Access in tools: executionOptions.experimental_context.userId\r\n * ```\r\n *\r\n * @example With typed context\r\n * ```typescript\r\n * interface MyAppContext {\r\n *   tenant: string;\r\n *   workspace: string;\r\n *   features: string[];\r\n * }\r\n *\r\n * const context = createExecutionContext<MyAppContext>({\r\n *   context: { tenant: 'acme', workspace: 'main', features: ['analytics'] },\r\n *   writer: streamWriter\r\n * });\r\n * // Access in tools: executionOptions.experimental_context.tenant\r\n * ```\r\n *\r\n * @example With metadata\r\n * ```typescript\r\n * const context = createExecutionContext({\r\n *   context: { userId: '123', tenantId: 'acme' },\r\n *   writer: streamWriter,\r\n *   metadata: { agent: 'reports', requestId: 'req_123' }\r\n * });\r\n * ```\r\n */\r\nexport function createExecutionContext<\r\n  TContext extends Record<string, unknown> = Record<string, unknown>,\r\n>(options: ContextOptions<TContext>): ExecutionContext<TContext> {\r\n  return {\r\n    ...options.context,\r\n    writer: options.writer,\r\n    metadata: {\r\n      startTime: new Date(),\r\n      ...options.metadata,\r\n    },\r\n  } as ExecutionContext<TContext>;\r\n}\r\n\r\n/**\r\n * Get your custom context from execution options\r\n *\r\n * Your context fields are available directly in experimental_context (no wrapper).\r\n * This helper provides type-safe access.\r\n *\r\n * @template T - Your custom context type (object)\r\n * @param executionOptions - Tool execution options from AI SDK\r\n * @returns Your custom context\r\n *\r\n * @example Direct access (no helper needed)\r\n * ```typescript\r\n * export const myTool = tool({\r\n *   execute: async (params, executionOptions) => {\r\n *     // Access fields directly\r\n *     const userId = executionOptions.experimental_context.userId;\r\n *     const db = executionOptions.experimental_context.db;\r\n *   }\r\n * });\r\n * ```\r\n *\r\n * @example With typed helper\r\n * ```typescript\r\n * interface AppContext {\r\n *   userId: string;\r\n *   tenantId: string;\r\n *   db: Database;\r\n * }\r\n *\r\n * export const myTool = tool({\r\n *   execute: async (params, executionOptions) => {\r\n *     const { userId, tenantId, db } = getContext<AppContext>(executionOptions);\r\n *     const user = await db.users.findOne(userId);\r\n *   }\r\n * });\r\n * ```\r\n */\r\nexport function getContext<\n  T extends Record<string, unknown> = Record<string, unknown>,\n>(executionOptions?: { experimental_context?: unknown }): T | undefined {\n  // AI SDK passes context via experimental_context\n  return executionOptions?.experimental_context as T | undefined;\n}\n","const isDebugEnabled = process.env.DEBUG_AGENTS === 'true';\r\n\r\n// ANSI color codes for terminal output\r\nconst colors = {\r\n  reset: '\\x1b[0m',\r\n  gray: '\\x1b[90m',\r\n  blue: '\\x1b[34m',\r\n  cyan: '\\x1b[36m',\r\n  yellow: '\\x1b[33m',\r\n  red: '\\x1b[31m',\r\n  green: '\\x1b[32m',\r\n  magenta: '\\x1b[35m',\r\n};\r\n\r\n// Format timestamp\r\nconst timestamp = () => new Date().toISOString().slice(11, 23);\r\n\r\n// Create category-scoped logger with clean API\r\nexport function createLogger(category: string) {\r\n  if (!isDebugEnabled) {\r\n    // Return no-op functions when debug is disabled\r\n    return {\r\n      debug: () => {},\r\n      info: () => {},\r\n      warn: () => {},\r\n      error: () => {},\r\n    };\r\n  }\r\n\r\n  return {\r\n    debug: (message: string, data?: any) => {\r\n      const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n      const level = `${colors.blue}DEBUG${colors.reset}`;\r\n      const cat = `${colors.cyan}[${category}]${colors.reset}`;\r\n      const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n      console.log(`${ts} ${level} ${cat} ${message}${dataStr}`);\r\n    },\r\n    info: (message: string, data?: any) => {\r\n      const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n      const level = `${colors.green}INFO${colors.reset}`;\r\n      const cat = `${colors.cyan}[${category}]${colors.reset}`;\r\n      const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n      console.log(`${ts} ${level} ${cat} ${message}${dataStr}`);\r\n    },\r\n    warn: (message: string, data?: any) => {\r\n      const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n      const level = `${colors.yellow}WARN${colors.reset}`;\r\n      const cat = `${colors.cyan}[${category}]${colors.reset}`;\r\n      const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n      console.warn(`${ts} ${level} ${cat} ${message}${dataStr}`);\r\n    },\r\n    error: (message: string, data?: any) => {\r\n      const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n      const level = `${colors.red}ERROR${colors.reset}`;\r\n      const cat = `${colors.cyan}[${category}]${colors.reset}`;\r\n      const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n      console.error(`${ts} ${level} ${cat} ${message}${dataStr}`);\r\n    },\r\n  };\r\n}\r\n\r\n// Export a base logger for backward compatibility\r\nexport const logger = {\r\n  debug: (message: string, data?: any) => {\r\n    if (!isDebugEnabled) return;\r\n    const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n    const level = `${colors.blue}DEBUG${colors.reset}`;\r\n    const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n    console.log(`${ts} ${level} ${message}${dataStr}`);\r\n  },\r\n  info: (message: string, data?: any) => {\r\n    if (!isDebugEnabled) return;\r\n    const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n    const level = `${colors.green}INFO${colors.reset}`;\r\n    const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n    console.log(`${ts} ${level} ${message}${dataStr}`);\r\n  },\r\n  warn: (message: string, data?: any) => {\r\n    if (!isDebugEnabled) return;\r\n    const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n    const level = `${colors.yellow}WARN${colors.reset}`;\r\n    const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n    console.warn(`${ts} ${level} ${message}${dataStr}`);\r\n  },\r\n  error: (message: string, data?: any) => {\r\n    if (!isDebugEnabled) return;\r\n    const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n    const level = `${colors.red}ERROR${colors.reset}`;\r\n    const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n    console.error(`${ts} ${level} ${message}${dataStr}`);\r\n  },\r\n};\r\n\r\n","import type { ConversationMessage, WorkingMemory } from \"./types.js\";\r\n\r\n/**\r\n * Default working memory template\r\n */\r\nexport const DEFAULT_TEMPLATE = `# Working Memory\r\n\r\n## Key Facts\r\n- [Important information goes here]\r\n\r\n## Current Focus\r\n- [What the user is working on]\r\n\r\n## Preferences\r\n- [User preferences and settings]\r\n`;\r\n\r\n/**\r\n * Format working memory for system prompt\r\n */\r\nexport function formatWorkingMemory(memory: WorkingMemory | null): string {\r\n  if (!memory?.content) return \"\";\r\n  return `\\n## Working Memory\\n\\n${memory.content}\\n`;\r\n}\r\n\r\n/**\r\n * Format conversation history\r\n */\r\nexport function formatHistory(\r\n  messages: ConversationMessage[],\r\n  limit = 10,\r\n): string {\r\n  if (!messages.length) return \"\";\r\n\r\n  const recent = messages.slice(-limit);\r\n  const formatted = recent\r\n    .map((m) => `**${m.role}**: ${m.content}`)\r\n    .join(\"\\n\\n\");\r\n\r\n  return `\\n## Recent Messages\\n\\n${formatted}\\n`;\r\n}\r\n\r\n/**\r\n * Instructions for working memory\r\n */\r\nexport function getWorkingMemoryInstructions(template: string): string {\r\n  return `\r\n## Working Memory\r\n\r\nYou have access to persistent working memory that stores user preferences, context, and important facts across conversations.\r\n\r\n**ALWAYS call updateWorkingMemory when:**\r\n- User shares OR corrects their name, role, company, or preferences\r\n- User provides OR updates important facts you should remember\r\n- User corrects previous information about themselves\r\n- Any new or changed context that should persist for future conversations\r\n\r\n**Template structure to follow:**\r\n\\`\\`\\`\r\n${template}\r\n\\`\\`\\`\r\n\r\n**Critical:** After calling updateWorkingMemory, respond to the user confirming the update.\r\n`.trim();\r\n}\r\n","import { createLogger } from \"@ai-sdk-tools/debug\";\r\nimport {\r\n  DEFAULT_TEMPLATE,\r\n  formatWorkingMemory,\r\n  getWorkingMemoryInstructions,\r\n  type MemoryConfig,\r\n} from \"@ai-sdk-tools/memory\";\r\nimport {\r\n  ToolLoopAgent as AISDKAgent,\n  convertToModelMessages,\r\n  createUIMessageStream,\r\n  createUIMessageStreamResponse,\r\n  generateObject,\r\n  generateText,\r\n  type LanguageModel,\r\n  type ModelMessage,\r\n  type StepResult,\r\n  stepCountIs,\r\n  type Tool,\r\n  tool,\r\n  type UIMessage,\r\n  type UIMessageStreamOnFinishCallback,\r\n  type UIMessageStreamWriter,\r\n} from \"ai\";\r\nimport { z } from \"zod\";\r\nimport { createExecutionContext } from \"./context.js\";\r\nimport {\r\n  createHandoffTool,\r\n  HANDOFF_TOOL_NAME,\r\n  isHandoffResult,\r\n} from \"./handoff.js\";\r\nimport { promptWithHandoffInstructions } from \"./handoff-prompt.js\";\r\nimport { AgentRunContext } from \"./run-context.js\";\r\nimport { writeAgentStatus, writeSuggestions } from \"./streaming.js\";\r\nimport { createDefaultInputFilter } from \"./tool-result-extractor.js\";\r\nimport type {\r\n  AgentConfig,\r\n  AgentEvent,\r\n  AgentGenerateOptions,\r\n  AgentGenerateResult,\r\n  AgentStreamOptions,\r\n  AgentStreamOptionsUI,\r\n  AgentStreamResult,\r\n  ConfiguredHandoff,\r\n  ExtendedExecutionContext,\r\n  HandoffInputData,\r\n  HandoffInstruction,\r\n  Agent as IAgent,\r\n  InputGuardrail,\r\n  MemoryIdentifiers,\r\n  OutputGuardrail,\r\n  ToolPermissions,\r\n} from \"./types.js\";\r\nimport { extractTextFromMessage, stripMetadata } from \"./utils.js\";\r\n\r\nconst logger = createLogger(\"AGENT\");\r\n\r\nexport class Agent<\r\n  TContext extends Record<string, unknown> = Record<string, unknown>,\r\n> implements IAgent<TContext>\r\n{\r\n  public readonly name: string;\r\n  public readonly instructions: string | ((context: TContext) => string);\r\n  public readonly matchOn?:\r\n    | (string | RegExp)[]\r\n    | ((message: string) => boolean);\r\n  public readonly onEvent?: (event: AgentEvent) => void | Promise<void>;\r\n  public readonly inputGuardrails?: InputGuardrail[];\r\n  public readonly outputGuardrails?: OutputGuardrail[];\r\n  public readonly permissions?: ToolPermissions;\r\n  public readonly lastMessages?: number;\r\n  private readonly memory?: MemoryConfig;\r\n  private readonly model: LanguageModel;\r\n  private readonly aiAgent: AISDKAgent<never, Record<string, Tool>>;\n  private readonly handoffAgents: Array<IAgent<any> | ConfiguredHandoff<any>>;\r\n  private readonly configuredTools:\r\n    | Record<string, Tool>\r\n    | ((context: TContext) => Record<string, Tool>);\r\n  private readonly modelSettings?: Record<string, unknown>;\r\n  // Cache for system prompt construction\r\n  private _cachedSystemPrompt?: string;\r\n  private _cacheKey?: string;\r\n\r\n  constructor(config: AgentConfig<TContext>) {\r\n    this.name = config.name;\r\n    this.instructions = config.instructions;\r\n    this.matchOn = config.matchOn;\r\n    this.onEvent = config.onEvent;\r\n    this.inputGuardrails = config.inputGuardrails;\r\n    this.outputGuardrails = config.outputGuardrails;\r\n    this.permissions = config.permissions;\r\n    this.lastMessages = config.lastMessages;\r\n    this.memory = config.memory;\r\n    this.model = config.model;\r\n    this.handoffAgents = config.handoffs || [];\r\n    this.modelSettings = config.modelSettings;\r\n\r\n    // Store tools config (will be resolved at runtime)\r\n    this.configuredTools = config.tools || {};\r\n\r\n    // Create AI SDK Agent with minimal config (instructions overridden per-request in stream())\n    // Extract toolChoice from modelSettings (needs to be a top-level param per AI SDK)\r\n    const { toolChoice, ...otherModelSettings } = config.modelSettings || {};\r\n\r\n    this.aiAgent = new AISDKAgent<never, Record<string, Tool>>({\n      model: config.model,\r\n      instructions: \"\", // Will be overridden per-request with resolved instructions\n      tools: {}, // Will be overridden per-request with resolved tools\r\n      stopWhen: stepCountIs(config.maxTurns || 10),\r\n      temperature: config.temperature,\r\n      toolChoice: toolChoice as any, // Pass toolChoice as top-level param\r\n      ...otherModelSettings,\r\n    });\r\n  }\r\n\r\n  async generate(options: AgentGenerateOptions): Promise<AgentGenerateResult> {\r\n    const startTime = new Date();\r\n\r\n    try {\r\n      const result =\r\n        options.messages && options.messages.length > 0\r\n          ? await this.aiAgent.generate({\r\n              messages: [\r\n                ...options.messages,\r\n                { role: \"user\", content: options.prompt || \"Continue\" },\r\n              ],\r\n            })\r\n          : await this.aiAgent.generate({\r\n              prompt: options.prompt,\r\n            });\r\n\r\n      const endTime = new Date();\r\n\r\n      // Extract handoffs from steps\r\n      const handoffs: HandoffInstruction[] = [];\r\n      if (result.steps) {\r\n        for (const step of result.steps) {\r\n          if (step.toolResults) {\r\n            for (const toolResult of step.toolResults) {\r\n              if (isHandoffResult(toolResult.output)) {\r\n                handoffs.push(toolResult.output as HandoffInstruction);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return {\r\n        text: result.text || \"\",\r\n        finalAgent: this.name,\r\n        finalOutput: result.text || \"\",\r\n        handoffs,\r\n        metadata: {\r\n          startTime,\r\n          endTime,\r\n          duration: endTime.getTime() - startTime.getTime(),\r\n        },\r\n        steps: result.steps,\r\n        finishReason: result.finishReason,\r\n        usage: result.usage,\r\n        toolCalls: result.toolCalls?.map((tc) => ({\r\n          toolCallId: tc.toolCallId,\r\n          toolName: tc.toolName,\r\n          args: \"args\" in tc ? tc.args : undefined,\r\n        })),\r\n      };\r\n    } catch (error) {\r\n      throw new Error(\r\n        `Agent ${this.name} failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\r\n      );\r\n    }\r\n  }\r\n\r\n  stream(\r\n    options: AgentStreamOptions | { messages: ModelMessage[] },\r\n  ): AgentStreamResult {\r\n    logger.debug(`${this.name} stream called`, { name: this.name });\r\n\r\n    // Extract our internal execution context (we map to/from AI SDK's experimental_context at boundaries)\r\n    const executionContext = (options as Record<string, unknown>)\r\n      .executionContext as Record<string, unknown> | undefined;\r\n    const maxSteps = (options as Record<string, unknown>).maxSteps as\r\n      | number\r\n      | undefined;\r\n    const onStepFinish = (options as Record<string, unknown>).onStepFinish as\r\n      | ((step: unknown) => void | Promise<void>)\r\n      | undefined;\r\n    const toolChoice = (options as Record<string, unknown>).toolChoice as\r\n      | string\r\n      | undefined;\r\n\r\n    // Resolve instructions dynamically (static string or function)\r\n    const resolvedInstructions =\r\n      typeof this.instructions === \"function\"\r\n        ? this.instructions(executionContext as TContext)\r\n        : this.instructions;\r\n\r\n    // Get memory addition from context if preloaded\r\n    const extendedContext = executionContext as ExtendedExecutionContext;\r\n    const memoryAddition = extendedContext._memoryAddition || \"\";\r\n\r\n    // Build cache key for static parts\r\n    const cacheKey = `${typeof this.instructions === \"string\" ? this.instructions : \"dynamic\"}_${this.handoffAgents.length}_${this.memory?.workingMemory?.enabled || false}`;\r\n\r\n    // Build system prompt with caching for static parts\r\n    let systemPrompt: string;\r\n    if (\r\n      this._cacheKey === cacheKey &&\r\n      this._cachedSystemPrompt &&\r\n      !memoryAddition\r\n    ) {\r\n      // Use cached version if no dynamic memory addition\r\n      systemPrompt = this._cachedSystemPrompt;\r\n    } else {\r\n      // Build the static base prompt\r\n      let basePrompt =\r\n        this.handoffAgents.length > 0\r\n          ? promptWithHandoffInstructions(resolvedInstructions)\r\n          : resolvedInstructions;\r\n\r\n      // Add working memory instructions if enabled\r\n      if (this.memory?.workingMemory?.enabled) {\r\n        const workingMemoryInstructions = getWorkingMemoryInstructions(\r\n          this.memory.workingMemory.template || DEFAULT_TEMPLATE,\r\n        );\r\n        basePrompt += `\\n\\n${workingMemoryInstructions}`;\r\n      }\r\n\r\n      // Cache the base prompt if instructions are static\r\n      if (typeof this.instructions === \"string\" && !memoryAddition) {\r\n        this._cachedSystemPrompt = basePrompt;\r\n        this._cacheKey = cacheKey;\r\n      }\r\n\r\n      // Add dynamic memory addition\r\n      systemPrompt = basePrompt + memoryAddition;\r\n    }\r\n\r\n    // Resolve tools dynamically (static object or function)\r\n    const resolvedTools =\r\n      typeof this.configuredTools === \"function\"\r\n        ? this.configuredTools(executionContext as TContext)\r\n        : { ...this.configuredTools };\r\n\r\n    // Add handoff tool if needed\r\n    if (this.handoffAgents.length > 0) {\r\n      resolvedTools[HANDOFF_TOOL_NAME] = createHandoffTool(this.handoffAgents);\r\n      // Note: Agents communicate via conversationMessages during handoffs\r\n    }\r\n\r\n    // Add working memory update tool if enabled\r\n    // Give to all agents that can do work (have tools beyond just handoff)\r\n    const hasOtherTools = Object.keys(resolvedTools).some(\r\n      (key) => key !== HANDOFF_TOOL_NAME,\r\n    );\r\n    const isPureOrchestrator = this.handoffAgents.length > 0 && !hasOtherTools;\r\n\r\n    if (this.memory?.workingMemory?.enabled && !isPureOrchestrator) {\r\n      resolvedTools.updateWorkingMemory = this.createWorkingMemoryTool();\r\n    }\r\n\r\n    // Note: Conversation history is automatically loaded via loadMessagesWithHistory()\r\n\r\n    // Build additional options to pass to AI SDK\r\n    // Extract toolChoice as a top-level param (per AI SDK requirements)\r\n    const { toolChoice: configuredToolChoice, ...otherSettings } =\r\n      this.modelSettings || {};\r\n\r\n    // Allow runtime toolChoice to override configured toolChoice\r\n    const effectiveToolChoice = toolChoice\r\n      ? { type: \"tool\" as const, toolName: toolChoice }\r\n      : configuredToolChoice;\r\n\r\n    const additionalOptions: Record<string, unknown> = {\r\n      system: systemPrompt, // Override system prompt per call\r\n      tools: resolvedTools, // Add resolved tools here\r\n      toolChoice: effectiveToolChoice, // Pass toolChoice as top-level param\r\n      ...otherSettings, // Include other model settings\r\n    };\r\n\r\n    if (executionContext) {\r\n      additionalOptions.experimental_context = executionContext;\r\n    }\r\n\r\n    if (maxSteps) additionalOptions.maxSteps = maxSteps;\r\n    if (onStepFinish) additionalOptions.onStepFinish = onStepFinish;\r\n\r\n    // Handle simple { messages } format (like working code)\r\n    if (\"messages\" in options && !(\"prompt\" in options) && options.messages) {\r\n      logger.debug(`Stream with messages only`, {\r\n        messageCount: options.messages.length,\r\n      });\r\n      return this.aiAgent.stream({\r\n        messages: options.messages,\r\n        ...additionalOptions,\r\n      }) as unknown as AgentStreamResult;\r\n    }\r\n\r\n    // Handle full AgentStreamOptions format\r\n    const opts = options as AgentStreamOptions;\r\n    logger.debug(`Stream options for ${this.name}`, {\r\n      hasPrompt: !!opts.prompt,\r\n      messageCount: opts.messages?.length || 0,\r\n    });\r\n\r\n    if (!opts.prompt && (!opts.messages || opts.messages.length === 0)) {\r\n      throw new Error(\"No prompt or messages provided to stream method\");\r\n    }\r\n\r\n    // If we have messages, append prompt as user message\r\n    if (opts.messages && opts.messages.length > 0 && opts.prompt) {\r\n      return this.aiAgent.stream({\r\n        messages: [...opts.messages, { role: \"user\", content: opts.prompt }],\r\n        ...additionalOptions,\r\n      }) as unknown as AgentStreamResult;\r\n    }\r\n\r\n    // Prompt only\r\n    if (opts.prompt) {\r\n      return this.aiAgent.stream({\r\n        prompt: opts.prompt,\r\n        ...additionalOptions,\r\n      }) as unknown as AgentStreamResult;\r\n    }\r\n\r\n    throw new Error(\"No valid options provided to stream method\");\r\n  }\r\n\r\n  getHandoffs(): Array<IAgent<any>> {\r\n    return this.handoffAgents.map((h) => (\"agent\" in h ? h.agent : h));\r\n  }\r\n\r\n  getConfiguredHandoffs(): Array<ConfiguredHandoff<any>> {\r\n    return this.handoffAgents.map((h) => (\"agent\" in h ? h : { agent: h }));\r\n  }\r\n\r\n  /**\r\n   * Convert agent execution to UI Message Stream Response\r\n   * High-level API for Next.js route handlers\r\n   *\r\n   * This follows the working pattern from the route.ts reference code\r\n   */\r\n  toUIMessageStream(options: AgentStreamOptionsUI): Response {\r\n    const {\r\n      message,\r\n      strategy = \"auto\",\r\n      maxRounds = 5,\r\n      maxSteps = 10,\r\n      context,\r\n      agentChoice,\r\n      toolChoice,\r\n      beforeStream,\r\n      onEvent,\r\n      // AI SDK createUIMessageStream options\r\n      onFinish,\r\n      onError,\r\n      generateId,\r\n      // AI SDK toUIMessageStream options\r\n      sendReasoning,\r\n      sendSources,\r\n      sendFinish,\r\n      sendStart,\r\n      messageMetadata,\r\n      // Response options\r\n      status,\r\n      statusText,\r\n      headers,\r\n    } = options;\r\n\r\n    // Declare variable to store chat metadata (will be loaded in execute block)\r\n    let existingChatForSave: any = null;\r\n\r\n    // Wrap onFinish to save messages after streaming\r\n    const wrappedOnFinish: UIMessageStreamOnFinishCallback<never> = async (\r\n      event,\r\n    ) => {\r\n      // Save messages and update chat session after stream completes\r\n      if (this.memory?.history?.enabled && context) {\r\n        const { chatId, userId } = this.extractMemoryIdentifiers(\r\n          context as TContext,\r\n        );\r\n\r\n        if (!chatId) {\r\n          logger.warn(\"Cannot save messages: chatId is missing from context\");\r\n        } else {\r\n          try {\r\n            // The AI SDK provides complete messages with all parts in event.messages\r\n            const userMsg: any = event.messages[event.messages.length - 2]; // second to last is user message\r\n            const assistantMsg: any = event.messages[event.messages.length - 1]; // last is assistant message\r\n\r\n            // Filter out file parts from user message - files should never be stored in history\r\n            // They're only needed during initial LLM processing\r\n            let userMsgToSave: any = userMsg;\r\n            if (userMsg && Array.isArray(userMsg.content)) {\r\n              const filteredContent = userMsg.content.filter(\r\n                (part: any) => part.type !== \"file\",\r\n              );\r\n              userMsgToSave = {\r\n                ...userMsg,\r\n                content: filteredContent.length > 0 ? filteredContent : \"\",\r\n              };\r\n            }\r\n\r\n            logger.debug(`Saving messages (files excluded from storage)`);\r\n            await this.saveConversation(\r\n              chatId,\r\n              userId,\r\n              JSON.stringify(userMsgToSave),\r\n              JSON.stringify(assistantMsg),\r\n              existingChatForSave,\r\n            );\r\n          } catch (err) {\r\n            logger.error(\"Failed to save conversation\", { error: err });\r\n          }\r\n        }\r\n      }\r\n\r\n      // Call user's onFinish\r\n      await onFinish?.(event);\r\n    };\r\n\r\n    const stream = createUIMessageStream({\r\n      originalMessages: [message] as never[],\r\n      onFinish: wrappedOnFinish,\r\n      onError,\r\n      generateId,\r\n      execute: async ({ writer }) => {\r\n        // Load history and working memory in parallel for better performance\r\n        const [messages, memoryAddition] = await Promise.all([\r\n          this.loadMessagesWithHistory(message, context as TContext),\r\n          context && this.memory?.workingMemory?.enabled\r\n            ? this.loadWorkingMemory(context as TContext)\r\n            : Promise.resolve(\"\"),\r\n        ]);\r\n\r\n        // Load chat metadata once for the entire request (stored in closure for wrappedOnFinish)\r\n        const { chatId } = this.extractMemoryIdentifiers(context as TContext);\r\n        if (this.memory?.chats?.enabled && chatId) {\r\n          existingChatForSave = await this.memory.provider?.getChat?.(chatId);\r\n        }\r\n\r\n        // Extract input from last message for routing\r\n        const lastMessage = messages[messages.length - 1];\r\n        const input = extractTextFromMessage(lastMessage);\r\n\r\n        // Generate chat title if this is the first message (using pre-loaded chat)\r\n        await this.maybeGenerateChatTitle(\r\n          context as TContext,\r\n          input,\r\n          writer,\r\n          existingChatForSave,\r\n        );\r\n\r\n        // Create AgentRunContext for the workflow\r\n        const runContext = new AgentRunContext(context || {});\r\n        runContext.metadata = {\r\n          agent: this.name,\r\n          requestId: `req_${Date.now()}_${Math.random().toString(36).substring(7)}`,\r\n        };\r\n\r\n        // Create execution context with user context and writer\r\n        const executionContext = createExecutionContext({\r\n          context: (context || {}) as Record<string, unknown>,\r\n          writer,\r\n          metadata: {\r\n            agent: this.name,\r\n            requestId: runContext.metadata.requestId as string,\r\n          },\r\n        });\r\n\r\n        // Add runContext to execution context for shared memory tool\r\n        (executionContext as any).runContext = runContext;\r\n\r\n        // Store memory addition for system prompt injection\r\n        if (memoryAddition) {\r\n          const extendedExecContext =\r\n            executionContext as ExtendedExecutionContext;\r\n          extendedExecContext._memoryAddition = memoryAddition;\r\n        }\r\n\r\n        try {\r\n          // Execute beforeStream hook - allows for rate limiting, auth, etc.\r\n          if (beforeStream) {\r\n            const shouldContinue = await beforeStream({ writer });\r\n            if (shouldContinue === false) {\r\n              // Type assertion needed: custom finish message format\r\n              writer.write({ type: \"finish\" } as any);\r\n              return;\r\n            }\r\n          }\r\n\r\n          // Prepare conversation messages\r\n          const conversationMessages = [...messages];\r\n\r\n          // Get handoff agents (specialists)\r\n          const specialists = this.getHandoffs();\r\n\r\n          // Emit orchestrator start (even if we skip to specialist via programmatic routing)\r\n          writeAgentStatus(writer, {\r\n            status: \"routing\",\r\n            agent: this.name,\r\n          });\r\n\r\n          if (onEvent) {\r\n            await onEvent({\r\n              type: \"agent-start\",\r\n              agent: this.name,\r\n              round: 0,\r\n            });\r\n          }\r\n\r\n          // Determine starting agent using programmatic routing\r\n          let currentAgent: IAgent<any> = this;\r\n\r\n          // Check for explicit agent or tool choice (highest priority)\r\n          if (agentChoice && specialists.length > 0) {\r\n            const chosenAgent = specialists.find(\r\n              (agent) => agent.name === agentChoice,\r\n            );\r\n            if (chosenAgent) {\r\n              currentAgent = chosenAgent;\r\n              logger.debug(`Explicit agent choice: ${currentAgent.name}`, {\r\n                agent: currentAgent.name,\r\n              });\r\n\r\n              // Mark orchestrator as completing\r\n              writeAgentStatus(writer, {\r\n                status: \"completing\",\r\n                agent: this.name,\r\n              });\r\n\r\n              if (onEvent) {\r\n                await onEvent({\r\n                  type: \"agent-finish\",\r\n                  agent: this.name,\r\n                  round: 0,\r\n                });\r\n              }\r\n\r\n              // Emit handoff event for explicit choice\r\n              writer.write({\r\n                type: \"data-agent-handoff\",\r\n                data: {\r\n                  from: this.name,\r\n                  to: chosenAgent.name,\r\n                  reason: \"User selected agent\",\r\n                  routingStrategy: \"explicit\",\r\n                },\r\n                transient: true,\r\n              } as never);\r\n\r\n              if (onEvent) {\r\n                await onEvent({\r\n                  type: \"agent-handoff\",\r\n                  from: this.name,\r\n                  to: chosenAgent.name,\r\n                  reason: \"User selected agent\",\r\n                });\r\n              }\r\n            }\r\n          } else if (toolChoice && specialists.length > 0) {\r\n            // Find agent that has the requested tool\r\n            const agentWithTool = specialists.find((agent) => {\r\n              const agentImpl = agent as Agent<any>;\r\n              return (\r\n                agentImpl.configuredTools &&\r\n                toolChoice in agentImpl.configuredTools\r\n              );\r\n            });\r\n\r\n            if (agentWithTool) {\r\n              currentAgent = agentWithTool;\r\n              logger.debug(\r\n                `Tool choice routing: ${toolChoice} â†’ ${currentAgent.name}`,\r\n                { toolChoice, agent: currentAgent.name },\r\n              );\r\n\r\n              // Mark orchestrator as completing\r\n              writeAgentStatus(writer, {\r\n                status: \"completing\",\r\n                agent: this.name,\r\n              });\r\n\r\n              if (onEvent) {\r\n                await onEvent({\r\n                  type: \"agent-finish\",\r\n                  agent: this.name,\r\n                  round: 0,\r\n                });\r\n              }\r\n\r\n              // Emit handoff event for tool choice\r\n              writer.write({\r\n                type: \"data-agent-handoff\",\r\n                data: {\r\n                  from: this.name,\r\n                  to: agentWithTool.name,\r\n                  reason: `User requested tool: ${toolChoice}`,\r\n                  routingStrategy: \"tool-choice\",\r\n                  preferredTool: toolChoice,\r\n                },\r\n                transient: true,\r\n              } as never);\r\n\r\n              if (onEvent) {\r\n                await onEvent({\r\n                  type: \"agent-handoff\",\r\n                  from: this.name,\r\n                  to: agentWithTool.name,\r\n                  reason: `User requested tool: ${toolChoice}`,\r\n                });\r\n              }\r\n            }\r\n          } else if (strategy === \"auto\" && specialists.length > 0) {\r\n            // Try programmatic classification\r\n            const matchedAgent = specialists.find((agent) => {\r\n              if (!agent.matchOn) return false;\r\n              if (typeof agent.matchOn === \"function\") {\r\n                return agent.matchOn(input);\r\n              }\r\n              if (Array.isArray(agent.matchOn)) {\r\n                return agent.matchOn.some((pattern) => {\r\n                  if (typeof pattern === \"string\") {\r\n                    return input.toLowerCase().includes(pattern.toLowerCase());\r\n                  }\r\n                  if (pattern instanceof RegExp) {\r\n                    return pattern.test(input);\r\n                  }\r\n                  return false;\r\n                });\r\n              }\r\n              return false;\r\n            });\r\n\r\n            if (matchedAgent) {\r\n              currentAgent = matchedAgent;\r\n              logger.debug(`Programmatic match: ${currentAgent.name}`, {\r\n                agent: currentAgent.name,\r\n              });\r\n\r\n              // Mark orchestrator as completing\r\n              writeAgentStatus(writer, {\r\n                status: \"completing\",\r\n                agent: this.name,\r\n              });\r\n\r\n              if (onEvent) {\r\n                await onEvent({\r\n                  type: \"agent-finish\",\r\n                  agent: this.name,\r\n                  round: 0,\r\n                });\r\n              }\r\n\r\n              // Emit handoff event for programmatic routing\r\n              writer.write({\r\n                type: \"data-agent-handoff\",\r\n                data: {\r\n                  from: this.name,\r\n                  to: matchedAgent.name,\r\n                  reason: \"Programmatic routing match\",\r\n                  routingStrategy: \"programmatic\",\r\n                },\r\n                transient: true,\r\n              } as never);\r\n\r\n              if (onEvent) {\r\n                await onEvent({\r\n                  type: \"agent-handoff\",\r\n                  from: this.name,\r\n                  to: matchedAgent.name,\r\n                  reason: \"Programmatic routing match\",\r\n                });\r\n              }\r\n            }\r\n          }\r\n\r\n          let round = 0;\r\n          const usedSpecialists = new Set<string>();\r\n\r\n          // If we used programmatic routing, mark specialist as used\r\n          if (currentAgent !== this) {\r\n            usedSpecialists.add(currentAgent.name);\r\n          }\r\n\r\n          while (round++ < maxRounds) {\r\n            // Send status: agent executing\r\n            writeAgentStatus(writer, {\r\n              status: \"executing\",\r\n              agent: currentAgent.name,\r\n            });\r\n\r\n            // Get context window size from agent config, with sensible defaults\r\n            // Use lower default for specialists (no handoffs) to reduce token usage\r\n            const defaultLastMessages =\r\n              currentAgent.getHandoffs().length > 0 ? 10 : 5;\r\n            const lastMessages =\r\n              currentAgent.lastMessages ?? defaultLastMessages;\r\n\r\n            // Ensure we have at least the original user message\r\n            let messagesToSend = conversationMessages.slice(-lastMessages);\r\n            if (messagesToSend.length === 0 && messages.length > 0) {\r\n              messagesToSend = messages.slice(-1); // Use the last user message\r\n            }\r\n\r\n            // Emit agent start event\r\n            if (onEvent) {\r\n              await onEvent({\r\n                type: \"agent-start\",\r\n                agent: currentAgent.name,\r\n                round,\r\n              });\r\n            }\r\n\r\n            // Type assertion needed: executionContext and onStepFinish types don't strictly match\r\n            // Note: toolChoice is NOT passed here - it was only used for routing\r\n            // Passing it would force the tool to be called on every turn\r\n            const result = currentAgent.stream({\r\n              messages: messagesToSend,\r\n              executionContext: executionContext,\r\n              maxSteps, // Limit tool calls per round\r\n              onStepFinish: async (step: unknown) => {\r\n                if (onEvent) {\r\n                  await onEvent({\r\n                    type: \"agent-step\",\r\n                    agent: currentAgent.name,\r\n                    step: step as StepResult<Record<string, Tool>>,\r\n                  });\r\n                }\r\n              },\r\n            } as any);\r\n\r\n            // This automatically converts fullStream to proper UI message chunks\r\n            // Pass toUIMessageStream options from user config\r\n            const uiStream = result.toUIMessageStream({\r\n              sendReasoning,\r\n              sendSources,\r\n              sendFinish,\r\n              sendStart,\r\n              messageMetadata,\r\n            });\r\n\r\n            // Track for orchestration\r\n            let textAccumulated = \"\";\r\n            let handoffData: HandoffInstruction | null = null;\r\n            const toolCallNames = new Map<string, string>(); // toolCallId -> toolName\r\n            const toolResults = new Map<string, any>(); // toolName -> result\r\n            let hasStartedContent = false;\r\n\r\n            // Optimize handoff detection with Set for O(1) lookups\r\n            const handoffToolNames = new Set([HANDOFF_TOOL_NAME]);\r\n\r\n            // Stream UI chunks - AI SDK handles all the formatting!\r\n            for await (const chunk of uiStream) {\r\n              // Skip undefined/null chunks\r\n              if (!chunk) {\r\n                logger.warn(\"Received null/undefined chunk from uiStream\");\r\n                continue;\r\n              }\r\n\r\n              // Track tool names when they start (do this early for handoff detection)\r\n              if (chunk.type === \"tool-input-start\") {\r\n                toolCallNames.set(chunk.toolCallId, chunk.toolName);\r\n                logger.debug(\r\n                  `Tool call started: ${chunk.toolName} (${chunk.toolCallId})`,\r\n                  {\r\n                    toolName: chunk.toolName,\r\n                    toolCallId: chunk.toolCallId,\r\n                    agent: currentAgent.name,\r\n                    round,\r\n                  },\r\n                );\r\n              }\r\n\r\n              // Check if this chunk is related to handoff (internal orchestration)\r\n              let isHandoffChunk = false;\r\n\r\n              if (chunk.type === \"tool-input-start\") {\r\n                isHandoffChunk = handoffToolNames.has((chunk as any).toolName);\r\n              } else if (\r\n                chunk.type === \"tool-input-delta\" ||\r\n                chunk.type === \"tool-input-available\"\r\n              ) {\r\n                const toolName = toolCallNames.get((chunk as any).toolCallId);\r\n                isHandoffChunk = toolName\r\n                  ? handoffToolNames.has(toolName)\r\n                  : false;\r\n              } else if (chunk.type === \"tool-output-available\") {\r\n                const toolName = toolCallNames.get((chunk as any).toolCallId);\r\n                isHandoffChunk = toolName\r\n                  ? handoffToolNames.has(toolName)\r\n                  : false;\r\n              }\r\n\r\n              // Clear status on first actual content (text or non-handoff tool)\r\n              if (\r\n                !hasStartedContent &&\r\n                (chunk.type === \"text-delta\" ||\r\n                  (chunk.type === \"tool-input-start\" && !isHandoffChunk))\r\n              ) {\r\n                hasStartedContent = true;\r\n              }\r\n\r\n              // Log general errors\r\n              if (chunk.type === \"error\") {\r\n                logger.error(\"Stream error\", {\r\n                  error:\r\n                    (chunk as any).errorText || (chunk as any).error || chunk,\r\n                });\r\n              }\r\n\r\n              // Capture tool results and detect handoffs\r\n              if (chunk.type === \"tool-output-available\") {\r\n                const toolName = toolCallNames.get(chunk.toolCallId);\r\n                if (toolName) {\r\n                  // Store tool result for handoff context\r\n                  toolResults.set(toolName, chunk.output);\r\n                  logger.debug(`Captured ${toolName}`, {\r\n                    toolName,\r\n                    outputType: typeof chunk.output,\r\n                  });\r\n\r\n                  // Detect handoff\r\n                  if (handoffToolNames.has(toolName)) {\r\n                    handoffData = chunk.output as HandoffInstruction;\r\n                    logger.debug(\"Handoff detected\", handoffData);\r\n                  }\r\n                }\r\n              }\r\n\r\n              // Filter out handoff tool chunks from UI (internal orchestration)\r\n              // But keep agent status events (written separately via writeAgentStatus)\r\n              if (!isHandoffChunk) {\r\n                try {\r\n                  writer.write(chunk as any);\r\n                } catch (error) {\r\n                  logger.error(\"Failed to write chunk to stream\", {\r\n                    chunkType: chunk.type,\r\n                    error,\r\n                  });\r\n                }\r\n              }\r\n\r\n              // Track text for conversation history\r\n              if (chunk.type === \"text-delta\") {\r\n                textAccumulated += chunk.delta;\r\n              }\r\n            }\r\n\r\n            // Update conversation - only add text if it's a complete response\r\n            // Don't add intermediate text that was generated between tool calls\r\n            if (textAccumulated && !handoffData) {\r\n              // Only add to conversation if this is a final response (no handoff occurred)\r\n              conversationMessages.push({\r\n                role: \"assistant\",\r\n                content: textAccumulated,\r\n              });\r\n            } else if (textAccumulated && handoffData) {\r\n              // If there was a handoff, this text was intermediate - don't add to conversation\r\n              // The handoff agent will provide the final response\r\n              logger.debug(\"Skipping intermediate text due to handoff\", {\r\n                textLength: textAccumulated.length,\r\n                handoffTarget: handoffData.targetAgent,\r\n              });\r\n            }\r\n\r\n            // Emit agent finish event\r\n            if (onEvent) {\r\n              await onEvent({\r\n                type: \"agent-finish\",\r\n                agent: currentAgent.name,\r\n                round,\r\n              });\r\n            }\r\n\r\n            // Handle orchestration flow\r\n            if (currentAgent === this) {\r\n              if (handoffData) {\r\n                // Check if this specialist has already been used\r\n                if (usedSpecialists.has(handoffData.targetAgent)) {\r\n                  // Don't route to the same specialist twice - task is complete\r\n                  break;\r\n                }\r\n\r\n                // Send routing status\r\n                writeAgentStatus(writer, {\r\n                  status: \"routing\",\r\n                  agent: this.name,\r\n                });\r\n\r\n                // Mark specialist as used and route to it\r\n                usedSpecialists.add(handoffData.targetAgent);\r\n                const nextAgent = specialists.find(\r\n                  (a) => a.name === handoffData.targetAgent,\r\n                );\r\n                if (nextAgent) {\r\n                  // Apply handoff input filter if configured\r\n                  const configuredHandoffs = this.getConfiguredHandoffs();\r\n                  const configuredHandoff = configuredHandoffs.find(\r\n                    (ch) => ch.agent.name === handoffData.targetAgent,\r\n                  );\r\n\r\n                  // Apply handoff input filter if configured\r\n                  const inputFilter = configuredHandoff?.config?.inputFilter;\r\n                  if (inputFilter) {\r\n                    try {\r\n                      // Build HandoffInputData with captured tool results\r\n                      const handoffInputData: HandoffInputData = {\r\n                        inputHistory: conversationMessages,\r\n                        preHandoffItems: [],\r\n                        newItems: Array.from(toolResults.entries()).map(\r\n                          ([name, result]) => ({\r\n                            toolName: name,\r\n                            result: result,\r\n                          }),\r\n                        ),\r\n                        runContext,\r\n                      };\r\n\r\n                      // Apply filter to modify conversation history\r\n                      const filteredData = inputFilter(handoffInputData);\r\n\r\n                      // Update conversation messages with filtered data\r\n                      conversationMessages.length = 0;\r\n                      conversationMessages.push(...filteredData.inputHistory);\r\n                    } catch (error) {\r\n                      logger.error(\"Error applying handoff input filter\", {\r\n                        error,\r\n                      });\r\n                      // Continue with original conversation messages as fallback\r\n                    }\r\n                  } else {\r\n                    // Use default input filter to modify conversation history\r\n                    logger.debug(\"Applying default input filter for\", {\r\n                      targetAgent: handoffData.targetAgent,\r\n                    });\r\n                    const defaultFilter = createDefaultInputFilter();\r\n\r\n                    const handoffInputData: HandoffInputData = {\r\n                      inputHistory: conversationMessages,\r\n                      preHandoffItems: [],\r\n                      newItems: Array.from(toolResults.entries()).map(\r\n                        ([name, result]) => ({\r\n                          toolName: name,\r\n                          result: result,\r\n                        }),\r\n                      ),\r\n                      runContext,\r\n                    };\r\n\r\n                    logger.debug(\"Input history length\", {\r\n                      length: handoffInputData.inputHistory.length,\r\n                    });\r\n                    logger.debug(\"Input history messages\", {\r\n                      messages: handoffInputData.inputHistory.map((m) => ({\r\n                        role: m.role,\r\n                        contentType: typeof m.content,\r\n                      })),\r\n                    });\r\n                    const filteredData = defaultFilter(handoffInputData);\r\n                    logger.debug(\"Filtered history length\", {\r\n                      length: filteredData.inputHistory.length,\r\n                    });\r\n\r\n                    // Update conversation messages with filtered data\r\n                    conversationMessages.length = 0;\r\n                    conversationMessages.push(...filteredData.inputHistory);\r\n                    logger.debug(\"Updated conversation messages length\", {\r\n                      length: conversationMessages.length,\r\n                    });\r\n                  }\r\n\r\n                  // Call onHandoff callback if configured\r\n                  if (configuredHandoff?.config?.onHandoff) {\r\n                    try {\r\n                      await configuredHandoff.config.onHandoff(runContext);\r\n                    } catch (error) {\r\n                      logger.error(\"Error in onHandoff callback\", { error });\r\n                      // Continue execution - callback errors shouldn't stop handoff\r\n                    }\r\n                  }\r\n\r\n                  currentAgent = nextAgent;\r\n\r\n                  writer.write({\r\n                    type: \"data-agent-handoff\",\r\n                    data: {\r\n                      from: this.name,\r\n                      to: nextAgent.name,\r\n                      reason: handoffData.reason,\r\n                      routingStrategy: \"llm\",\r\n                    },\r\n                    transient: true,\r\n                  } as never);\r\n\r\n                  // Emit handoff event\r\n                  if (onEvent) {\r\n                    await onEvent({\r\n                      type: \"agent-handoff\",\r\n                      from: this.name,\r\n                      to: nextAgent.name,\r\n                      reason: handoffData.reason,\r\n                    });\r\n                  }\r\n                }\r\n              } else {\r\n                // Orchestrator done, no more handoffs\r\n                break;\r\n              }\r\n            } else {\r\n              // Specialist done\r\n              if (handoffData) {\r\n                // Specialist handed off to another specialist\r\n                if (usedSpecialists.has(handoffData.targetAgent)) {\r\n                  // Already used this specialist - complete\r\n                  break;\r\n                }\r\n\r\n                // Route to next specialist\r\n                usedSpecialists.add(handoffData.targetAgent);\r\n                const nextAgent = specialists.find(\r\n                  (a) => a.name === handoffData.targetAgent,\r\n                );\r\n                if (nextAgent) {\r\n                  // Apply handoff input filter if configured\r\n                  const configuredHandoffs = this.getConfiguredHandoffs();\r\n                  const configuredHandoff = configuredHandoffs.find(\r\n                    (ch) => ch.agent.name === handoffData.targetAgent,\r\n                  );\r\n\r\n                  if (configuredHandoff?.config?.inputFilter) {\r\n                    try {\r\n                      // Build HandoffInputData\r\n                      const handoffInputData: HandoffInputData = {\r\n                        inputHistory: conversationMessages.slice(0, -1), // All messages except the last assistant message\r\n                        preHandoffItems: [], // No pre-handoff items for specialist-to-specialist\r\n                        newItems: conversationMessages.slice(-1), // The last assistant message\r\n                        runContext,\r\n                      };\r\n\r\n                      // Apply filter\r\n                      const filteredData =\r\n                        configuredHandoff.config.inputFilter(handoffInputData);\r\n\r\n                      // Update conversation messages with filtered data\r\n                      conversationMessages.length = 0;\r\n                      conversationMessages.push(\r\n                        ...filteredData.inputHistory,\r\n                        ...filteredData.newItems,\r\n                      );\r\n                    } catch (error) {\r\n                      logger.error(\"Error applying handoff input filter\", {\r\n                        error,\r\n                      });\r\n                      // Continue with original conversation messages as fallback\r\n                    }\r\n                  }\r\n\r\n                  // Call onHandoff callback if configured\r\n                  if (configuredHandoff?.config?.onHandoff) {\r\n                    try {\r\n                      await configuredHandoff.config.onHandoff(runContext);\r\n                    } catch (error) {\r\n                      logger.error(\"Error in onHandoff callback\", { error });\r\n                      // Continue execution - callback errors shouldn't stop handoff\r\n                    }\r\n                  }\r\n\r\n                  const previousAgent = currentAgent;\r\n                  currentAgent = nextAgent;\r\n\r\n                  // Write handoff to stream for devtools\r\n                  writer.write({\r\n                    type: \"data-agent-handoff\",\r\n                    data: {\r\n                      from: previousAgent.name,\r\n                      to: nextAgent.name,\r\n                      reason: handoffData.reason,\r\n                      routingStrategy: \"llm\",\r\n                    },\r\n                    transient: true,\r\n                  } as never);\r\n\r\n                  // Emit handoff event\r\n                  if (onEvent) {\r\n                    await onEvent({\r\n                      type: \"agent-handoff\",\r\n                      from: previousAgent.name,\r\n                      to: nextAgent.name,\r\n                      reason: handoffData.reason,\r\n                    });\r\n                  }\r\n                }\r\n              } else {\r\n                // No handoff - specialist is done, complete the task\r\n                break;\r\n              }\r\n            }\r\n          }\r\n\r\n          // Emit completion event\r\n          if (onEvent) {\r\n            await onEvent({\r\n              type: \"agent-complete\",\r\n              totalRounds: round,\r\n            });\r\n          }\r\n\r\n          // Generate suggestions after orchestration completes\r\n          const config = this.memory?.chats?.generateSuggestions;\r\n          const minLength =\r\n            typeof config === \"object\" && config.minResponseLength\r\n              ? config.minResponseLength\r\n              : 100;\r\n\r\n          // Get accumulated text length from conversation messages\r\n          const assistantMessages = conversationMessages.filter(\r\n            (m) => m.role === \"assistant\",\r\n          );\r\n          const totalTextLength = assistantMessages.reduce((sum, m) => {\r\n            return sum + (typeof m.content === \"string\" ? m.content.length : 0);\r\n          }, 0);\r\n\r\n          // Only generate if response is substantial enough\r\n          if (totalTextLength >= minLength) {\r\n            // Use focused context window (recent exchanges) instead of full history\r\n            const contextWindow =\r\n              typeof config === \"object\" && config.contextWindow\r\n                ? config.contextWindow\r\n                : 1;\r\n\r\n            // Get last N exchanges (user + assistant pairs)\r\n            const recentMessages = conversationMessages.slice(\r\n              -(contextWindow * 2),\r\n            );\r\n\r\n            const conversationContext = recentMessages\r\n              .map((msg) => {\r\n                const role = msg.role === \"user\" ? \"User\" : \"Assistant\";\r\n                return `${role}: ${typeof msg.content === \"string\" ? msg.content : JSON.stringify(msg.content)}`;\r\n              })\r\n              .join(\"\\n\\n\");\r\n\r\n            // Generate suggestions based on recent context\r\n            await this.generateSuggestions(\r\n              conversationContext,\r\n              conversationMessages,\r\n              writer,\r\n              context as TContext,\r\n            ).catch((err) =>\r\n              logger.error(\"Suggestion generation error\", { error: err }),\r\n            );\r\n          }\r\n\r\n          writer.write({ type: \"finish\" });\r\n        } catch (error) {\r\n          logger.error(\"Error in toUIMessageStream\", { error });\r\n\r\n          // Emit error event\r\n          if (onEvent) {\r\n            await onEvent({\r\n              type: \"agent-error\",\r\n              error: error instanceof Error ? error : new Error(String(error)),\r\n            });\r\n          }\r\n\r\n          // Type assertions needed: custom error and finish message formats\r\n          writer.write({\r\n            type: \"error\",\r\n            error: error instanceof Error ? error.message : String(error),\r\n          } as any);\r\n          writer.write({ type: \"finish\" } as any);\r\n        }\r\n      },\r\n    });\r\n\r\n    const response = createUIMessageStreamResponse({\r\n      stream,\r\n      status,\r\n      statusText,\r\n      headers,\r\n    });\r\n\r\n    return response;\r\n  }\r\n\r\n  /**\r\n   * Extract chatId and userId from context for memory operations\r\n   */\r\n  private extractMemoryIdentifiers(context: TContext): {\r\n    chatId?: string;\r\n    userId?: string;\r\n  } {\r\n    const ctx = context as TContext & MemoryIdentifiers;\r\n    const chatId = ctx.chatId || ctx.metadata?.chatId;\r\n    const userId = ctx.userId || ctx.metadata?.userId;\r\n    return { chatId, userId };\r\n  }\r\n\r\n  /**\r\n   * Generate a title for the chat based on the first user message\r\n   */\r\n  private async generateChatTitle(\r\n    chatId: string,\r\n    userMessage: string,\r\n    writer: UIMessageStreamWriter,\r\n    _context?: TContext,\r\n  ): Promise<void> {\r\n    if (!this.memory?.chats?.generateTitle) return;\r\n\r\n    const config = this.memory.chats.generateTitle;\r\n    const model = typeof config === \"object\" ? config.model : this.model;\r\n    const instructions =\r\n      typeof config === \"object\" && config.instructions\r\n        ? config.instructions\r\n        : `<task_context>\r\nYou are a helpful assistant that can generate titles for conversations.\r\n</task_context>\r\n\r\n<rules>\r\nFind the most concise title that captures what the user is asking for.\r\nTitles should be at most 30 characters.\r\nTitles should be formatted in sentence case, with capital letters at the start of each word. Do not provide a period at the end.\r\n</rules>\r\n\r\n<task>\r\nGenerate a title for the conversation.\r\n</task>\r\n\r\n<output_format>\r\nReturn only the title.\r\n</output_format>`;\r\n\r\n    try {\r\n      // Generate title based only on the user's message\r\n      const { text } = await generateText({\r\n        model,\r\n        system: instructions,\r\n        prompt: userMessage,\r\n        temperature: 0,\r\n      });\r\n\r\n      await this.memory.provider?.updateChatTitle?.(chatId, text);\r\n\r\n      writer.write({\r\n        type: \"data-chat-title\",\r\n        data: { chatId, title: text },\r\n      });\r\n\r\n      logger.debug(`Generated title for ${chatId}`, { chatId, title: text });\r\n    } catch (err) {\r\n      logger.error(\"Title generation failed\", { error: err });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build capabilities description from available tools and agents\r\n   */\r\n  private buildCapabilitiesDescription(context?: TContext): string {\r\n    const capabilities: string[] = [];\r\n\r\n    // Add tools (exclude internal tools)\r\n    if (this.configuredTools) {\r\n      // Resolve tools if they're a function\r\n      const resolvedTools =\r\n        typeof this.configuredTools === \"function\" && context\r\n          ? this.configuredTools(context)\r\n          : typeof this.configuredTools === \"object\"\r\n            ? this.configuredTools\r\n            : {};\r\n\r\n      const toolNames = Object.keys(resolvedTools).filter(\r\n        (name) => name !== \"handoff_to_agent\" && name !== \"updateWorkingMemory\",\r\n      );\r\n\r\n      if (toolNames.length > 0) {\r\n        capabilities.push(\"Available tools:\");\r\n        for (const toolName of toolNames) {\r\n          const tool = resolvedTools[toolName];\r\n          // @ts-expect-error - accessing internal tool properties\r\n          const description = tool?.spec?.description || toolName;\r\n          capabilities.push(`- ${toolName}: ${description}`);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Add handoff agents\r\n    const handoffs = this.getHandoffs();\r\n    if (handoffs.length > 0) {\r\n      if (capabilities.length > 0) capabilities.push(\"\");\r\n      capabilities.push(\"Can route to specialist agents:\");\r\n      for (const agent of handoffs) {\r\n        // @ts-expect-error - accessing internal agent properties\r\n        const description = agent.handoffDescription || `${agent.name} agent`;\r\n        capabilities.push(`- ${agent.name}: ${description}`);\r\n      }\r\n    }\r\n\r\n    return capabilities.join(\"\\n\");\r\n  }\r\n\r\n  /**\r\n   * Generate contextual prompt suggestions after agent response\r\n   */\r\n  private async generateSuggestions(\r\n    conversationContext: string,\r\n    conversationMessages: ModelMessage[],\r\n    writer: UIMessageStreamWriter,\r\n    context?: TContext,\r\n  ): Promise<void> {\r\n    const config = this.memory?.chats?.generateSuggestions;\r\n    if (!config) return;\r\n\r\n    // Handle boolean true (use defaults) or object config with enabled check\r\n    let enabled: boolean;\r\n    if (typeof config === \"boolean\") {\r\n      enabled = config;\r\n    } else if (typeof config.enabled === \"function\") {\r\n      // Call the function with messages and context\r\n      enabled = await config.enabled({\r\n        messages: conversationMessages,\r\n        context,\r\n      });\r\n    } else {\r\n      enabled = config.enabled;\r\n    }\r\n\r\n    if (!enabled) return;\r\n\r\n    const model =\r\n      typeof config === \"object\" && config.model ? config.model : this.model;\r\n    const limit = typeof config === \"object\" && config.limit ? config.limit : 5;\r\n\r\n    // Build default instructions with actual capabilities\r\n    const defaultInstructions = `Generate ${limit} contextual follow-up suggestions based on what was JUST discussed.\r\n\r\n${this.buildCapabilitiesDescription(context)}\r\n\r\nGuidelines:\r\n1. Analyze what the assistant just showed/discussed (data, analysis, insights)\r\n2. Suggest logical NEXT STEPS that build on this specific response\r\n3. Keep suggestions ultra-brief (2-3 words ideal, max 5 words)\r\n4. Use action verbs (\"Show\", \"Compare\", \"Analyze\", \"Check\", \"List\", \"Explore\")\r\n5. Make suggestions specific to the context, not generic\r\n6. Focus on available capabilities that provide value\r\n\r\nGood suggestions are:\r\n- Specific to what was just discussed\r\n- Actionable using available capabilities\r\n- Brief and clear (2-3 words)\r\n- Natural next steps, not repetitive`;\r\n\r\n    const instructions =\r\n      typeof config === \"object\" && config.instructions\r\n        ? config.instructions\r\n        : defaultInstructions;\r\n\r\n    try {\r\n      // Define schema for structured output\r\n      const suggestionsSchema = z.object({\r\n        prompts: z\r\n          .array(z.string().max(40))\r\n          .min(3)\r\n          .max(limit)\r\n          .describe(`Array of prompt suggestions (2-5 words each)`),\r\n      });\r\n\r\n      // Generate suggestions using structured output\r\n      const { object } = await generateObject({\n        model,\n        system: instructions,\n        prompt: conversationContext,\n        schema: suggestionsSchema,\n      });\n\r\n      const { prompts } = object;\r\n\r\n      // Stream suggestions as transient data part\r\n      writeSuggestions(writer, prompts);\r\n    } catch (err) {\r\n      logger.error(\"Suggestion generation failed\", { error: err });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create the updateWorkingMemory tool\r\n   */\r\n  private createWorkingMemoryTool() {\r\n    const scope = this.memory?.workingMemory?.scope || \"chat\";\r\n    const memory = this.memory;\r\n    const extractMemoryIdentifiers = this.extractMemoryIdentifiers.bind(this);\r\n\r\n    return tool({\r\n      description: `Save user information to persistent memory for future conversations.`,\r\n      inputSchema: z.object({\r\n        content: z\r\n          .string()\r\n          .describe(\r\n            \"Updated working memory content in markdown format. Include user preferences and any important facts to remember.\",\r\n          ),\r\n      }),\r\n      execute: async ({ content }, options) => {\r\n        logger.debug(\"updateWorkingMemory tool called\", {\r\n          contentLength: content.length,\r\n        });\r\n\r\n        if (!memory?.provider) {\r\n          logger.warn(\"Memory provider not configured\");\r\n          return \"Memory system not configured\";\r\n        }\r\n\r\n        const { getContext } = await import(\"./context.js\");\r\n        const ctx = getContext(\r\n          options as { experimental_context?: Record<string, unknown> },\r\n        );\r\n        const contextData = ctx as TContext | undefined;\r\n\r\n        if (!contextData) {\r\n          logger.warn(\"Context not available for working memory update\");\r\n          return \"Context not available\";\r\n        }\r\n\r\n        const { chatId, userId } = extractMemoryIdentifiers(contextData);\r\n        logger.debug(\"Updating working memory\", { chatId, userId, scope });\r\n\r\n        try {\r\n          await memory.provider.updateWorkingMemory({\r\n            chatId,\r\n            userId,\r\n            scope,\r\n            content,\r\n          });\r\n          logger.debug(\"Working memory updated successfully\");\r\n          return \"success\";\r\n        } catch (error) {\r\n          logger.error(\"Failed to update working memory\", {\r\n            error: error instanceof Error ? error.message : error,\r\n          });\r\n          return \"error\";\r\n        }\r\n      },\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Load working memory and inject into system prompt\r\n   */\r\n  private async loadWorkingMemory(context: TContext): Promise<string> {\r\n    if (!this.memory?.workingMemory?.enabled || !this.memory?.provider) {\r\n      return \"\";\r\n    }\r\n\r\n    const { chatId, userId } = this.extractMemoryIdentifiers(context);\r\n    const scope = this.memory.workingMemory.scope;\r\n\r\n    try {\r\n      const memory = await this.memory.provider.getWorkingMemory({\r\n        chatId,\r\n        userId,\r\n        scope,\r\n      });\r\n\r\n      if (!memory) return \"\";\r\n\r\n      return formatWorkingMemory(memory);\r\n    } catch (error) {\r\n      logger.error(\"Failed to load working memory\", {\r\n        error: error instanceof Error ? error.message : error,\r\n      });\r\n      return \"\";\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load message history from memory and prepend to the current message.\r\n   * Falls back to just the current message if history is disabled or unavailable.\r\n   *\r\n   * @param message - The current user message\r\n   * @param context - Execution context containing chatId\r\n   * @returns Array of ModelMessages including history + current message\r\n   */\r\n  private async loadMessagesWithHistory(\r\n    message: UIMessage,\r\n    context: TContext | undefined,\r\n  ): Promise<ModelMessage[]> {\r\n    // No memory - just convert the message\r\n    if (!this.memory?.history?.enabled || !context) {\r\n      logger.debug(\r\n        \"History disabled or no context - using single message only\",\r\n      );\r\n      return await convertToModelMessages([message]);\n    }\r\n\r\n    const { chatId } = this.extractMemoryIdentifiers(context);\r\n\r\n    if (!chatId) {\r\n      logger.warn(\"Cannot load history: chatId missing from context\");\r\n      return await convertToModelMessages([message]);\n    }\r\n\r\n    // Check if provider exists\r\n    if (!this.memory.provider) {\r\n      logger.warn(\"No memory provider configured - using single message only\");\r\n      return await convertToModelMessages([message]);\n    }\r\n\r\n    try {\r\n      const previousMessages =\r\n        (await this.memory.provider.getMessages?.({\r\n          chatId,\r\n          limit: this.memory.history.limit,\r\n        })) || [];\r\n\r\n      logger.debug(`Loading history for chatId=${chatId}`, {\r\n        chatId,\r\n        count: previousMessages.length,\r\n      });\r\n\r\n      if (previousMessages.length === 0) {\r\n        logger.debug(\"No previous messages found - starting new conversation\");\r\n        return convertToModelMessages([message]);\r\n      }\r\n\r\n      const historyMessages = await convertToModelMessages(\n        stripMetadata(previousMessages),\n      );\n\r\n      logger.debug(\r\n        `Loaded ${historyMessages.length} history messages for context`,\r\n        {\r\n          count: historyMessages.length,\r\n        },\r\n      );\r\n      return [...historyMessages, ...(await convertToModelMessages([message]))];\n    } catch (err) {\r\n      logger.error(`Load history failed for chatId=${chatId}`, {\r\n        chatId,\r\n        error: err,\r\n      });\r\n      return await convertToModelMessages([message]);\n    }\r\n  }\r\n\r\n  /**\r\n   * Save user and assistant messages, then update chat session.\r\n   * Messages are saved in parallel for better performance.\r\n   *\r\n   * @param chatId - The chat identifier\r\n   * @param userId - Optional user identifier\r\n   * @param userMessage - The user's message text\r\n   * @param assistantMessage - The assistant's response text\r\n   * @param existingChat - Pre-loaded chat object to avoid duplicate queries\r\n   */\r\n  private async saveConversation(\r\n    chatId: string,\r\n    userId: string | undefined,\r\n    userMessage: string,\r\n    assistantMessage: string,\r\n    existingChat?: any,\r\n  ): Promise<void> {\r\n    if (!this.memory?.provider || !this.memory?.history?.enabled) return;\r\n\r\n    logger.debug(`Saving conversation for chatId=${chatId}`, {\r\n      chatId,\r\n      userLength: userMessage.length,\r\n      assistantLength: assistantMessage.length,\r\n    });\r\n\r\n    // Save messages and update chat session in parallel for better performance\r\n    try {\r\n      const savePromises = [\r\n        this.memory.provider.saveMessage?.({\r\n          chatId,\r\n          userId,\r\n          role: \"user\",\r\n          content: userMessage,\r\n          timestamp: new Date(),\r\n        }),\r\n      ];\r\n\r\n      // Only save assistant message if it has content\r\n      if (assistantMessage && assistantMessage.length > 0) {\r\n        logger.debug(`Will save assistant message`, {\r\n          length: assistantMessage.length,\r\n        });\r\n        savePromises.push(\r\n          this.memory.provider.saveMessage?.({\r\n            chatId,\r\n            userId,\r\n            role: \"assistant\",\r\n            content: assistantMessage,\r\n            timestamp: new Date(),\r\n          }),\r\n        );\r\n      } else {\r\n        logger.warn(`Skipping assistant message save - empty or undefined`);\r\n      }\r\n\r\n      // Batch chat session update with message saves (using passed existingChat to avoid duplicate query)\r\n      if (this.memory?.chats?.enabled) {\r\n        const messageCount = savePromises.length;\r\n\r\n        savePromises.push(\r\n          this.memory.provider.saveChat?.({\r\n            ...(existingChat || { chatId, userId, createdAt: new Date() }),\r\n            messageCount: (existingChat?.messageCount || 0) + messageCount,\r\n            updatedAt: new Date(),\r\n          }),\r\n        );\r\n      }\r\n\r\n      await Promise.all(savePromises);\r\n\r\n      logger.debug(`Successfully saved ${savePromises.length} items`, {\r\n        chatId,\r\n        count: savePromises.length,\r\n      });\r\n    } catch (error) {\r\n      logger.error(`Failed to save messages for chatId=${chatId}`, {\r\n        chatId,\r\n        error,\r\n      });\r\n      throw error; // Re-throw to make save failures visible\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a chat title if this is the first message.\r\n   * Runs asynchronously without blocking the response.\r\n   *\r\n   * @param context - Execution context containing chatId\r\n   * @param userMessage - The user's message to generate title from\r\n   * @param writer - Stream writer for sending title update\r\n   * @param existingChat - Pre-loaded chat object to avoid duplicate queries\r\n   */\r\n  private async maybeGenerateChatTitle(\r\n    context: TContext | undefined,\r\n    userMessage: string,\r\n    writer: UIMessageStreamWriter,\r\n    existingChat?: any,\r\n  ): Promise<void> {\r\n    if (\r\n      !this.memory?.chats?.enabled ||\r\n      !this.memory?.chats?.generateTitle ||\r\n      !context\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const { chatId } = this.extractMemoryIdentifiers(context);\r\n\r\n    if (!chatId) {\r\n      logger.warn(\"Cannot generate title: chatId missing from context\");\r\n      return;\r\n    }\r\n\r\n    // Only generate for first message (using passed existingChat to avoid duplicate query)\r\n    const isFirstMessage = !existingChat || existingChat.messageCount === 0;\r\n    if (isFirstMessage) {\r\n      this.generateChatTitle(chatId, userMessage, writer, context).catch(\r\n        (err) => logger.error(\"Title generation error\", { error: err }),\r\n      );\r\n    }\r\n  }\r\n\r\n  static create<\r\n    TContext extends Record<string, unknown> = Record<string, unknown>,\r\n  >(config: AgentConfig<TContext>): Agent<TContext> {\r\n    return new Agent<TContext>(config);\r\n  }\r\n}\r\n","import { tool } from \"ai\";\r\nimport { z } from \"zod\";\r\nimport type { \r\n  Agent, \r\n  HandoffInstruction, \r\n  HandoffConfig, \r\n  ConfiguredHandoff,\r\n} from \"./types.js\";\r\n\r\n/**\r\n * Creates a handoff instruction for transferring to another agent\r\n */\r\nexport function createHandoff(\r\n  targetAgent: Agent | string,\r\n  context?: string,\r\n  reason?: string,\r\n): HandoffInstruction {\r\n  const targetName =\r\n    typeof targetAgent === \"string\" ? targetAgent : targetAgent.name;\r\n\r\n  return {\r\n    targetAgent: targetName,\r\n    context,\r\n    reason,\r\n  };\r\n}\r\n\r\n/**\r\n * Creates a configured handoff from an agent\r\n */\r\nexport function handoff<TContext extends Record<string, unknown> = Record<string, unknown>>(\r\n  agent: Agent<TContext>,\r\n  config?: HandoffConfig<TContext>\r\n): ConfiguredHandoff<TContext> {\r\n  return {\r\n    agent,\r\n    config,\r\n  };\r\n}\r\n\r\n/**\r\n * Generates the message that will be given as tool output to the model that requested the handoff\r\n */\r\nexport function getTransferMessage<TContext extends Record<string, unknown>>(agent: Agent<TContext>): string {\r\n  return JSON.stringify({ assistant: agent.name });\r\n}\r\n\r\n/**\r\n * Handoff tool that agents can use to transfer to other agents\r\n * Updated to work with ConfiguredHandoff\r\n */\r\nexport function createHandoffTool(availableHandoffs: Array<Agent | ConfiguredHandoff>) {\r\n  const agentNames = availableHandoffs.map((h) => \r\n    'agent' in h ? h.agent.name : h.name\r\n  );\r\n\r\n  return tool({\r\n    description: `Transfer the conversation to another specialized agent.\r\n    \r\nAvailable agents: ${agentNames.join(', ')}`,\r\n    inputSchema: z.object({\r\n      targetAgent: z.enum(agentNames as [string, ...string[]]),\r\n      context: z\r\n        .string()\r\n        .optional()\r\n        .describe(\"Context or summary to pass to the target agent\"),\r\n      reason: z.string().optional().describe(\"Reason for the handoff\"),\r\n    }),\r\n    execute: async ({ targetAgent, context, reason }) => {\r\n      // This will be handled by the runner\r\n      return createHandoff(targetAgent, context, reason);\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * The standard name for the handoff tool\r\n */\r\nexport const HANDOFF_TOOL_NAME = \"handoff_to_agent\";\r\n\r\n/**\r\n * Checks if a tool name is the handoff tool\r\n */\r\nexport function isHandoffTool(toolName: string | undefined): boolean {\r\n  return toolName === HANDOFF_TOOL_NAME;\r\n}\r\n\r\n/**\r\n * Checks if a result contains a handoff instruction\r\n */\r\nexport function isHandoffResult(result: unknown): result is HandoffInstruction {\r\n  return (\r\n    typeof result === \"object\" &&\r\n    result !== null &&\r\n    \"targetAgent\" in result &&\r\n    typeof (result as HandoffInstruction).targetAgent === \"string\"\r\n  );\r\n}\r\n","/**\r\n * A recommended prompt prefix for agents that use handoffs. We recommend including this or\r\n * similar instructions in any agents that use handoffs.\r\n */\r\nexport const RECOMMENDED_PROMPT_PREFIX = `<system_context>\r\nYou are part of a multi-agent system called AI SDK Agents, designed to make agent coordination and execution easy. This system uses two primary abstractions: **Agents** and **Handoffs**. An agent encompasses instructions and tools and can hand off a conversation to another agent when appropriate. Handoffs are achieved by calling a handoff function, generally named \\`handoff_to_agent\\`. Transfers between agents are handled seamlessly in the background; do not mention or draw attention to these transfers in your conversation with the user.\r\n</system_context>\r\n\r\n<tool_calling_guidelines>\r\nWhen you need to call multiple tools, call them ALL at once using parallel tool calling.\r\n</tool_calling_guidelines>`;\r\n\r\n/**\r\n * Add recommended instructions to the prompt for agents that use handoffs.\r\n *\r\n * @param prompt - The original prompt string.\r\n * @returns The prompt prefixed with recommended handoff instructions.\r\n */\r\nexport function promptWithHandoffInstructions(prompt: string): string {\r\n  return `${RECOMMENDED_PROMPT_PREFIX}\\n\\n${prompt}`;\r\n}\r\n","/**\r\n * AgentRunContext\r\n * \r\n * Tracks user context and metadata throughout agent workflows.\r\n */\r\n\r\nexport class AgentRunContext<TContext = Record<string, unknown>> {\r\n  /**\r\n   * The context object passed to the agent workflow\r\n   */\r\n  public context: TContext;\r\n\r\n  /**\r\n   * Additional metadata for the run\r\n   */\r\n  public metadata: Record<string, unknown>;\r\n\r\n  constructor(context?: TContext) {\r\n    this.context = (context || {}) as TContext;\r\n    this.metadata = {};\r\n  }\r\n\r\n  /**\r\n   * Serialize the run context to JSON\r\n   */\r\n  toJSON(): {\r\n    context: TContext;\r\n    metadata: Record<string, unknown>;\r\n  } {\r\n    return {\r\n      context: this.context,\r\n      metadata: this.metadata,\r\n    };\r\n  }\r\n}\r\n","/**\r\n * Type-safe streaming utilities for agent orchestration\r\n *\r\n * This module provides helper functions for writing custom data parts\r\n * to the UI message stream following the AI SDK's streaming data pattern.\r\n */\r\n\r\nimport type { UIMessageStreamWriter } from \"ai\";\r\nimport type { AgentDataParts } from \"./types.js\";\r\n\r\n/**\r\n * Write a typed data part to the stream.\r\n *\r\n * This helper provides type-safe access to agent data parts while handling\r\n * the necessary type assertions for AI SDK's internal types.\r\n *\r\n * @template K - Key of the data part type\r\n * @param writer - The UI message stream writer\r\n * @param type - The data part type (e.g., 'data-agent-status')\r\n * @param data - The data payload\r\n * @param options - Additional options (transient, id for reconciliation)\r\n *\r\n * @example\r\n * ```typescript\r\n * writeDataPart(writer, 'data-agent-status', {\r\n *   status: 'executing',\r\n *   agent: 'analytics'\r\n * }, { transient: true });\r\n * ```\r\n */\r\nexport function writeDataPart<K extends keyof AgentDataParts>(\r\n  writer: UIMessageStreamWriter,\r\n  type: `data-${K}`,\r\n  data: AgentDataParts[K],\r\n  options?: { transient?: boolean; id?: string },\r\n): void {\r\n  writer.write({\r\n    type,\r\n    data,\r\n    ...options,\r\n  } as never);\r\n}\r\n\r\n/**\r\n * Write a transient agent status update.\r\n *\r\n * Status updates are ephemeral and won't be added to message history.\r\n * They're only available via the onData callback in useChat.\r\n *\r\n * @param writer - The UI message stream writer\r\n * @param status - The status update data\r\n *\r\n * @example\r\n * ```typescript\r\n * writeAgentStatus(writer, {\r\n *   status: 'routing',\r\n *   agent: 'orchestrator'\r\n * });\r\n * ```\r\n */\r\nexport function writeAgentStatus(\r\n  writer: UIMessageStreamWriter,\r\n  status: AgentDataParts[\"agent-status\"],\r\n): void {\r\n  writeDataPart(writer, \"data-agent-status\", status, { transient: true });\r\n}\r\n\r\n/**\r\n * Write a transient rate limit update.\r\n *\r\n * Rate limit updates are ephemeral and won't be added to message history.\r\n * They're only available via the onData callback in useChat.\r\n *\r\n * @param writer - The UI message stream writer\r\n * @param rateLimit - The rate limit data\r\n *\r\n * @example\r\n * ```typescript\r\n * writeRateLimit(writer, {\r\n *   limit: 100,\r\n *   remaining: 95,\r\n *   reset: '2024-01-01T00:00:00Z'\r\n * });\r\n * ```\r\n */\r\nexport function writeRateLimit(\r\n  writer: UIMessageStreamWriter,\r\n  rateLimit: AgentDataParts[\"rate-limit\"],\r\n): void {\r\n  writeDataPart(writer, \"data-rate-limit\", rateLimit, { transient: true });\r\n}\r\n\r\n/**\r\n * Write transient suggested prompts.\r\n *\r\n * Suggested prompts are ephemeral and won't be added to message history.\r\n * They're only available via the onData callback in useChat.\r\n *\r\n * @param writer - The UI message stream writer\r\n * @param prompts - Array of suggested prompt strings\r\n *\r\n * @example\r\n * ```typescript\r\n * writeSuggestions(writer, [\r\n *   'Show me the balance sheet',\r\n *   'What is our burn rate?',\r\n *   'Analyze revenue trends'\r\n * ]);\r\n * ```\r\n */\r\nexport function writeSuggestions(\r\n  writer: UIMessageStreamWriter,\r\n  prompts: string[],\r\n): void {\r\n  writeDataPart(writer, \"data-suggestions\", { prompts }, { transient: true });\r\n}\r\n","/**\r\n * Tool Result Extractor\r\n * \r\n * Extracts tool results from conversation messages to pass to handoff agents\r\n */\r\n\r\nimport type { ModelMessage } from \"ai\";\r\nimport type { HandoffInputData } from \"./types.js\";\r\nimport { createLogger } from \"@ai-sdk-tools/debug\";\r\n\r\nconst logger = createLogger('TOOL_EXTRACTOR');\r\n\r\n/**\r\n * Extract tool results from conversation messages\r\n */\r\nexport function extractToolResults(messages: ModelMessage[]): Record<string, any> {\r\n  const toolResults: Record<string, any> = {};\r\n  \r\n  logger.debug(`Analyzing ${messages.length} messages for tool results`, { count: messages.length });\r\n  \r\n  for (let i = 0; i < messages.length; i++) {\r\n    const message = messages[i];\r\n    logger.debug(`Message ${i}`, { role: message.role, contentType: typeof message.content });\r\n    \r\n    if (message.role === \"assistant\" && message.content) {\r\n      // Look for tool calls in assistant messages\r\n      if (Array.isArray(message.content)) {\r\n        logger.debug(`Assistant message has ${message.content.length} content items`, { count: message.content.length });\r\n        for (const content of message.content) {\r\n          logger.debug(`Content item type: ${content.type}`, { type: content.type });\r\n          if (content.type === \"tool-result\") {\r\n            const toolName = content.toolName;\r\n            const result = (content as any).result || (content as any).output;\r\n            logger.debug(`Found tool result: ${toolName}`, { toolName });\r\n            if (toolName && result) {\r\n              toolResults[toolName] = result;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Also check for tool results in the message itself\r\n    if (message.role === \"tool\" && message.content) {\r\n      // Tool messages contain the result directly\r\n      const toolName = (message as any).toolName;\r\n      logger.debug(`Tool message: ${toolName}`, { toolName });\r\n      if (toolName && message.content) {\r\n        try {\r\n          const result = typeof message.content === 'string' \r\n            ? JSON.parse(message.content) \r\n            : message.content;\r\n          toolResults[toolName] = result;\r\n        } catch (e) {\r\n          // If not JSON, store as string\r\n          toolResults[toolName] = message.content;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  logger.debug(\"Final tool results\", { tools: Object.keys(toolResults) });\r\n  return toolResults;\r\n}\r\n\r\n/**\r\n * Create a default input filter that modifies conversation history to include tool results\r\n * \r\n * @internal This is automatically applied during handoffs. You typically don't need to use this directly.\r\n * Simply use `handoff(agent)` without specifying an inputFilter.\r\n */\r\nexport function createDefaultInputFilter(): (input: HandoffInputData) => HandoffInputData {\r\n  return (input: HandoffInputData) => {\r\n    logger.debug(`Processing input history with ${input.inputHistory.length} messages`, { \r\n      historyCount: input.inputHistory.length \r\n    });\r\n    logger.debug(`Processing newItems with ${input.newItems.length} items`, { \r\n      newItemsCount: input.newItems.length \r\n    });\r\n    \r\n    // Extract tool results from newItems\r\n    const toolResults: Record<string, any> = {};\r\n    \r\n    // Process newItems to extract tool results\r\n    for (const item of input.newItems) {\r\n      logger.debug(`Processing newItem: ${typeof item}`, { itemType: typeof item });\r\n      \r\n      // Check if item has tool results\r\n      if (item && typeof item === 'object') {\r\n        // Look for tool result properties\r\n        if ('toolName' in item && 'result' in item) {\r\n          const toolName = (item as any).toolName;\r\n          const result = (item as any).result;\r\n          if (toolName && result) {\r\n            toolResults[toolName] = result;\r\n            logger.debug(`Found tool result in newItems: ${toolName}`, { toolName });\r\n          }\r\n        }\r\n        \r\n        // Also check for nested tool results\r\n        if ('content' in item && Array.isArray((item as any).content)) {\r\n          const content = (item as any).content;\r\n          for (const contentItem of content) {\r\n            if (contentItem.type === 'tool-result' && contentItem.toolName && contentItem.result) {\r\n              toolResults[contentItem.toolName] = contentItem.result;\r\n              logger.debug(`Found nested tool result: ${contentItem.toolName}`, { toolName: contentItem.toolName });\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    logger.debug(\"Extracted tool results from newItems\", { tools: Object.keys(toolResults) });\r\n    \r\n    // Create a summary message with the available data\r\n    if (Object.keys(toolResults).length > 0) {\r\n      const dataSummary = Object.entries(toolResults)\r\n        .map(([key, value]) => {\r\n          // Generic data summary based on value type\r\n          if (Array.isArray(value)) {\r\n            return `Available ${key} data: ${value.length} items found`;\r\n          }\r\n          if (typeof value === 'object' && value !== null) {\r\n            return `Available ${key} data: ${JSON.stringify(value)}`;\r\n          }\r\n          return `Available ${key} data: ${value}`;\r\n        })\r\n        .join('\\n');\r\n      \r\n      // Add a system message with the available data\r\n      const dataMessage: ModelMessage = {\r\n        role: 'system',\r\n        content: `Available data from previous agent:\\n${dataSummary}\\n\\n**IMPORTANT**: Only use this data if it's DIRECTLY relevant to the current user question. If the user is asking about something different, ignore this data and call the appropriate tools.`\r\n      };\r\n      \r\n      // Ensure we keep the original conversation and add the data message\r\n      const enhancedHistory = [...input.inputHistory];\r\n      if (enhancedHistory.length === 0) {\r\n        // If no history, add a user message to maintain context\r\n        enhancedHistory.push({\r\n          role: 'user',\r\n          content: 'Please help with the request using the available data.'\r\n        });\r\n      }\r\n      enhancedHistory.push(dataMessage);\r\n      \r\n      return {\r\n        ...input,\r\n        inputHistory: enhancedHistory,\r\n      };\r\n    }\r\n    \r\n    return input;\r\n  };\r\n}\r\n\r\n/**\r\n * Create an input filter that only passes recent tool results\r\n */\r\nexport function createRecentDataFilter(maxAge: number = 5): (input: HandoffInputData) => HandoffInputData {\r\n  return (input: HandoffInputData) => {\r\n    // Only look at recent messages (last maxAge messages)\r\n    const recentMessages = input.inputHistory.slice(-maxAge);\r\n    const toolResults = extractToolResults(recentMessages);\r\n    \r\n    return {\r\n      ...input,\r\n      availableData: toolResults,\r\n    };\r\n  };\r\n}\r\n","import { isToolUIPart, type ModelMessage, type UIMessage } from \"ai\";\r\n\r\n/**\r\n * Extract text content from a ModelMessage.\r\n * Handles both string content and content arrays with text parts.\r\n *\r\n * @param message - The message to extract text from\r\n * @returns The extracted text content, or an empty string if none found\r\n *\r\n * @example\r\n * ```ts\r\n * const text = extractTextFromMessage(message);\r\n * // \"Hello world\"\r\n * ```\r\n */\r\nexport function extractTextFromMessage(\r\n  message: ModelMessage | undefined,\r\n): string {\r\n  if (!message?.content) return \"\";\r\n\r\n  const { content } = message;\r\n\r\n  // String content\r\n  if (typeof content === \"string\") return content;\r\n\r\n  // Array of parts - extract all text parts and join them\r\n  if (Array.isArray(content)) {\r\n    return content\r\n      .filter(\r\n        (part): part is { type: \"text\"; text: string } =>\r\n          typeof part === \"object\" && part !== null && part.type === \"text\",\r\n      )\r\n      .map((part) => part.text)\r\n      .join(\"\");\r\n  }\r\n\r\n  return \"\";\r\n}\r\n\r\n/**\r\n * Strip metadata from UI messages to prevent duplicate ID errors.\r\n * Provider metadata (like OpenAI item IDs) should not be reused across API calls.\r\n */\r\nexport function stripMetadata(messages: UIMessage[]): UIMessage[] {\r\n  return messages.map((msg) => ({\r\n    ...msg,\r\n    parts: msg.parts?.map((part) => {\r\n      const sanitizedPart: typeof part = { ...part };\r\n\r\n      if (\"providerMetadata\" in sanitizedPart) {\r\n        sanitizedPart.providerMetadata = undefined;\r\n      }\r\n\r\n      if (\r\n        isToolUIPart(sanitizedPart) &&\r\n        \"callProviderMetadata\" in sanitizedPart\r\n      ) {\r\n        sanitizedPart.callProviderMetadata = undefined;\r\n      }\r\n\r\n      return sanitizedPart;\r\n    }),\r\n  }));\r\n}\r\n","// Core exports\r\nexport { Agent } from \"./agent.js\";\r\nexport type { ContextOptions, ExecutionContext } from \"./context.js\";\r\n// Context management\r\nexport { createExecutionContext, getContext } from \"./context.js\";\r\n// Guardrails\r\nexport {\r\n  AgentsError,\r\n  GuardrailExecutionError,\r\n  InputGuardrailTripwireTriggered,\r\n  MaxTurnsExceededError,\r\n  OutputGuardrailTripwireTriggered,\r\n  runInputGuardrails,\r\n  runOutputGuardrails,\r\n  ToolCallError,\r\n  ToolPermissionDeniedError,\r\n} from \"./guardrails.js\";\r\n// Handoff utilities\r\nexport {\r\n  createHandoff,\r\n  createHandoffTool,\r\n  isHandoffResult,\r\n  isHandoffTool,\r\n  HANDOFF_TOOL_NAME,\r\n  handoff,\r\n  getTransferMessage,\r\n} from \"./handoff.js\";\r\n// Permissions\r\nexport {\r\n  checkToolPermission,\r\n  createUsageTracker,\r\n  trackToolCall,\r\n} from \"./permissions.js\";\r\n// Routing\r\nexport { findBestMatch, matchAgent } from \"./routing.js\";\r\nexport { AgentRunContext } from \"./run-context.js\";\r\n// Streaming utilities\r\nexport {\r\n  writeAgentStatus,\r\n  writeDataPart,\r\n  writeRateLimit,\r\n} from \"./streaming.js\";\r\n// Types\r\nexport type {\r\n  AgentConfig,\r\n  AgentDataParts,\r\n  AgentEvent,\r\n  AgentGenerateOptions,\r\n  AgentGenerateResult,\r\n  AgentStreamOptions,\r\n  AgentStreamOptionsUI,\r\n  AgentStreamResult,\r\n  AgentUIMessage,\r\n  ConfiguredHandoff,\r\n  ExtendedExecutionContext,\r\n  GuardrailResult,\r\n  HandoffConfig,\r\n  HandoffData,\r\n  HandoffInstruction,\r\n  InputGuardrail,\r\n  MemoryIdentifiers,\r\n  OutputGuardrail,\r\n  ToolPermissionCheck,\r\n  ToolPermissionContext,\r\n  ToolPermissionResult,\r\n  ToolPermissions,\r\n} from \"./types.js\";\r\n// Utilities\r\nexport { extractTextFromMessage } from \"./utils.js\";\r\n","import type { InputGuardrail, OutputGuardrail } from \"./types.js\";\r\n\r\n/**\r\n * Base error class for all agent errors\r\n */\r\nexport class AgentsError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public readonly state?: unknown,\r\n  ) {\r\n    super(message);\r\n    this.name = \"AgentsError\";\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when input guardrail tripwire is triggered\r\n */\r\nexport class InputGuardrailTripwireTriggered extends AgentsError {\r\n  constructor(\r\n    public readonly guardrailName: string,\r\n    public readonly outputInfo?: unknown,\r\n    state?: unknown,\r\n  ) {\r\n    super(`Input guardrail tripwire triggered: ${guardrailName}`, state);\r\n    this.name = \"InputGuardrailTripwireTriggered\";\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when output guardrail tripwire is triggered\r\n */\r\nexport class OutputGuardrailTripwireTriggered extends AgentsError {\r\n  constructor(\r\n    public readonly guardrailName: string,\r\n    public readonly outputInfo?: unknown,\r\n    state?: unknown,\r\n  ) {\r\n    super(`Output guardrail tripwire triggered: ${guardrailName}`, state);\r\n    this.name = \"OutputGuardrailTripwireTriggered\";\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when a guardrail fails to execute\r\n */\r\nexport class GuardrailExecutionError extends AgentsError {\r\n  constructor(\r\n    public readonly guardrailName: string,\r\n    public readonly originalError: Error,\r\n    state?: unknown,\r\n  ) {\r\n    super(\r\n      `Guardrail execution failed: ${guardrailName} - ${originalError.message}`,\r\n      state,\r\n    );\r\n    this.name = \"GuardrailExecutionError\";\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when maximum turns are exceeded\r\n */\r\nexport class MaxTurnsExceededError extends AgentsError {\r\n  constructor(\r\n    public readonly currentTurns: number,\r\n    public readonly maxTurns: number,\r\n    state?: unknown,\r\n  ) {\r\n    super(`Maximum turns exceeded: ${currentTurns}/${maxTurns}`, state);\r\n    this.name = \"MaxTurnsExceededError\";\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when a tool call fails\r\n */\r\nexport class ToolCallError extends AgentsError {\r\n  constructor(\r\n    public readonly toolName: string,\r\n    public readonly originalError: Error,\r\n    state?: unknown,\r\n  ) {\r\n    super(`Tool call failed: ${toolName} - ${originalError.message}`, state);\r\n    this.name = \"ToolCallError\";\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown for tool permission denial\r\n */\r\nexport class ToolPermissionDeniedError extends AgentsError {\r\n  constructor(\r\n    public readonly toolName: string,\r\n    public readonly reason: string,\r\n    state?: unknown,\r\n  ) {\r\n    super(`Tool permission denied: ${toolName} - ${reason}`, state);\r\n    this.name = \"ToolPermissionDeniedError\";\r\n  }\r\n}\r\n\r\n/**\r\n * Run input guardrails in parallel\r\n */\r\nexport async function runInputGuardrails(\r\n  guardrails: InputGuardrail[],\r\n  input: string,\r\n  context?: unknown,\r\n): Promise<void> {\r\n  if (!guardrails || guardrails.length === 0) return;\r\n\r\n  const results = await Promise.allSettled(\r\n    guardrails.map(async (guardrail) => {\r\n      try {\r\n        const result = await guardrail.execute({ input, context });\r\n        if (result.tripwireTriggered) {\r\n          throw new InputGuardrailTripwireTriggered(\r\n            guardrail.name,\r\n            result.outputInfo,\r\n          );\r\n        }\r\n        return result;\r\n      } catch (error) {\r\n        if (error instanceof InputGuardrailTripwireTriggered) {\r\n          throw error;\r\n        }\r\n        throw new GuardrailExecutionError(\r\n          guardrail.name,\r\n          error instanceof Error ? error : new Error(String(error)),\r\n        );\r\n      }\r\n    }),\r\n  );\r\n\r\n  // Check for failures\r\n  for (const result of results) {\r\n    if (result.status === \"rejected\") {\r\n      throw result.reason;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Run output guardrails in parallel\r\n */\r\nexport async function runOutputGuardrails<TOutput = unknown>(\r\n  guardrails: OutputGuardrail<TOutput>[],\r\n  agentOutput: TOutput,\r\n  context?: unknown,\r\n): Promise<void> {\r\n  if (!guardrails || guardrails.length === 0) return;\r\n\r\n  const results = await Promise.allSettled(\r\n    guardrails.map(async (guardrail) => {\r\n      try {\r\n        const result = await guardrail.execute({ agentOutput, context });\r\n        if (result.tripwireTriggered) {\r\n          throw new OutputGuardrailTripwireTriggered(\r\n            guardrail.name,\r\n            result.outputInfo,\r\n          );\r\n        }\r\n        return result;\r\n      } catch (error) {\r\n        if (error instanceof OutputGuardrailTripwireTriggered) {\r\n          throw error;\r\n        }\r\n        throw new GuardrailExecutionError(\r\n          guardrail.name,\r\n          error instanceof Error ? error : new Error(String(error)),\r\n        );\r\n      }\r\n    }),\r\n  );\r\n\r\n  // Check for failures\r\n  for (const result of results) {\r\n    if (result.status === \"rejected\") {\r\n      throw result.reason;\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Tool Permissions System\r\n *\r\n * Runtime access control for tool execution\r\n */\r\n\r\nimport { ToolPermissionDeniedError } from \"./guardrails.js\";\r\nimport type { ToolPermissionContext, ToolPermissions } from \"./types.js\";\r\n\r\n/**\r\n * Check if a tool can be executed based on permissions\r\n */\r\nexport async function checkToolPermission(\r\n  permissions: ToolPermissions | undefined,\r\n  toolName: string,\r\n  args: unknown,\r\n  context: ToolPermissionContext,\r\n): Promise<void> {\r\n  if (!permissions) return;\r\n\r\n  try {\r\n    const result = await permissions.check({ toolName, args, context });\r\n\r\n    if (!result.allowed) {\r\n      throw new ToolPermissionDeniedError(\r\n        toolName,\r\n        result.reason || \"Permission denied\",\r\n      );\r\n    }\r\n  } catch (error) {\r\n    if (error instanceof ToolPermissionDeniedError) {\r\n      throw error;\r\n    }\r\n    // Re-throw other errors as-is\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Create a tool usage tracker for permission context\r\n */\r\nexport function createUsageTracker(): ToolPermissionContext[\"usage\"] {\r\n  return {\r\n    toolCalls: {},\r\n    tokens: 0,\r\n  };\r\n}\r\n\r\n/**\r\n * Update usage tracker with tool call\r\n */\r\nexport function trackToolCall(\r\n  usage: ToolPermissionContext[\"usage\"],\r\n  toolName: string,\r\n): void {\r\n  usage.toolCalls[toolName] = (usage.toolCalls[toolName] || 0) + 1;\r\n}\r\n","/**\r\n * Programmatic Routing System\r\n *\r\n * Matches user messages to agents based on keywords, patterns, or custom functions\r\n */\r\n\r\nimport type { Agent } from \"./types.js\";\r\nimport { createLogger } from \"@ai-sdk-tools/debug\";\r\n\r\nconst logger = createLogger('ROUTING');\r\n\r\n/**\r\n * Normalize text for better matching\r\n * - Lowercase\r\n * - Remove numbers\r\n * - Remove extra whitespace\r\n * - Simple plural â†’ singular\r\n */\r\nfunction normalizeText(text: string): string {\r\n  return text\r\n    .toLowerCase()\r\n    .trim()\r\n    .replace(/\\d+/g, \"\") // remove numbers\r\n    .replace(/\\s+/g, \" \") // normalize whitespace\r\n    .trim();\r\n}\r\n\r\n/**\r\n * Match a message against an agent's matchOn patterns\r\n */\r\nexport function matchAgent(\r\n  agent: Agent,\r\n  message: string,\r\n  matchOn?: (string | RegExp)[] | ((message: string) => boolean),\r\n): { matched: boolean; score: number } {\r\n  if (!matchOn) {\r\n    return { matched: false, score: 0 };\r\n  }\r\n\r\n  const normalizedMessage = normalizeText(message);\r\n  let score = 0;\r\n\r\n  // Function-based matching\r\n  if (typeof matchOn === \"function\") {\r\n    try {\r\n      const result = matchOn(message);\r\n      return { matched: result, score: result ? 10 : 0 };\r\n    } catch (error) {\r\n      logger.error(`Error in matchOn function for ${agent.name}`, { \r\n        agent: agent.name, \r\n        error \r\n      });\r\n      return { matched: false, score: 0 };\r\n    }\r\n  }\r\n\r\n  // Array-based matching (strings and regex)\r\n  for (const pattern of matchOn) {\r\n    if (typeof pattern === \"string\") {\r\n      // String keyword matching\r\n      const normalizedPattern = normalizeText(pattern);\r\n      if (normalizedMessage.includes(normalizedPattern)) {\r\n        // Weight longer keywords higher (more specific)\r\n        const weight = normalizedPattern.split(\" \").length;\r\n        score += weight;\r\n      }\r\n    } else if (pattern instanceof RegExp) {\r\n      // Regex pattern matching\r\n      if (pattern.test(normalizedMessage)) {\r\n        score += 2; // Regex matches get higher weight\r\n      }\r\n    }\r\n  }\r\n\r\n  return { matched: score > 0, score };\r\n}\r\n\r\n/**\r\n * Find the best matching agent from a list of agents\r\n */\r\nexport function findBestMatch(\r\n  agents: Agent[],\r\n  message: string,\r\n  getMatchOn?: (\r\n    agent: Agent,\r\n  ) => (string | RegExp)[] | ((message: string) => boolean) | undefined,\r\n): Agent | null {\r\n  const scores: Array<{ agent: Agent; score: number }> = [];\r\n\r\n  for (const agent of agents) {\r\n    const matchOn = getMatchOn ? getMatchOn(agent) : undefined;\r\n    const { matched, score } = matchAgent(agent, message, matchOn);\r\n\r\n    if (matched && score > 0) {\r\n      scores.push({ agent, score });\r\n    }\r\n  }\r\n\r\n  // No matches found\r\n  if (scores.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  // Sort by score (highest first)\r\n  scores.sort((a, b) => b.score - a.score);\r\n\r\n  // Return agent with highest score\r\n  return scores[0].agent;\r\n}\r\n"],"mappings":"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","names":["tool","z","logger","result","tool","z","getContext","logger"]}