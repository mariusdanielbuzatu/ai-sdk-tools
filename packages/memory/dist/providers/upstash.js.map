{"version":3,"sources":["../../../debug/src/index.ts","../../src/providers/upstash.ts"],"sourcesContent":["const isDebugEnabled = process.env.DEBUG_AGENTS === 'true';\r\n\r\n// ANSI color codes for terminal output\r\nconst colors = {\r\n  reset: '\\x1b[0m',\r\n  gray: '\\x1b[90m',\r\n  blue: '\\x1b[34m',\r\n  cyan: '\\x1b[36m',\r\n  yellow: '\\x1b[33m',\r\n  red: '\\x1b[31m',\r\n  green: '\\x1b[32m',\r\n  magenta: '\\x1b[35m',\r\n};\r\n\r\n// Format timestamp\r\nconst timestamp = () => new Date().toISOString().slice(11, 23);\r\n\r\n// Create category-scoped logger with clean API\r\nexport function createLogger(category: string) {\r\n  if (!isDebugEnabled) {\r\n    // Return no-op functions when debug is disabled\r\n    return {\r\n      debug: () => {},\r\n      info: () => {},\r\n      warn: () => {},\r\n      error: () => {},\r\n    };\r\n  }\r\n\r\n  return {\r\n    debug: (message: string, data?: any) => {\r\n      const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n      const level = `${colors.blue}DEBUG${colors.reset}`;\r\n      const cat = `${colors.cyan}[${category}]${colors.reset}`;\r\n      const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n      console.log(`${ts} ${level} ${cat} ${message}${dataStr}`);\r\n    },\r\n    info: (message: string, data?: any) => {\r\n      const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n      const level = `${colors.green}INFO${colors.reset}`;\r\n      const cat = `${colors.cyan}[${category}]${colors.reset}`;\r\n      const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n      console.log(`${ts} ${level} ${cat} ${message}${dataStr}`);\r\n    },\r\n    warn: (message: string, data?: any) => {\r\n      const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n      const level = `${colors.yellow}WARN${colors.reset}`;\r\n      const cat = `${colors.cyan}[${category}]${colors.reset}`;\r\n      const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n      console.warn(`${ts} ${level} ${cat} ${message}${dataStr}`);\r\n    },\r\n    error: (message: string, data?: any) => {\r\n      const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n      const level = `${colors.red}ERROR${colors.reset}`;\r\n      const cat = `${colors.cyan}[${category}]${colors.reset}`;\r\n      const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n      console.error(`${ts} ${level} ${cat} ${message}${dataStr}`);\r\n    },\r\n  };\r\n}\r\n\r\n// Export a base logger for backward compatibility\r\nexport const logger = {\r\n  debug: (message: string, data?: any) => {\r\n    if (!isDebugEnabled) return;\r\n    const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n    const level = `${colors.blue}DEBUG${colors.reset}`;\r\n    const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n    console.log(`${ts} ${level} ${message}${dataStr}`);\r\n  },\r\n  info: (message: string, data?: any) => {\r\n    if (!isDebugEnabled) return;\r\n    const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n    const level = `${colors.green}INFO${colors.reset}`;\r\n    const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n    console.log(`${ts} ${level} ${message}${dataStr}`);\r\n  },\r\n  warn: (message: string, data?: any) => {\r\n    if (!isDebugEnabled) return;\r\n    const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n    const level = `${colors.yellow}WARN${colors.reset}`;\r\n    const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n    console.warn(`${ts} ${level} ${message}${dataStr}`);\r\n  },\r\n  error: (message: string, data?: any) => {\r\n    if (!isDebugEnabled) return;\r\n    const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n    const level = `${colors.red}ERROR${colors.reset}`;\r\n    const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n    console.error(`${ts} ${level} ${message}${dataStr}`);\r\n  },\r\n};\r\n\r\n","import { createLogger } from \"@ai-sdk-tools/debug\";\r\nimport type { Redis } from \"@upstash/redis\";\r\nimport type {\r\n  ChatSession,\r\n  ConversationMessage,\r\n  MemoryProvider,\r\n  MemoryScope,\r\n  UIMessage,\r\n  WorkingMemory,\r\n} from \"../types.js\";\r\n\r\nconst logger = createLogger(\"UPSTASH\");\r\n\r\n/**\r\n * Configuration options for UpstashProvider\r\n */\r\nexport interface UpstashProviderOptions {\r\n  /** Key prefix for all Redis keys (default: \"memory:\") */\r\n  prefix?: string;\r\n  /** TTL in seconds for message lists (default: no expiration) */\r\n  messageTtl?: number;\r\n}\r\n\r\n/**\r\n * Upstash Redis provider - serverless edge\r\n */\r\nexport class UpstashProvider implements MemoryProvider {\r\n  private readonly messageTtl?: number;\r\n  private readonly prefix: string;\r\n\r\n  constructor(\r\n    private redis: Redis,\r\n    options?: UpstashProviderOptions,\r\n  ) {\r\n    this.prefix = options?.prefix ?? \"memory:\";\r\n    this.messageTtl = options?.messageTtl;\r\n  }\r\n\r\n  async getWorkingMemory(params: {\r\n    chatId?: string;\r\n    userId?: string;\r\n    scope: MemoryScope;\r\n  }): Promise<WorkingMemory | null> {\r\n    const key = this.getKey(\"wm\", params.scope, params.chatId, params.userId);\r\n    return await this.redis.get<WorkingMemory>(key);\r\n  }\r\n\r\n  async updateWorkingMemory(params: {\r\n    chatId?: string;\r\n    userId?: string;\r\n    scope: MemoryScope;\r\n    content: string;\r\n  }): Promise<void> {\r\n    const key = this.getKey(\"wm\", params.scope, params.chatId, params.userId);\r\n    logger.debug(\"updateWorkingMemory called\", {\r\n      key,\r\n      scope: params.scope,\r\n      chatId: params.chatId,\r\n      userId: params.userId,\r\n      contentLength: params.content.length,\r\n    });\r\n\r\n    const memory: WorkingMemory = {\r\n      content: params.content,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    // TTL: 30 days for user, 24h for chat\r\n    const ttl = params.scope === \"user\" ? 60 * 60 * 24 * 30 : 60 * 60 * 24;\r\n\r\n    await this.redis.setex(key, ttl, memory);\r\n    logger.debug(\"updateWorkingMemory complete\", { key });\r\n  }\r\n\r\n  async saveMessage(message: ConversationMessage): Promise<void> {\r\n    const key = this.getKey(\"msg\", \"chat\", message.chatId);\r\n    logger.debug(`saveMessage: chatId=${message.chatId}`, {\r\n      chatId: message.chatId,\r\n      role: message.role,\r\n      key,\r\n    });\r\n    await this.redis.rpush(key, message);\r\n    await this.redis.ltrim(key, -100, -1); // Keep last 100\r\n\r\n    // Only set TTL if configured\r\n    if (this.messageTtl !== undefined) {\r\n      await this.redis.expire(key, this.messageTtl);\r\n    }\r\n\r\n    logger.debug(`saveMessage complete for ${message.chatId}`, {\r\n      chatId: message.chatId,\r\n    });\r\n  }\r\n\r\n  async getMessages<T = UIMessage>(params: {\r\n    chatId: string;\r\n    userId?: string;\r\n    limit?: number;\r\n  }): Promise<T[]> {\r\n    const key = this.getKey(\"msg\", \"chat\", params.chatId);\r\n    const start = params.limit ? -params.limit : 0;\r\n    const messages = await this.redis.lrange<ConversationMessage>(\r\n      key,\r\n      start,\r\n      -1,\r\n    );\r\n\r\n    // Debug: Check what we actually retrieved\r\n    logger.debug(`getMessages for ${params.chatId}`, {\r\n      chatId: params.chatId,\r\n      key,\r\n      start,\r\n      found: messages?.length || 0,\r\n    });\r\n\r\n    if (!messages || messages.length === 0) return [];\r\n\r\n    // Filter by userId if provided and parse content, then extract content field\r\n    const filtered = messages\r\n      .filter((msg) => {\r\n        // Filter by userId if provided\r\n        if (params.userId) {\r\n          return !msg.userId || msg.userId === params.userId;\r\n        }\r\n        return true;\r\n      })\r\n      .map((msg) => {\r\n        // Always attempt to parse content as JSON\r\n        let content: string | unknown = msg.content;\r\n        try {\r\n          if (typeof msg.content === \"string\") {\r\n            const parsed = JSON.parse(msg.content);\r\n            content = parsed; // Replace content with parsed value\r\n          }\r\n        } catch {\r\n          // If parsing fails, keep original content\r\n        }\r\n        // Return the content field directly (UIMessage format)\r\n        return content as T;\r\n      });\r\n\r\n    if (filtered.length > 0) {\r\n      logger.debug(`Messages retrieved`, {\r\n        count: filtered.length,\r\n      });\r\n    }\r\n\r\n    return filtered;\r\n  }\r\n\r\n  async saveChat(chat: ChatSession): Promise<void> {\r\n    const chatKey = `${this.prefix}chat:${chat.chatId}`;\r\n\r\n    // Get existing chat to preserve title if it exists\r\n    const existing = await this.redis.hgetall<Record<string, unknown>>(chatKey);\r\n\r\n    // Convert Dates to timestamps for Redis storage\r\n    const chatData = {\r\n      ...chat,\r\n      createdAt: chat.createdAt.getTime(),\r\n      updatedAt: chat.updatedAt.getTime(),\r\n      // Preserve existing title if new chat doesn't have one\r\n      title: chat.title || (existing?.title as string | undefined),\r\n    };\r\n\r\n    await this.redis.hset(chatKey, chatData);\r\n    await this.redis.expire(chatKey, 60 * 60 * 24 * 30); // 30 days\r\n\r\n    // Add to global sorted set (for efficient sorting/limiting when no userId)\r\n    const globalChatsKey = `${this.prefix}chats:global`;\r\n    const score = chat.updatedAt.getTime();\r\n    await this.redis.zadd(globalChatsKey, { score, member: chat.chatId });\r\n    await this.redis.expire(globalChatsKey, 60 * 60 * 24 * 30); // 30 days\r\n\r\n    // If userId exists, add to user's chats sorted set\r\n    if (chat.userId) {\r\n      const userChatsKey = `${this.prefix}chats:${chat.userId}`;\r\n      await this.redis.zadd(userChatsKey, { score, member: chat.chatId });\r\n      await this.redis.expire(userChatsKey, 60 * 60 * 24 * 30); // 30 days\r\n    }\r\n  }\r\n\r\n  async getChats(params: {\r\n    userId?: string;\r\n    search?: string;\r\n    limit?: number;\r\n  }): Promise<ChatSession[]> {\r\n    let chats: ChatSession[] = [];\r\n\r\n    if (params.userId) {\r\n      // Get chats for specific user from sorted set (already sorted by updatedAt desc)\r\n      const userChatsKey = `${this.prefix}chats:${params.userId}`;\r\n      // Use limit to fetch most recent chats first (reduce data fetching)\r\n      // If search is needed, we may need to fetch more to find enough matches\r\n      const fetchLimit = params.search ? undefined : params.limit;\r\n      const endIndex = fetchLimit ? fetchLimit - 1 : -1;\r\n      const chatIds = await this.redis.zrange(userChatsKey, 0, endIndex, {\r\n        rev: true, // Most recent first (highest score = most recent)\r\n      });\r\n\r\n      if (chatIds.length === 0) return [];\r\n\r\n      // Fetch all chats in parallel\r\n      const userChats = await Promise.all(\r\n        chatIds.map(async (chatId) => {\r\n          const chatKey = `${this.prefix}chat:${chatId}`;\r\n          const data =\r\n            await this.redis.hgetall<Record<string, unknown>>(chatKey);\r\n          if (!data) return null;\r\n          // Convert timestamps back to Dates\r\n          return {\r\n            ...data,\r\n            createdAt: new Date(data.createdAt as number),\r\n            updatedAt: new Date(data.updatedAt as number),\r\n          } as ChatSession;\r\n        }),\r\n      );\r\n\r\n      chats = userChats.filter((chat): chat is ChatSession => chat !== null);\r\n    } else {\r\n      // Use global sorted set for efficient sorting and limiting\r\n      const globalChatsKey = `${this.prefix}chats:global`;\r\n      // Fetch chat IDs from global sorted set (most recent first)\r\n      // If search is needed, fetch more to find matches (fetch 3x limit if limit provided)\r\n      const fetchLimit =\r\n        params.search && params.limit\r\n          ? params.limit * 3 // Fetch more to account for filtering\r\n          : params.search\r\n            ? undefined // No limit, fetch all for search\r\n            : params.limit; // No search, use exact limit\r\n      const endIndex = fetchLimit ? fetchLimit - 1 : -1;\r\n      const chatIds = await this.redis.zrange(globalChatsKey, 0, endIndex, {\r\n        rev: true, // Most recent first (highest score = most recent)\r\n      });\r\n\r\n      if (chatIds.length === 0) return [];\r\n\r\n      // Fetch all chats in parallel\r\n      const allChats = await Promise.all(\r\n        chatIds.map(async (chatId) => {\r\n          const chatKey = `${this.prefix}chat:${chatId}`;\r\n          const data =\r\n            await this.redis.hgetall<Record<string, unknown>>(chatKey);\r\n          if (!data) return null;\r\n          // Convert timestamps back to Dates\r\n          return {\r\n            ...data,\r\n            createdAt: new Date(data.createdAt as number),\r\n            updatedAt: new Date(data.updatedAt as number),\r\n          } as ChatSession;\r\n        }),\r\n      );\r\n\r\n      chats = allChats.filter((chat): chat is ChatSession => chat !== null);\r\n    }\r\n\r\n    // Filter by search term (title) if provided\r\n    // Note: Redis doesn't support searching hash field values natively.\r\n    // For database-level search, consider using RediSearch module or Drizzle provider.\r\n    if (params.search) {\r\n      const searchLower = params.search.toLowerCase();\r\n      chats = chats.filter((chat) =>\r\n        chat.title?.toLowerCase().includes(searchLower),\r\n      );\r\n    }\r\n\r\n    // Apply limit after filtering (to ensure we respect limit even with search)\r\n    if (params.limit) {\r\n      chats = chats.slice(0, params.limit);\r\n    }\r\n\r\n    return chats;\r\n  }\r\n\r\n  async getChat(chatId: string): Promise<ChatSession | null> {\r\n    const chatKey = `${this.prefix}chat:${chatId}`;\r\n    const data = await this.redis.hgetall<Record<string, unknown>>(chatKey);\r\n    if (!data) return null;\r\n    // Convert timestamps back to Dates\r\n    return {\r\n      ...data,\r\n      createdAt: new Date(data.createdAt as number),\r\n      updatedAt: new Date(data.updatedAt as number),\r\n    } as ChatSession;\r\n  }\r\n\r\n  async updateChatTitle(chatId: string, title: string): Promise<void> {\r\n    const chatKey = `${this.prefix}chat:${chatId}`;\r\n    const data = await this.redis.hgetall<Record<string, unknown>>(chatKey);\r\n\r\n    const updatedAt = Date.now();\r\n\r\n    if (data) {\r\n      // Chat exists, update it\r\n      const chatData = {\r\n        ...data,\r\n        title,\r\n        updatedAt,\r\n      };\r\n      await this.redis.hset(chatKey, chatData);\r\n    } else {\r\n      // Chat doesn't exist yet, create it with the title\r\n      // This can happen if title generation completes before the chat is saved\r\n      const now = Date.now();\r\n      const chatData: ChatSession = {\r\n        chatId,\r\n        title,\r\n        createdAt: new Date(now),\r\n        updatedAt: new Date(updatedAt),\r\n        messageCount: 0,\r\n      };\r\n      await this.saveChat(chatData);\r\n      return; // saveChat already handles sorted sets, so we can return early\r\n    }\r\n\r\n    // Update score in global sorted set\r\n    const globalChatsKey = `${this.prefix}chats:global`;\r\n    await this.redis.zadd(globalChatsKey, {\r\n      score: updatedAt,\r\n      member: chatId,\r\n    });\r\n\r\n    // Update score in user's sorted set if userId exists\r\n    if (data.userId) {\r\n      const userChatsKey = `${this.prefix}chats:${data.userId}`;\r\n      await this.redis.zadd(userChatsKey, {\r\n        score: updatedAt,\r\n        member: chatId,\r\n      });\r\n    }\r\n  }\r\n\r\n  async deleteChat(chatId: string): Promise<void> {\r\n    const chatKey = `${this.prefix}chat:${chatId}`;\r\n    const messageKey = this.getKey(\"msg\", \"chat\", chatId);\r\n\r\n    // Get chat data to find userId before deleting\r\n    const chatData = await this.redis.hgetall<Record<string, unknown>>(chatKey);\r\n    const userId = chatData?.userId as string | undefined;\r\n\r\n    // Delete chat\r\n    await this.redis.del(chatKey);\r\n\r\n    // Delete messages\r\n    await this.redis.del(messageKey);\r\n\r\n    // Remove from global sorted set\r\n    const globalChatsKey = `${this.prefix}chats:global`;\r\n    await this.redis.zrem(globalChatsKey, chatId);\r\n\r\n    // Remove from user's sorted set if userId exists\r\n    if (userId) {\r\n      const userChatsKey = `${this.prefix}chats:${userId}`;\r\n      await this.redis.zrem(userChatsKey, chatId);\r\n    }\r\n\r\n    logger.debug(`Deleted chat ${chatId}`, { chatId, userId });\r\n  }\r\n\r\n  private getKey(\r\n    type: \"wm\" | \"msg\",\r\n    scope: MemoryScope | \"chat\",\r\n    chatId?: string,\r\n    userId?: string,\r\n  ): string {\r\n    const id = scope === \"chat\" ? chatId : userId;\r\n    return `${this.prefix}${type}:${scope}:${id}`;\r\n  }\r\n}\r\n"],"mappings":";AAAA,IAAM,iBAAiB,QAAQ,IAAI,iBAAiB;AAGpD,IAAM,SAAS;EACb,OAAO;EACP,MAAM;EACN,MAAM;EACN,MAAM;EACN,QAAQ;EACR,KAAK;EACL,OAAO;EACP,SAAS;AACX;AAGA,IAAM,YAAY,OAAM,oBAAI,KAAK,GAAE,YAAY,EAAE,MAAM,IAAI,EAAE;AAGtD,SAAS,aAAa,UAAkB;AAC7C,MAAI,CAAC,gBAAgB;AAEnB,WAAO;MACL,OAAO,MAAM;MAAC;MACd,MAAM,MAAM;MAAC;MACb,MAAM,MAAM;MAAC;MACb,OAAO,MAAM;MAAC;IAChB;EACF;AAEA,SAAO;IACL,OAAO,CAAC,SAAiB,SAAe;AACtC,YAAM,KAAK,GAAG,OAAO,IAAI,IAAI,UAAU,CAAC,IAAI,OAAO,KAAK;AACxD,YAAM,QAAQ,GAAG,OAAO,IAAI,QAAQ,OAAO,KAAK;AAChD,YAAM,MAAM,GAAG,OAAO,IAAI,IAAI,QAAQ,IAAI,OAAO,KAAK;AACtD,YAAM,UAAU,OAAO,IAAI,OAAO,IAAI,GAAG,KAAK,UAAU,IAAI,CAAC,GAAG,OAAO,KAAK,KAAK;AACjF,cAAQ,IAAI,GAAG,EAAE,IAAI,KAAK,IAAI,GAAG,IAAI,OAAO,GAAG,OAAO,EAAE;IAC1D;IACA,MAAM,CAAC,SAAiB,SAAe;AACrC,YAAM,KAAK,GAAG,OAAO,IAAI,IAAI,UAAU,CAAC,IAAI,OAAO,KAAK;AACxD,YAAM,QAAQ,GAAG,OAAO,KAAK,OAAO,OAAO,KAAK;AAChD,YAAM,MAAM,GAAG,OAAO,IAAI,IAAI,QAAQ,IAAI,OAAO,KAAK;AACtD,YAAM,UAAU,OAAO,IAAI,OAAO,IAAI,GAAG,KAAK,UAAU,IAAI,CAAC,GAAG,OAAO,KAAK,KAAK;AACjF,cAAQ,IAAI,GAAG,EAAE,IAAI,KAAK,IAAI,GAAG,IAAI,OAAO,GAAG,OAAO,EAAE;IAC1D;IACA,MAAM,CAAC,SAAiB,SAAe;AACrC,YAAM,KAAK,GAAG,OAAO,IAAI,IAAI,UAAU,CAAC,IAAI,OAAO,KAAK;AACxD,YAAM,QAAQ,GAAG,OAAO,MAAM,OAAO,OAAO,KAAK;AACjD,YAAM,MAAM,GAAG,OAAO,IAAI,IAAI,QAAQ,IAAI,OAAO,KAAK;AACtD,YAAM,UAAU,OAAO,IAAI,OAAO,IAAI,GAAG,KAAK,UAAU,IAAI,CAAC,GAAG,OAAO,KAAK,KAAK;AACjF,cAAQ,KAAK,GAAG,EAAE,IAAI,KAAK,IAAI,GAAG,IAAI,OAAO,GAAG,OAAO,EAAE;IAC3D;IACA,OAAO,CAAC,SAAiB,SAAe;AACtC,YAAM,KAAK,GAAG,OAAO,IAAI,IAAI,UAAU,CAAC,IAAI,OAAO,KAAK;AACxD,YAAM,QAAQ,GAAG,OAAO,GAAG,QAAQ,OAAO,KAAK;AAC/C,YAAM,MAAM,GAAG,OAAO,IAAI,IAAI,QAAQ,IAAI,OAAO,KAAK;AACtD,YAAM,UAAU,OAAO,IAAI,OAAO,IAAI,GAAG,KAAK,UAAU,IAAI,CAAC,GAAG,OAAO,KAAK,KAAK;AACjF,cAAQ,MAAM,GAAG,EAAE,IAAI,KAAK,IAAI,GAAG,IAAI,OAAO,GAAG,OAAO,EAAE;IAC5D;EACF;AACF;;;AChDA,IAAM,SAAS,aAAa,SAAS;AAe9B,IAAM,kBAAN,MAAgD;AAAA,EAIrD,YACU,OACR,SACA;AAFQ;AAGR,SAAK,SAAS,SAAS,UAAU;AACjC,SAAK,aAAa,SAAS;AAAA,EAC7B;AAAA,EATiB;AAAA,EACA;AAAA,EAUjB,MAAM,iBAAiB,QAIW;AAChC,UAAM,MAAM,KAAK,OAAO,MAAM,OAAO,OAAO,OAAO,QAAQ,OAAO,MAAM;AACxE,WAAO,MAAM,KAAK,MAAM,IAAmB,GAAG;AAAA,EAChD;AAAA,EAEA,MAAM,oBAAoB,QAKR;AAChB,UAAM,MAAM,KAAK,OAAO,MAAM,OAAO,OAAO,OAAO,QAAQ,OAAO,MAAM;AACxE,WAAO,MAAM,8BAA8B;AAAA,MACzC;AAAA,MACA,OAAO,OAAO;AAAA,MACd,QAAQ,OAAO;AAAA,MACf,QAAQ,OAAO;AAAA,MACf,eAAe,OAAO,QAAQ;AAAA,IAChC,CAAC;AAED,UAAM,SAAwB;AAAA,MAC5B,SAAS,OAAO;AAAA,MAChB,WAAW,oBAAI,KAAK;AAAA,IACtB;AAGA,UAAM,MAAM,OAAO,UAAU,SAAS,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK;AAEpE,UAAM,KAAK,MAAM,MAAM,KAAK,KAAK,MAAM;AACvC,WAAO,MAAM,gCAAgC,EAAE,IAAI,CAAC;AAAA,EACtD;AAAA,EAEA,MAAM,YAAY,SAA6C;AAC7D,UAAM,MAAM,KAAK,OAAO,OAAO,QAAQ,QAAQ,MAAM;AACrD,WAAO,MAAM,uBAAuB,QAAQ,MAAM,IAAI;AAAA,MACpD,QAAQ,QAAQ;AAAA,MAChB,MAAM,QAAQ;AAAA,MACd;AAAA,IACF,CAAC;AACD,UAAM,KAAK,MAAM,MAAM,KAAK,OAAO;AACnC,UAAM,KAAK,MAAM,MAAM,KAAK,MAAM,EAAE;AAGpC,QAAI,KAAK,eAAe,QAAW;AACjC,YAAM,KAAK,MAAM,OAAO,KAAK,KAAK,UAAU;AAAA,IAC9C;AAEA,WAAO,MAAM,4BAA4B,QAAQ,MAAM,IAAI;AAAA,MACzD,QAAQ,QAAQ;AAAA,IAClB,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,YAA2B,QAIhB;AACf,UAAM,MAAM,KAAK,OAAO,OAAO,QAAQ,OAAO,MAAM;AACpD,UAAM,QAAQ,OAAO,QAAQ,CAAC,OAAO,QAAQ;AAC7C,UAAM,WAAW,MAAM,KAAK,MAAM;AAAA,MAChC;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAGA,WAAO,MAAM,mBAAmB,OAAO,MAAM,IAAI;AAAA,MAC/C,QAAQ,OAAO;AAAA,MACf;AAAA,MACA;AAAA,MACA,OAAO,UAAU,UAAU;AAAA,IAC7B,CAAC;AAED,QAAI,CAAC,YAAY,SAAS,WAAW,EAAG,QAAO,CAAC;AAGhD,UAAM,WAAW,SACd,OAAO,CAAC,QAAQ;AAEf,UAAI,OAAO,QAAQ;AACjB,eAAO,CAAC,IAAI,UAAU,IAAI,WAAW,OAAO;AAAA,MAC9C;AACA,aAAO;AAAA,IACT,CAAC,EACA,IAAI,CAAC,QAAQ;AAEZ,UAAI,UAA4B,IAAI;AACpC,UAAI;AACF,YAAI,OAAO,IAAI,YAAY,UAAU;AACnC,gBAAM,SAAS,KAAK,MAAM,IAAI,OAAO;AACrC,oBAAU;AAAA,QACZ;AAAA,MACF,QAAQ;AAAA,MAER;AAEA,aAAO;AAAA,IACT,CAAC;AAEH,QAAI,SAAS,SAAS,GAAG;AACvB,aAAO,MAAM,sBAAsB;AAAA,QACjC,OAAO,SAAS;AAAA,MAClB,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,SAAS,MAAkC;AAC/C,UAAM,UAAU,GAAG,KAAK,MAAM,QAAQ,KAAK,MAAM;AAGjD,UAAM,WAAW,MAAM,KAAK,MAAM,QAAiC,OAAO;AAG1E,UAAM,WAAW;AAAA,MACf,GAAG;AAAA,MACH,WAAW,KAAK,UAAU,QAAQ;AAAA,MAClC,WAAW,KAAK,UAAU,QAAQ;AAAA;AAAA,MAElC,OAAO,KAAK,SAAU,UAAU;AAAA,IAClC;AAEA,UAAM,KAAK,MAAM,KAAK,SAAS,QAAQ;AACvC,UAAM,KAAK,MAAM,OAAO,SAAS,KAAK,KAAK,KAAK,EAAE;AAGlD,UAAM,iBAAiB,GAAG,KAAK,MAAM;AACrC,UAAM,QAAQ,KAAK,UAAU,QAAQ;AACrC,UAAM,KAAK,MAAM,KAAK,gBAAgB,EAAE,OAAO,QAAQ,KAAK,OAAO,CAAC;AACpE,UAAM,KAAK,MAAM,OAAO,gBAAgB,KAAK,KAAK,KAAK,EAAE;AAGzD,QAAI,KAAK,QAAQ;AACf,YAAM,eAAe,GAAG,KAAK,MAAM,SAAS,KAAK,MAAM;AACvD,YAAM,KAAK,MAAM,KAAK,cAAc,EAAE,OAAO,QAAQ,KAAK,OAAO,CAAC;AAClE,YAAM,KAAK,MAAM,OAAO,cAAc,KAAK,KAAK,KAAK,EAAE;AAAA,IACzD;AAAA,EACF;AAAA,EAEA,MAAM,SAAS,QAIY;AACzB,QAAI,QAAuB,CAAC;AAE5B,QAAI,OAAO,QAAQ;AAEjB,YAAM,eAAe,GAAG,KAAK,MAAM,SAAS,OAAO,MAAM;AAGzD,YAAM,aAAa,OAAO,SAAS,SAAY,OAAO;AACtD,YAAM,WAAW,aAAa,aAAa,IAAI;AAC/C,YAAM,UAAU,MAAM,KAAK,MAAM,OAAO,cAAc,GAAG,UAAU;AAAA,QACjE,KAAK;AAAA;AAAA,MACP,CAAC;AAED,UAAI,QAAQ,WAAW,EAAG,QAAO,CAAC;AAGlC,YAAM,YAAY,MAAM,QAAQ;AAAA,QAC9B,QAAQ,IAAI,OAAO,WAAW;AAC5B,gBAAM,UAAU,GAAG,KAAK,MAAM,QAAQ,MAAM;AAC5C,gBAAM,OACJ,MAAM,KAAK,MAAM,QAAiC,OAAO;AAC3D,cAAI,CAAC,KAAM,QAAO;AAElB,iBAAO;AAAA,YACL,GAAG;AAAA,YACH,WAAW,IAAI,KAAK,KAAK,SAAmB;AAAA,YAC5C,WAAW,IAAI,KAAK,KAAK,SAAmB;AAAA,UAC9C;AAAA,QACF,CAAC;AAAA,MACH;AAEA,cAAQ,UAAU,OAAO,CAAC,SAA8B,SAAS,IAAI;AAAA,IACvE,OAAO;AAEL,YAAM,iBAAiB,GAAG,KAAK,MAAM;AAGrC,YAAM,aACJ,OAAO,UAAU,OAAO,QACpB,OAAO,QAAQ,IACf,OAAO,SACL,SACA,OAAO;AACf,YAAM,WAAW,aAAa,aAAa,IAAI;AAC/C,YAAM,UAAU,MAAM,KAAK,MAAM,OAAO,gBAAgB,GAAG,UAAU;AAAA,QACnE,KAAK;AAAA;AAAA,MACP,CAAC;AAED,UAAI,QAAQ,WAAW,EAAG,QAAO,CAAC;AAGlC,YAAM,WAAW,MAAM,QAAQ;AAAA,QAC7B,QAAQ,IAAI,OAAO,WAAW;AAC5B,gBAAM,UAAU,GAAG,KAAK,MAAM,QAAQ,MAAM;AAC5C,gBAAM,OACJ,MAAM,KAAK,MAAM,QAAiC,OAAO;AAC3D,cAAI,CAAC,KAAM,QAAO;AAElB,iBAAO;AAAA,YACL,GAAG;AAAA,YACH,WAAW,IAAI,KAAK,KAAK,SAAmB;AAAA,YAC5C,WAAW,IAAI,KAAK,KAAK,SAAmB;AAAA,UAC9C;AAAA,QACF,CAAC;AAAA,MACH;AAEA,cAAQ,SAAS,OAAO,CAAC,SAA8B,SAAS,IAAI;AAAA,IACtE;AAKA,QAAI,OAAO,QAAQ;AACjB,YAAM,cAAc,OAAO,OAAO,YAAY;AAC9C,cAAQ,MAAM;AAAA,QAAO,CAAC,SACpB,KAAK,OAAO,YAAY,EAAE,SAAS,WAAW;AAAA,MAChD;AAAA,IACF;AAGA,QAAI,OAAO,OAAO;AAChB,cAAQ,MAAM,MAAM,GAAG,OAAO,KAAK;AAAA,IACrC;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,QAAQ,QAA6C;AACzD,UAAM,UAAU,GAAG,KAAK,MAAM,QAAQ,MAAM;AAC5C,UAAM,OAAO,MAAM,KAAK,MAAM,QAAiC,OAAO;AACtE,QAAI,CAAC,KAAM,QAAO;AAElB,WAAO;AAAA,MACL,GAAG;AAAA,MACH,WAAW,IAAI,KAAK,KAAK,SAAmB;AAAA,MAC5C,WAAW,IAAI,KAAK,KAAK,SAAmB;AAAA,IAC9C;AAAA,EACF;AAAA,EAEA,MAAM,gBAAgB,QAAgB,OAA8B;AAClE,UAAM,UAAU,GAAG,KAAK,MAAM,QAAQ,MAAM;AAC5C,UAAM,OAAO,MAAM,KAAK,MAAM,QAAiC,OAAO;AAEtE,UAAM,YAAY,KAAK,IAAI;AAE3B,QAAI,MAAM;AAER,YAAM,WAAW;AAAA,QACf,GAAG;AAAA,QACH;AAAA,QACA;AAAA,MACF;AACA,YAAM,KAAK,MAAM,KAAK,SAAS,QAAQ;AAAA,IACzC,OAAO;AAGL,YAAM,MAAM,KAAK,IAAI;AACrB,YAAM,WAAwB;AAAA,QAC5B;AAAA,QACA;AAAA,QACA,WAAW,IAAI,KAAK,GAAG;AAAA,QACvB,WAAW,IAAI,KAAK,SAAS;AAAA,QAC7B,cAAc;AAAA,MAChB;AACA,YAAM,KAAK,SAAS,QAAQ;AAC5B;AAAA,IACF;AAGA,UAAM,iBAAiB,GAAG,KAAK,MAAM;AACrC,UAAM,KAAK,MAAM,KAAK,gBAAgB;AAAA,MACpC,OAAO;AAAA,MACP,QAAQ;AAAA,IACV,CAAC;AAGD,QAAI,KAAK,QAAQ;AACf,YAAM,eAAe,GAAG,KAAK,MAAM,SAAS,KAAK,MAAM;AACvD,YAAM,KAAK,MAAM,KAAK,cAAc;AAAA,QAClC,OAAO;AAAA,QACP,QAAQ;AAAA,MACV,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EAEA,MAAM,WAAW,QAA+B;AAC9C,UAAM,UAAU,GAAG,KAAK,MAAM,QAAQ,MAAM;AAC5C,UAAM,aAAa,KAAK,OAAO,OAAO,QAAQ,MAAM;AAGpD,UAAM,WAAW,MAAM,KAAK,MAAM,QAAiC,OAAO;AAC1E,UAAM,SAAS,UAAU;AAGzB,UAAM,KAAK,MAAM,IAAI,OAAO;AAG5B,UAAM,KAAK,MAAM,IAAI,UAAU;AAG/B,UAAM,iBAAiB,GAAG,KAAK,MAAM;AACrC,UAAM,KAAK,MAAM,KAAK,gBAAgB,MAAM;AAG5C,QAAI,QAAQ;AACV,YAAM,eAAe,GAAG,KAAK,MAAM,SAAS,MAAM;AAClD,YAAM,KAAK,MAAM,KAAK,cAAc,MAAM;AAAA,IAC5C;AAEA,WAAO,MAAM,gBAAgB,MAAM,IAAI,EAAE,QAAQ,OAAO,CAAC;AAAA,EAC3D;AAAA,EAEQ,OACN,MACA,OACA,QACA,QACQ;AACR,UAAM,KAAK,UAAU,SAAS,SAAS;AACvC,WAAO,GAAG,KAAK,MAAM,GAAG,IAAI,IAAI,KAAK,IAAI,EAAE;AAAA,EAC7C;AACF;","names":[]}