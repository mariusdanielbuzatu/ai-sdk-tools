{"version":3,"sources":["../../src/providers/redis.ts","../../../debug/src/index.ts"],"sourcesContent":["import { createLogger } from \"@ai-sdk-tools/debug\";\r\nimport type { RedisClientType } from \"redis\";\r\nimport type {\r\n  ChatSession,\r\n  ConversationMessage,\r\n  MemoryProvider,\r\n  MemoryScope,\r\n  UIMessage,\r\n  WorkingMemory,\r\n} from \"../types.js\";\r\n\r\nconst logger = createLogger(\"REDIS\");\r\n\r\n/**\r\n * ioredis client interface\r\n */\r\ninterface IORedisClient {\r\n  get(key: string): Promise<string | null>;\r\n  setex(key: string, seconds: number, value: string): Promise<string>;\r\n  rpush(key: string, ...values: string[]): Promise<number>;\r\n  ltrim(key: string, start: number, stop: number): Promise<string>;\r\n  expire(key: string, seconds: number): Promise<number>;\r\n  lrange(key: string, start: number, stop: number): Promise<string[]>;\r\n  hset(key: string, data: Record<string, unknown>): Promise<number>;\r\n  hgetall(key: string): Promise<Record<string, string> | null>;\r\n  zadd(\r\n    key: string,\r\n    ...args: Array<{ score: number; member: string }>\r\n  ): Promise<number>;\r\n  zrange(key: string, start: number, stop: number): Promise<string[]>;\r\n  zrevrange(key: string, start: number, stop: number): Promise<string[]>;\r\n  keys(pattern: string): Promise<string[]>;\r\n  del(key: string): Promise<number>;\r\n  zrem(key: string, member: string): Promise<number>;\r\n}\r\n\r\n/**\r\n * redis package (v4+) client interface\r\n */\r\ninterface RedisPackageClient {\r\n  get(key: string): Promise<string | null>;\r\n  setEx(key: string, seconds: number, value: string): Promise<string>;\r\n  rPush(key: string, ...values: string[]): Promise<number>;\r\n  lTrim(key: string, start: number, stop: number): Promise<string>;\r\n  expire(key: string, seconds: number): Promise<number>;\r\n  lRange(key: string, start: number, stop: number): Promise<string[]>;\r\n  hSet(key: string, data: Record<string, unknown>): Promise<number>;\r\n  hGetAll(key: string): Promise<Record<string, string> | null>;\r\n  zAdd(\r\n    key: string,\r\n    ...args: Array<{ score: number; value: string }>\r\n  ): Promise<number>;\r\n  zRange(key: string, start: number, stop: number): Promise<string[]>;\r\n  zRevRange(key: string, start: number, stop: number): Promise<string[]>;\r\n  keys(pattern: string): Promise<string[]>;\r\n  del(key: string): Promise<number>;\r\n  zRem(key: string, member: string): Promise<number>;\r\n}\r\n\r\n/**\r\n * Supported Redis client types (ioredis or redis package)\r\n */\r\ntype RedisClient = IORedisClient | RedisPackageClient | RedisClientType;\r\n\r\n/**\r\n * Configuration options for RedisProvider\r\n */\r\nexport interface RedisProviderOptions {\r\n  /** Key prefix for all Redis keys (default: \"memory:\") */\r\n  prefix?: string;\r\n  /** TTL in seconds for message lists (default: no expiration) */\r\n  messageTtl?: number;\r\n}\r\n\r\n/**\r\n * Redis provider - standard Redis client (ioredis or redis package)\r\n *\r\n * Supports both `ioredis` and `redis` npm packages for traditional Redis instances.\r\n * Use this provider when you have a self-hosted Redis server or Redis Cloud instance.\r\n *\r\n * @example With ioredis\r\n * ```typescript\r\n * import Redis from \"ioredis\";\r\n * import { RedisProvider } from \"@ai-sdk-tools/memory/redis\";\r\n *\r\n * const redis = new Redis(process.env.REDIS_URL);\r\n * const memory = new RedisProvider(redis);\r\n * ```\r\n *\r\n * @example With redis package and custom options\r\n * ```typescript\r\n * import { createClient } from \"redis\";\r\n * import { RedisProvider } from \"@ai-sdk-tools/memory/redis\";\r\n *\r\n * const redis = createClient({ url: process.env.REDIS_URL });\r\n * await redis.connect();\r\n * const memory = new RedisProvider(redis, {\r\n *   prefix: \"my-app:memory:\",\r\n *   messageTtl: 60 * 60 * 24 * 30, // 30 days (optional, default: no expiration)\r\n * });\r\n * ```\r\n */\r\nexport class RedisProvider implements MemoryProvider {\r\n  private readonly isRedisPackage: boolean;\r\n  private readonly ioredis: IORedisClient | null;\r\n  private readonly redisPkg: RedisPackageClient | null;\r\n  private readonly messageTtl?: number;\r\n  private readonly prefix: string;\r\n\r\n  constructor(redis: RedisClient, options?: RedisProviderOptions) {\r\n    this.prefix = options?.prefix ?? \"memory:\";\r\n    this.messageTtl = options?.messageTtl;\r\n    // Detect which package is being used by checking for camelCase methods\r\n    // redis package uses camelCase (setEx, rPush, etc.)\r\n    // ioredis uses lowercase (setex, rpush, etc.)\r\n    this.isRedisPackage =\r\n      \"setEx\" in redis || \"rPush\" in redis || \"hSet\" in redis;\r\n\r\n    // Store typed references for better type safety\r\n    if (this.isRedisPackage) {\r\n      this.redisPkg = redis as RedisPackageClient;\r\n      this.ioredis = null;\r\n    } else {\r\n      this.ioredis = redis as IORedisClient;\r\n      this.redisPkg = null;\r\n    }\r\n  }\r\n\r\n  // Typed wrapper methods to avoid 'as any' casts\r\n  private async setex(\r\n    key: string,\r\n    seconds: number,\r\n    value: string,\r\n  ): Promise<string> {\r\n    if (this.isRedisPackage && this.redisPkg) {\r\n      return this.redisPkg.setEx(key, seconds, value);\r\n    }\r\n    if (this.ioredis) {\r\n      return this.ioredis.setex(key, seconds, value);\r\n    }\r\n    throw new Error(\"Redis client not properly initialized\");\r\n  }\r\n\r\n  private async rpush(key: string, ...values: string[]): Promise<number> {\r\n    if (this.isRedisPackage && this.redisPkg) {\r\n      return this.redisPkg.rPush(key, ...values);\r\n    }\r\n    if (this.ioredis) {\r\n      return this.ioredis.rpush(key, ...values);\r\n    }\r\n    throw new Error(\"Redis client not properly initialized\");\r\n  }\r\n\r\n  private async ltrim(\r\n    key: string,\r\n    start: number,\r\n    stop: number,\r\n  ): Promise<string> {\r\n    if (this.isRedisPackage && this.redisPkg) {\r\n      return this.redisPkg.lTrim(key, start, stop);\r\n    }\r\n    if (this.ioredis) {\r\n      return this.ioredis.ltrim(key, start, stop);\r\n    }\r\n    throw new Error(\"Redis client not properly initialized\");\r\n  }\r\n\r\n  private async lrange(\r\n    key: string,\r\n    start: number,\r\n    stop: number,\r\n  ): Promise<string[]> {\r\n    if (this.isRedisPackage && this.redisPkg) {\r\n      return this.redisPkg.lRange(key, start, stop);\r\n    }\r\n    if (this.ioredis) {\r\n      return this.ioredis.lrange(key, start, stop);\r\n    }\r\n    throw new Error(\"Redis client not properly initialized\");\r\n  }\r\n\r\n  private async hset(\r\n    key: string,\r\n    data: Record<string, unknown>,\r\n  ): Promise<number> {\r\n    if (this.isRedisPackage && this.redisPkg) {\r\n      return this.redisPkg.hSet(key, data);\r\n    }\r\n    if (this.ioredis) {\r\n      return this.ioredis.hset(key, data);\r\n    }\r\n    throw new Error(\"Redis client not properly initialized\");\r\n  }\r\n\r\n  private async hgetall(key: string): Promise<Record<string, string> | null> {\r\n    if (this.isRedisPackage && this.redisPkg) {\r\n      return this.redisPkg.hGetAll(key);\r\n    }\r\n    if (this.ioredis) {\r\n      return this.ioredis.hgetall(key);\r\n    }\r\n    throw new Error(\"Redis client not properly initialized\");\r\n  }\r\n\r\n  private async zadd(\r\n    key: string,\r\n    score: number,\r\n    member: string,\r\n  ): Promise<number> {\r\n    if (this.isRedisPackage && this.redisPkg) {\r\n      return this.redisPkg.zAdd(key, { score, value: member });\r\n    }\r\n    if (this.ioredis) {\r\n      return this.ioredis.zadd(key, { score, member });\r\n    }\r\n    throw new Error(\"Redis client not properly initialized\");\r\n  }\r\n\r\n  private async zrange(\r\n    key: string,\r\n    start: number,\r\n    stop: number,\r\n  ): Promise<string[]> {\r\n    if (this.isRedisPackage && this.redisPkg) {\r\n      return this.redisPkg.zRange(key, start, stop);\r\n    }\r\n    if (this.ioredis) {\r\n      return this.ioredis.zrange(key, start, stop);\r\n    }\r\n    throw new Error(\"Redis client not properly initialized\");\r\n  }\r\n\r\n  private async zrevrange(\r\n    key: string,\r\n    start: number,\r\n    stop: number,\r\n  ): Promise<string[]> {\r\n    if (this.ioredis) {\r\n      // ioredis has zrevrange method\r\n      return this.ioredis.zrevrange(key, start, stop);\r\n    }\r\n    if (this.isRedisPackage && this.redisPkg) {\r\n      // For redis package, use negative indices with zRange to get items from the end\r\n      // zRange returns items in ascending order, so we get from the end and reverse\r\n      if (stop === -1) {\r\n        // Get all items and reverse to get most recent first\r\n        const result = await this.redisPkg.zRange(key, 0, -1);\r\n        return result.reverse();\r\n      }\r\n      // Calculate how many items we need from the end\r\n      const count = stop - start + 1;\r\n      // Get last N items using negative indices (from end of sorted set)\r\n      // Negative indices: -1 is the last item, -count is the count-th item from the end\r\n      const result = await this.redisPkg.zRange(key, -count, -1);\r\n      // Reverse to get most recent first (highest score = most recent)\r\n      return result.reverse();\r\n    }\r\n    throw new Error(\"Redis client not properly initialized\");\r\n  }\r\n\r\n  private async get(key: string): Promise<string | null> {\r\n    if (this.isRedisPackage && this.redisPkg) {\r\n      return this.redisPkg.get(key);\r\n    }\r\n    if (this.ioredis) {\r\n      return this.ioredis.get(key);\r\n    }\r\n    throw new Error(\"Redis client not properly initialized\");\r\n  }\r\n\r\n  private async expire(key: string, seconds: number): Promise<number> {\r\n    if (this.isRedisPackage && this.redisPkg) {\r\n      return this.redisPkg.expire(key, seconds);\r\n    }\r\n    if (this.ioredis) {\r\n      return this.ioredis.expire(key, seconds);\r\n    }\r\n    throw new Error(\"Redis client not properly initialized\");\r\n  }\r\n\r\n  private async keys(pattern: string): Promise<string[]> {\r\n    if (this.isRedisPackage && this.redisPkg) {\r\n      return this.redisPkg.keys(pattern);\r\n    }\r\n    if (this.ioredis) {\r\n      return this.ioredis.keys(pattern);\r\n    }\r\n    throw new Error(\"Redis client not properly initialized\");\r\n  }\r\n\r\n  private async del(key: string): Promise<number> {\r\n    if (this.isRedisPackage && this.redisPkg) {\r\n      return this.redisPkg.del(key);\r\n    }\r\n    if (this.ioredis) {\r\n      return this.ioredis.del(key);\r\n    }\r\n    throw new Error(\"Redis client not properly initialized\");\r\n  }\r\n\r\n  private async zrem(key: string, member: string): Promise<number> {\r\n    if (this.isRedisPackage && this.redisPkg) {\r\n      return this.redisPkg.zRem(key, member);\r\n    }\r\n    if (this.ioredis) {\r\n      return this.ioredis.zrem(key, member);\r\n    }\r\n    throw new Error(\"Redis client not properly initialized\");\r\n  }\r\n\r\n  async getWorkingMemory(params: {\r\n    chatId?: string;\r\n    userId?: string;\r\n    scope: MemoryScope;\r\n  }): Promise<WorkingMemory | null> {\r\n    const key = this.getKey(\"wm\", params.scope, params.chatId, params.userId);\r\n    const value = await this.get(key);\r\n    if (!value) return null;\r\n\r\n    try {\r\n      const parsed = JSON.parse(value) as WorkingMemory;\r\n      // Convert updatedAt timestamp to Date\r\n      return {\r\n        ...parsed,\r\n        updatedAt: new Date(parsed.updatedAt),\r\n      };\r\n    } catch (error) {\r\n      logger.error(\"Failed to parse working memory\", { key, error });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async updateWorkingMemory(params: {\r\n    chatId?: string;\r\n    userId?: string;\r\n    scope: MemoryScope;\r\n    content: string;\r\n  }): Promise<void> {\r\n    const key = this.getKey(\"wm\", params.scope, params.chatId, params.userId);\r\n    logger.debug(\"updateWorkingMemory called\", {\r\n      key,\r\n      scope: params.scope,\r\n      chatId: params.chatId,\r\n      userId: params.userId,\r\n      contentLength: params.content.length,\r\n    });\r\n\r\n    const memory: WorkingMemory = {\r\n      content: params.content,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    // TTL: 30 days for user, 24h for chat\r\n    const ttl = params.scope === \"user\" ? 60 * 60 * 24 * 30 : 60 * 60 * 24;\r\n    const value = JSON.stringify(memory);\r\n\r\n    await this.setex(key, ttl, value);\r\n\r\n    logger.debug(\"updateWorkingMemory complete\", { key });\r\n  }\r\n\r\n  async saveMessage(message: ConversationMessage): Promise<void> {\r\n    const key = this.getKey(\"msg\", \"chat\", message.chatId);\r\n    logger.debug(`saveMessage: chatId=${message.chatId}`, {\r\n      chatId: message.chatId,\r\n      role: message.role,\r\n      key,\r\n    });\r\n\r\n    // Serialize message to JSON string\r\n    const serialized = JSON.stringify({\r\n      ...message,\r\n      timestamp: message.timestamp.getTime(),\r\n    });\r\n\r\n    await this.rpush(key, serialized);\r\n    await this.ltrim(key, -100, -1); // Keep last 100\r\n\r\n    // Only set TTL if configured\r\n    if (this.messageTtl !== undefined) {\r\n      await this.expire(key, this.messageTtl);\r\n    }\r\n\r\n    logger.debug(`saveMessage complete for ${message.chatId}`, {\r\n      chatId: message.chatId,\r\n    });\r\n  }\r\n\r\n  async getMessages<T = UIMessage>(params: {\r\n    chatId: string;\r\n    userId?: string;\r\n    limit?: number;\r\n  }): Promise<T[]> {\r\n    const key = this.getKey(\"msg\", \"chat\", params.chatId);\r\n    const start = params.limit ? -params.limit : 0;\r\n\r\n    const rawMessages = await this.lrange(key, start, -1);\r\n\r\n    logger.debug(`getMessages for ${params.chatId}`, {\r\n      chatId: params.chatId,\r\n      key,\r\n      start,\r\n      found: rawMessages?.length || 0,\r\n    });\r\n\r\n    if (!rawMessages || rawMessages.length === 0) return [];\r\n\r\n    // Parse each message from JSON and extract content field\r\n    const messages: T[] = [];\r\n    for (const raw of rawMessages) {\r\n      try {\r\n        const parsed = JSON.parse(raw);\r\n        const message: ConversationMessage = {\r\n          ...parsed,\r\n          timestamp: new Date(parsed.timestamp),\r\n        };\r\n\r\n        // Filter by userId if provided\r\n        if (params.userId) {\r\n          if (message.userId && message.userId !== params.userId) {\r\n            continue; // Skip messages that don't match userId\r\n          }\r\n        }\r\n\r\n        // Always attempt to parse content as JSON\r\n        let content: string | unknown = message.content;\r\n        try {\r\n          if (typeof message.content === \"string\") {\r\n            const parsedContent = JSON.parse(message.content);\r\n            content = parsedContent; // Replace content with parsed value\r\n          }\r\n        } catch {\r\n          // If parsing fails, keep original content\r\n        }\r\n\r\n        // Return the content field directly (UIMessage format)\r\n        messages.push(content as T);\r\n      } catch (error) {\r\n        logger.error(\"Failed to parse message\", { error, raw });\r\n      }\r\n    }\r\n\r\n    if (messages.length > 0) {\r\n      logger.debug(`Messages retrieved`, {\r\n        count: messages.length,\r\n      });\r\n    }\r\n\r\n    return messages;\r\n  }\r\n\r\n  async saveChat(chat: ChatSession): Promise<void> {\r\n    const chatKey = `${this.prefix}chat:${chat.chatId}`;\r\n\r\n    // Get existing chat to preserve title if it exists\r\n    const existing = await this.hgetall(chatKey);\r\n\r\n    // Convert Dates to timestamps for Redis storage\r\n    const chatData: Record<string, string> = {\r\n      chatId: chat.chatId,\r\n      userId: chat.userId || \"\",\r\n      // Preserve existing title if new chat doesn't have one\r\n      title: chat.title || existing?.title || \"\",\r\n      createdAt: chat.createdAt.getTime().toString(),\r\n      updatedAt: chat.updatedAt.getTime().toString(),\r\n      messageCount: chat.messageCount.toString(),\r\n    };\r\n\r\n    // Remove empty string values\r\n    Object.keys(chatData).forEach((key) => {\r\n      if (chatData[key] === \"\") {\r\n        delete chatData[key];\r\n      }\r\n    });\r\n\r\n    await this.hset(chatKey, chatData);\r\n    await this.expire(chatKey, 60 * 60 * 24 * 30); // 30 days\r\n\r\n    // Add to global sorted set (for efficient sorting/limiting when no userId)\r\n    const globalChatsKey = `${this.prefix}chats:global`;\r\n    const score = chat.updatedAt.getTime();\r\n    await this.zadd(globalChatsKey, score, chat.chatId);\r\n    await this.expire(globalChatsKey, 60 * 60 * 24 * 30); // 30 days\r\n\r\n    // If userId exists, add to user's chats sorted set\r\n    if (chat.userId) {\r\n      const userChatsKey = `${this.prefix}chats:${chat.userId}`;\r\n      await this.zadd(userChatsKey, score, chat.chatId);\r\n      await this.expire(userChatsKey, 60 * 60 * 24 * 30); // 30 days\r\n    }\r\n  }\r\n\r\n  async getChats(params: {\r\n    userId?: string;\r\n    search?: string;\r\n    limit?: number;\r\n  }): Promise<ChatSession[]> {\r\n    let chats: ChatSession[] = [];\r\n\r\n    if (params.userId) {\r\n      // Get chats for specific user from sorted set (already sorted by updatedAt desc)\r\n      const userChatsKey = `${this.prefix}chats:${params.userId}`;\r\n      // Use limit to fetch most recent chats first (reduce data fetching)\r\n      // If search is needed, we may need to fetch more to find enough matches\r\n      const fetchLimit = params.search ? undefined : params.limit;\r\n      const endIndex = fetchLimit ? fetchLimit - 1 : -1;\r\n      // Use zrevrange to get most recent chats first (highest score = most recent)\r\n      const chatIds = await this.zrevrange(userChatsKey, 0, endIndex);\r\n\r\n      if (chatIds.length === 0) return [];\r\n\r\n      // Fetch all chats in parallel\r\n      const userChats = await Promise.all(\r\n        chatIds.map(async (chatId) => {\r\n          const chatKey = `${this.prefix}chat:${chatId}`;\r\n          const data = await this.hgetall(chatKey);\r\n          if (!data || Object.keys(data).length === 0) return null;\r\n          // Convert timestamps back to Dates\r\n          return {\r\n            ...data,\r\n            chatId: data.chatId || chatId,\r\n            userId: data.userId || undefined,\r\n            title: data.title || undefined,\r\n            createdAt: new Date(parseInt(data.createdAt, 10)),\r\n            updatedAt: new Date(parseInt(data.updatedAt, 10)),\r\n            messageCount: parseInt(data.messageCount || \"0\", 10),\r\n          } as ChatSession;\r\n        }),\r\n      );\r\n\r\n      chats = userChats.filter(\r\n        (chat: ChatSession | null): chat is ChatSession => chat !== null,\r\n      );\r\n    } else {\r\n      // Use global sorted set for efficient sorting and limiting\r\n      const globalChatsKey = `${this.prefix}chats:global`;\r\n      // Fetch chat IDs from global sorted set (most recent first)\r\n      // If search is needed, fetch more to find matches (fetch 3x limit if limit provided)\r\n      const fetchLimit =\r\n        params.search && params.limit\r\n          ? params.limit * 3 // Fetch more to account for filtering\r\n          : params.search\r\n            ? undefined // No limit, fetch all for search\r\n            : params.limit; // No search, use exact limit\r\n      const endIndex = fetchLimit ? fetchLimit - 1 : -1;\r\n      // Use zrevrange to get most recent chats first (highest score = most recent)\r\n      const chatIds = await this.zrevrange(globalChatsKey, 0, endIndex);\r\n\r\n      if (chatIds.length === 0) return [];\r\n\r\n      // Fetch all chats in parallel\r\n      const allChats = await Promise.all(\r\n        chatIds.map(async (chatId) => {\r\n          const chatKey = `${this.prefix}chat:${chatId}`;\r\n          const data = await this.hgetall(chatKey);\r\n          if (!data || Object.keys(data).length === 0) return null;\r\n          // Convert timestamps back to Dates\r\n          return {\r\n            ...data,\r\n            chatId: data.chatId || chatId,\r\n            userId: data.userId || undefined,\r\n            title: data.title || undefined,\r\n            createdAt: new Date(parseInt(data.createdAt, 10)),\r\n            updatedAt: new Date(parseInt(data.updatedAt, 10)),\r\n            messageCount: parseInt(data.messageCount || \"0\", 10),\r\n          } as ChatSession;\r\n        }),\r\n      );\r\n\r\n      chats = allChats.filter((chat): chat is ChatSession => chat !== null);\r\n    }\r\n\r\n    // Filter by search term (title) if provided\r\n    // Note: Redis doesn't support searching hash field values natively.\r\n    // For database-level search, consider using RediSearch module or Drizzle provider.\r\n    if (params.search) {\r\n      const searchLower = params.search.toLowerCase();\r\n      chats = chats.filter((chat) =>\r\n        chat.title?.toLowerCase().includes(searchLower),\r\n      );\r\n    }\r\n\r\n    // Apply limit after filtering (to ensure we respect limit even with search)\r\n    if (params.limit) {\r\n      chats = chats.slice(0, params.limit);\r\n    }\r\n\r\n    return chats;\r\n  }\r\n\r\n  async getChat(chatId: string): Promise<ChatSession | null> {\r\n    const chatKey = `${this.prefix}chat:${chatId}`;\r\n    const data = await this.hgetall(chatKey);\r\n    if (!data || Object.keys(data).length === 0) return null;\r\n    // Convert timestamps back to Dates\r\n    return {\r\n      ...data,\r\n      chatId: data.chatId || chatId,\r\n      userId: data.userId || undefined,\r\n      title: data.title || undefined,\r\n      createdAt: new Date(parseInt(data.createdAt, 10)),\r\n      updatedAt: new Date(parseInt(data.updatedAt, 10)),\r\n      messageCount: parseInt(data.messageCount || \"0\", 10),\r\n    } as ChatSession;\r\n  }\r\n\r\n  async updateChatTitle(chatId: string, title: string): Promise<void> {\r\n    const chatKey = `${this.prefix}chat:${chatId}`;\r\n    const data = await this.hgetall(chatKey);\r\n\r\n    const updatedAt = Date.now();\r\n\r\n    if (data && Object.keys(data).length > 0) {\r\n      // Chat exists, update it\r\n      const chatData: Record<string, string> = {\r\n        ...data,\r\n        title,\r\n        updatedAt: updatedAt.toString(),\r\n      };\r\n\r\n      await this.hset(chatKey, chatData);\r\n\r\n      // Update score in global sorted set\r\n      const globalChatsKey = `${this.prefix}chats:global`;\r\n      await this.zadd(globalChatsKey, updatedAt, chatId);\r\n\r\n      // Update score in user's sorted set if userId exists\r\n      if (data.userId) {\r\n        const userChatsKey = `${this.prefix}chats:${data.userId}`;\r\n        await this.zadd(userChatsKey, updatedAt, chatId);\r\n      }\r\n    } else {\r\n      // Chat doesn't exist yet, create it with the title\r\n      // This can happen if title generation completes before the chat is saved\r\n      const now = Date.now();\r\n      const chatData: ChatSession = {\r\n        chatId,\r\n        title,\r\n        createdAt: new Date(now),\r\n        updatedAt: new Date(updatedAt),\r\n        messageCount: 0,\r\n      };\r\n      await this.saveChat(chatData);\r\n      return; // saveChat already handles sorted sets, so we can return early\r\n    }\r\n  }\r\n\r\n  async deleteChat(chatId: string): Promise<void> {\r\n    const chatKey = `${this.prefix}chat:${chatId}`;\r\n    const messageKey = this.getKey(\"msg\", \"chat\", chatId);\r\n\r\n    // Get chat data to find userId before deleting\r\n    const chatData = await this.hgetall(chatKey);\r\n    const userId = chatData?.userId;\r\n\r\n    // Delete chat\r\n    await this.del(chatKey);\r\n\r\n    // Delete messages\r\n    await this.del(messageKey);\r\n\r\n    // Remove from global sorted set\r\n    const globalChatsKey = `${this.prefix}chats:global`;\r\n    await this.zrem(globalChatsKey, chatId);\r\n\r\n    // Remove from user's sorted set if userId exists\r\n    if (userId) {\r\n      const userChatsKey = `${this.prefix}chats:${userId}`;\r\n      await this.zrem(userChatsKey, chatId);\r\n    }\r\n\r\n    logger.debug(`Deleted chat ${chatId}`, { chatId, userId });\r\n  }\r\n\r\n  private getKey(\r\n    type: \"wm\" | \"msg\",\r\n    scope: MemoryScope | \"chat\",\r\n    chatId?: string,\r\n    userId?: string,\r\n  ): string {\r\n    const id = scope === \"chat\" ? chatId : userId;\r\n    return `${this.prefix}${type}:${scope}:${id}`;\r\n  }\r\n}\r\n","const isDebugEnabled = process.env.DEBUG_AGENTS === 'true';\r\n\r\n// ANSI color codes for terminal output\r\nconst colors = {\r\n  reset: '\\x1b[0m',\r\n  gray: '\\x1b[90m',\r\n  blue: '\\x1b[34m',\r\n  cyan: '\\x1b[36m',\r\n  yellow: '\\x1b[33m',\r\n  red: '\\x1b[31m',\r\n  green: '\\x1b[32m',\r\n  magenta: '\\x1b[35m',\r\n};\r\n\r\n// Format timestamp\r\nconst timestamp = () => new Date().toISOString().slice(11, 23);\r\n\r\n// Create category-scoped logger with clean API\r\nexport function createLogger(category: string) {\r\n  if (!isDebugEnabled) {\r\n    // Return no-op functions when debug is disabled\r\n    return {\r\n      debug: () => {},\r\n      info: () => {},\r\n      warn: () => {},\r\n      error: () => {},\r\n    };\r\n  }\r\n\r\n  return {\r\n    debug: (message: string, data?: any) => {\r\n      const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n      const level = `${colors.blue}DEBUG${colors.reset}`;\r\n      const cat = `${colors.cyan}[${category}]${colors.reset}`;\r\n      const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n      console.log(`${ts} ${level} ${cat} ${message}${dataStr}`);\r\n    },\r\n    info: (message: string, data?: any) => {\r\n      const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n      const level = `${colors.green}INFO${colors.reset}`;\r\n      const cat = `${colors.cyan}[${category}]${colors.reset}`;\r\n      const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n      console.log(`${ts} ${level} ${cat} ${message}${dataStr}`);\r\n    },\r\n    warn: (message: string, data?: any) => {\r\n      const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n      const level = `${colors.yellow}WARN${colors.reset}`;\r\n      const cat = `${colors.cyan}[${category}]${colors.reset}`;\r\n      const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n      console.warn(`${ts} ${level} ${cat} ${message}${dataStr}`);\r\n    },\r\n    error: (message: string, data?: any) => {\r\n      const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n      const level = `${colors.red}ERROR${colors.reset}`;\r\n      const cat = `${colors.cyan}[${category}]${colors.reset}`;\r\n      const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n      console.error(`${ts} ${level} ${cat} ${message}${dataStr}`);\r\n    },\r\n  };\r\n}\r\n\r\n// Export a base logger for backward compatibility\r\nexport const logger = {\r\n  debug: (message: string, data?: any) => {\r\n    if (!isDebugEnabled) return;\r\n    const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n    const level = `${colors.blue}DEBUG${colors.reset}`;\r\n    const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n    console.log(`${ts} ${level} ${message}${dataStr}`);\r\n  },\r\n  info: (message: string, data?: any) => {\r\n    if (!isDebugEnabled) return;\r\n    const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n    const level = `${colors.green}INFO${colors.reset}`;\r\n    const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n    console.log(`${ts} ${level} ${message}${dataStr}`);\r\n  },\r\n  warn: (message: string, data?: any) => {\r\n    if (!isDebugEnabled) return;\r\n    const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n    const level = `${colors.yellow}WARN${colors.reset}`;\r\n    const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n    console.warn(`${ts} ${level} ${message}${dataStr}`);\r\n  },\r\n  error: (message: string, data?: any) => {\r\n    if (!isDebugEnabled) return;\r\n    const ts = `${colors.gray}[${timestamp()}]${colors.reset}`;\r\n    const level = `${colors.red}ERROR${colors.reset}`;\r\n    const dataStr = data ? ` ${colors.gray}${JSON.stringify(data)}${colors.reset}` : '';\r\n    console.error(`${ts} ${level} ${message}${dataStr}`);\r\n  },\r\n};\r\n\r\n"],"mappings":"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","names":["result"]}