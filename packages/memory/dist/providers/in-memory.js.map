{"version":3,"sources":["../../src/providers/in-memory.ts"],"sourcesContent":["import type {\r\n  ChatSession,\r\n  ConversationMessage,\r\n  MemoryProvider,\r\n  MemoryScope,\r\n  UIMessage,\r\n  WorkingMemory,\r\n} from \"../types.js\";\r\n\r\n/**\r\n * In-memory provider - perfect for development\r\n */\r\nexport class InMemoryProvider implements MemoryProvider {\r\n  private workingMemory = new Map<string, WorkingMemory>();\r\n  private messages = new Map<string, ConversationMessage[]>();\r\n  private chats = new Map<string, ChatSession>();\r\n\r\n  async getWorkingMemory(params: {\r\n    chatId?: string;\r\n    userId?: string;\r\n    scope: MemoryScope;\r\n  }): Promise<WorkingMemory | null> {\r\n    const key = this.getKey(params.scope, params.chatId, params.userId);\r\n    return this.workingMemory.get(key) || null;\r\n  }\r\n\r\n  async updateWorkingMemory(params: {\r\n    chatId?: string;\r\n    userId?: string;\r\n    scope: MemoryScope;\r\n    content: string;\r\n  }): Promise<void> {\r\n    const key = this.getKey(params.scope, params.chatId, params.userId);\r\n    this.workingMemory.set(key, {\r\n      content: params.content,\r\n      updatedAt: new Date(),\r\n    });\r\n  }\r\n\r\n  async saveMessage(message: ConversationMessage): Promise<void> {\r\n    const msgs = this.messages.get(message.chatId) || [];\r\n    msgs.push(message);\r\n    this.messages.set(message.chatId, msgs);\r\n  }\r\n\r\n  async getMessages<T = UIMessage>(params: {\r\n    chatId: string;\r\n    userId?: string;\r\n    limit?: number;\r\n  }): Promise<T[]> {\r\n    let msgs = this.messages.get(params.chatId) || [];\r\n\r\n    // Filter by userId if provided\r\n    if (params.userId) {\r\n      msgs = msgs.filter((msg) => !msg.userId || msg.userId === params.userId);\r\n    }\r\n\r\n    // Apply limit\r\n    const limited = params.limit ? msgs.slice(-params.limit) : msgs;\r\n\r\n    // Always attempt to parse content as JSON, then extract content field\r\n    return limited.map((msg) => {\r\n      let content: string | unknown = msg.content;\r\n      try {\r\n        // Try to parse as JSON (only if content is a string)\r\n        if (typeof msg.content === \"string\") {\r\n          const parsed = JSON.parse(msg.content);\r\n          content = parsed; // Replace content with parsed value\r\n        }\r\n      } catch {\r\n        // If parsing fails, keep original content string\r\n      }\r\n      // Return the content field directly (UIMessage format)\r\n      return content as T;\r\n    });\r\n  }\r\n\r\n  async saveChat(chat: ChatSession): Promise<void> {\r\n    const existing = this.chats.get(chat.chatId);\r\n    // Preserve existing title if new chat doesn't have one\r\n    const title = chat.title || existing?.title;\r\n    this.chats.set(chat.chatId, {\r\n      ...chat,\r\n      title,\r\n    });\r\n  }\r\n\r\n  async getChats(params: {\r\n    userId?: string;\r\n    search?: string;\r\n    limit?: number;\r\n  }): Promise<ChatSession[]> {\r\n    let allChats = Array.from(this.chats.values());\r\n\r\n    // Filter by userId if provided\r\n    if (params.userId) {\r\n      allChats = allChats.filter((chat) => chat.userId === params.userId);\r\n    }\r\n\r\n    // Sort by updatedAt descending (most recent first)\r\n    allChats.sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime());\r\n\r\n    // Filter by search term (title) if provided\r\n    if (params.search) {\r\n      const searchLower = params.search.toLowerCase();\r\n      allChats = allChats.filter((chat) =>\r\n        chat.title?.toLowerCase().includes(searchLower),\r\n      );\r\n    }\r\n\r\n    // Apply limit\r\n    if (params.limit) {\r\n      allChats = allChats.slice(0, params.limit);\r\n    }\r\n\r\n    return allChats;\r\n  }\r\n\r\n  async getChat(chatId: string): Promise<ChatSession | null> {\r\n    return this.chats.get(chatId) || null;\r\n  }\r\n\r\n  async updateChatTitle(chatId: string, title: string): Promise<void> {\r\n    const chat = this.chats.get(chatId);\r\n    if (chat) {\r\n      chat.title = title;\r\n      chat.updatedAt = new Date();\r\n      this.chats.set(chatId, chat);\r\n    } else {\r\n      // Chat doesn't exist yet, create it with the title\r\n      // This can happen if title generation completes before the chat is saved\r\n      const now = new Date();\r\n      this.chats.set(chatId, {\r\n        chatId,\r\n        title,\r\n        createdAt: now,\r\n        updatedAt: now,\r\n        messageCount: 0,\r\n      });\r\n    }\r\n  }\r\n\r\n  async deleteChat(chatId: string): Promise<void> {\r\n    // Delete chat\r\n    this.chats.delete(chatId);\r\n    // Delete associated messages\r\n    this.messages.delete(chatId);\r\n  }\r\n\r\n  private getKey(scope: MemoryScope, chatId?: string, userId?: string): string {\r\n    const id = scope === \"chat\" ? chatId : userId;\r\n    return `${scope}:${id}`;\r\n  }\r\n}\r\n"],"mappings":"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","names":[]}