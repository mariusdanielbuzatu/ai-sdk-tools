{"version":3,"sources":["../src/merge.ts","../src/utils.ts","../src/providers/gemini.ts","../src/providers/mistral.ts","../src/providers/ocr-fallback.ts","../src/quality.ts","../src/schemas.ts","../src/types.ts","../src/ocr.ts"],"names":["generateObject","z"],"mappings":"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","file":"index.cjs","sourcesContent":["/**\r\n * Merge results from primary and fallback attempts\r\n * Prefers primary results, supplements with fallback when primary is missing\r\n */\r\nexport function mergeResults<T extends Record<string, unknown>>(\r\n  primary: T,\r\n  fallback: T,\r\n): T {\r\n  const merged = { ...primary };\r\n\r\n  // Merge each field, preferring primary but using fallback if primary is missing/null/empty\r\n  for (const key in fallback) {\r\n    const primaryValue = merged[key];\r\n    const fallbackValue = fallback[key];\r\n\r\n    // Use fallback if primary is missing, null, empty string, or 0\r\n    if (\r\n      primaryValue === undefined ||\r\n      primaryValue === null ||\r\n      primaryValue === \"\" ||\r\n      (typeof primaryValue === \"number\" && primaryValue === 0)\r\n    ) {\r\n      if (fallbackValue !== undefined && fallbackValue !== null) {\r\n        merged[key] = fallbackValue;\r\n      }\r\n    }\r\n\r\n    // Special handling for arrays - merge if primary is empty\r\n    if (Array.isArray(primaryValue) && primaryValue.length === 0) {\r\n      if (Array.isArray(fallbackValue) && fallbackValue.length > 0) {\r\n        merged[key] = fallbackValue as T[Extract<keyof T, string>];\r\n      }\r\n    }\r\n  }\r\n\r\n  return merged;\r\n}\r\n","import type { OCRInput } from \"./types.js\";\r\n\r\nexport interface RetryOptions {\r\n  retries?: number;\r\n  timeout?: number;\r\n  delay?: number;\r\n}\r\n\r\n/**\r\n * Convert various input formats to a format suitable for AI SDK\r\n */\r\nexport async function normalizeInput(\r\n  input: OCRInput,\r\n): Promise<{ data: string; mediaType: string }> {\r\n  // Handle Buffer\r\n  if (Buffer.isBuffer(input)) {\r\n    const base64 = input.toString(\"base64\");\r\n    // Try to detect media type from buffer\r\n    const mediaType = detectMediaType(input);\r\n    return { data: base64, mediaType };\r\n  }\r\n\r\n  // Handle File object\r\n  if (input instanceof File) {\r\n    const arrayBuffer = await input.arrayBuffer();\r\n    const buffer = Buffer.from(arrayBuffer);\r\n    const base64 = buffer.toString(\"base64\");\r\n    const mediaType = input.type || detectMediaType(buffer);\r\n    return { data: base64, mediaType };\r\n  }\r\n\r\n  // Handle string (base64, file path, or URL)\r\n  if (typeof input === \"string\") {\r\n    // Check if it's a data URI\r\n    if (input.startsWith(\"data:\")) {\r\n      const [header, data] = input.split(\",\");\r\n      const mediaType = header.match(/data:([^;]+)/)?.[1] || \"image/png\";\r\n      return { data, mediaType };\r\n    }\r\n\r\n    // Check if it's a URL\r\n    if (input.startsWith(\"http://\") || input.startsWith(\"https://\")) {\r\n      const response = await fetch(input);\r\n      const arrayBuffer = await response.arrayBuffer();\r\n      const buffer = Buffer.from(arrayBuffer);\r\n      const base64 = buffer.toString(\"base64\");\r\n      const contentType = response.headers.get(\"content-type\") || \"image/png\";\r\n      return { data: base64, mediaType: contentType };\r\n    }\r\n\r\n    // Check if it's a file path (Node.js only)\r\n    if (typeof process !== \"undefined\" && process.versions?.node) {\r\n      try {\r\n        const fs = await import(\"node:fs/promises\");\r\n        const path = await import(\"node:path\");\r\n        try {\r\n          await fs.access(input);\r\n          const buffer = await fs.readFile(input);\r\n          const base64 = buffer.toString(\"base64\");\r\n          const ext = path.extname(input).toLowerCase();\r\n          const mediaType = getMediaTypeFromExtension(ext);\r\n          return { data: base64, mediaType };\r\n        } catch {\r\n          // File doesn't exist, continue to treat as base64\r\n        }\r\n      } catch {\r\n        // fs/promises not available, continue to treat as base64\r\n      }\r\n    }\r\n\r\n    // Assume it's base64\r\n    return { data: input, mediaType: \"image/png\" };\r\n  }\r\n\r\n  throw new Error(\"Unsupported input format\");\r\n}\r\n\r\n/**\r\n * Detect media type from buffer content\r\n */\r\nfunction detectMediaType(buffer: Buffer): string {\r\n  // Check for PDF\r\n  if (\r\n    buffer[0] === 0x25 &&\r\n    buffer[1] === 0x50 &&\r\n    buffer[2] === 0x44 &&\r\n    buffer[3] === 0x46\r\n  ) {\r\n    return \"application/pdf\";\r\n  }\r\n\r\n  // Check for PNG\r\n  if (\r\n    buffer[0] === 0x89 &&\r\n    buffer[1] === 0x50 &&\r\n    buffer[2] === 0x4e &&\r\n    buffer[3] === 0x47\r\n  ) {\r\n    return \"image/png\";\r\n  }\r\n\r\n  // Check for JPEG\r\n  if (buffer[0] === 0xff && buffer[1] === 0xd8) {\r\n    return \"image/jpeg\";\r\n  }\r\n\r\n  // Check for GIF\r\n  if (buffer[0] === 0x47 && buffer[1] === 0x49 && buffer[2] === 0x46) {\r\n    return \"image/gif\";\r\n  }\r\n\r\n  // Default to PNG\r\n  return \"image/png\";\r\n}\r\n\r\n/**\r\n * Get media type from file extension\r\n */\r\nfunction getMediaTypeFromExtension(ext: string): string {\r\n  const map: Record<string, string> = {\r\n    \".pdf\": \"application/pdf\",\r\n    \".png\": \"image/png\",\r\n    \".jpg\": \"image/jpeg\",\r\n    \".jpeg\": \"image/jpeg\",\r\n    \".gif\": \"image/gif\",\r\n    \".webp\": \"image/webp\",\r\n  };\r\n  return map[ext] || \"image/png\";\r\n}\r\n\r\n/**\r\n * Retry a function with exponential backoff\r\n */\r\nexport async function retryCall<T>(\r\n  fn: () => Promise<T>,\r\n  options: RetryOptions = {},\r\n): Promise<T> {\r\n  const { retries = 3, timeout = 20000, delay = 1000 } = options;\r\n\r\n  let lastError: Error | undefined;\r\n\r\n  for (let attempt = 0; attempt <= retries; attempt++) {\r\n    try {\r\n      const controller = new AbortController();\r\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\r\n\r\n      try {\r\n        const result = await fn();\r\n        clearTimeout(timeoutId);\r\n        return result;\r\n      } catch (error) {\r\n        clearTimeout(timeoutId);\r\n        throw error;\r\n      }\r\n    } catch (error) {\r\n      lastError = error instanceof Error ? error : new Error(String(error));\r\n\r\n      // Don't retry on the last attempt\r\n      if (attempt < retries) {\r\n        const backoffDelay = delay * 2 ** attempt;\r\n        await new Promise((resolve) => setTimeout(resolve, backoffDelay));\r\n      }\r\n    }\r\n  }\r\n\r\n  throw lastError || new Error(\"Retry failed\");\r\n}\r\n","import { generateObject } from \"ai\";\r\nimport { retryCall } from \"../utils.js\";\r\nimport type { ExtractOptions, ProviderResult } from \"./types.js\";\r\n\r\nlet geminiProvider: any;\r\n\r\nasync function getGeminiProvider(config?: { model?: string; apiKey?: string }) {\r\n  if (!geminiProvider) {\r\n    try {\r\n      // @ts-expect-error - Optional peer dependency\r\n      const google = await import(\"@ai-sdk/google\");\r\n      geminiProvider = google.google;\r\n    } catch {\r\n      throw new Error(\r\n        \"@ai-sdk/google is not installed. Install it with: npm install @ai-sdk/google\",\r\n      );\r\n    }\r\n  }\r\n\r\n  const apiKey = config?.apiKey || process.env.GOOGLE_GENERATIVE_AI_API_KEY;\r\n  if (!apiKey) {\r\n    throw new Error(\r\n      \"Google API key is required. Set GOOGLE_GENERATIVE_AI_API_KEY or provide apiKey in config\",\r\n    );\r\n  }\r\n\r\n  const model = config?.model || \"gemini-1.5-pro\";\r\n  return geminiProvider(model, { apiKey });\r\n}\r\n\r\nexport async function extractWithGemini<T>(\r\n  options: ExtractOptions<T>,\r\n  config?: { model?: string; apiKey?: string },\r\n): Promise<ProviderResult<T>> {\r\n  const startTime = Date.now();\r\n\r\n  try {\r\n    const model = await getGeminiProvider(config);\r\n\r\n    // Convert base64 to data URI for Gemini\r\n    const dataUri = `data:${options.input.mediaType};base64,${options.input.data}`;\r\n\r\n    const result = await retryCall(\r\n      () =>\r\n        generateObject({\r\n          model,\r\n          schema: options.schema,\r\n          temperature: 0.1,\r\n          abortSignal: AbortSignal.timeout(options.timeout || 20000),\r\n          messages: [\r\n            {\r\n              role: \"system\",\r\n              content: options.prompt,\r\n            },\r\n            {\r\n              role: \"user\",\r\n              content: [\r\n                {\r\n                  type: \"image\",\r\n                  image: dataUri,\r\n                },\r\n              ],\r\n            },\r\n          ],\r\n        }),\r\n      {\r\n        retries: options.retries || 3,\r\n        timeout: options.timeout || 20000,\r\n      },\r\n    );\r\n\r\n    return {\r\n      success: true,\r\n      result: result.object as T,\r\n      duration: Date.now() - startTime,\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error : new Error(String(error)),\r\n      duration: Date.now() - startTime,\r\n    };\r\n  }\r\n}\r\n","import { generateObject } from \"ai\";\r\nimport { retryCall } from \"../utils.js\";\r\nimport type { ExtractOptions, ProviderResult } from \"./types.js\";\r\n\r\nlet mistralProvider: any;\r\n\r\nasync function getMistralProvider(config?: {\r\n  model?: string;\r\n  apiKey?: string;\r\n}) {\r\n  if (!mistralProvider) {\r\n    try {\r\n      const mistral = await import(\"@ai-sdk/mistral\");\n      mistralProvider = mistral.mistral;\r\n    } catch {\r\n      throw new Error(\r\n        \"@ai-sdk/mistral is not installed. Install it with: npm install @ai-sdk/mistral\",\r\n      );\r\n    }\r\n  }\r\n\r\n  const apiKey = config?.apiKey || process.env.MISTRAL_API_KEY;\r\n  if (!apiKey) {\r\n    throw new Error(\r\n      \"Mistral API key is required. Set MISTRAL_API_KEY or provide apiKey in config\",\r\n    );\r\n  }\r\n\r\n  const model = config?.model || \"mistral-medium-latest\";\r\n  return mistralProvider(model, { apiKey });\r\n}\r\n\r\nexport async function extractWithMistral<T>(\r\n  options: ExtractOptions<T>,\r\n  config?: { model?: string; apiKey?: string },\r\n): Promise<ProviderResult<T>> {\r\n  const startTime = Date.now();\r\n\r\n  try {\r\n    const model = await getMistralProvider(config);\r\n\r\n    const result = await retryCall(\r\n      () =>\r\n        generateObject({\r\n          model,\r\n          schema: options.schema,\r\n          temperature: 0.1,\r\n          abortSignal: AbortSignal.timeout(options.timeout || 20000),\r\n          messages: [\r\n            {\r\n              role: \"system\",\r\n              content: options.prompt,\r\n            },\r\n            {\r\n              role: \"user\",\r\n              content: [\r\n                {\r\n                  type: \"file\",\r\n                  data: options.input.data,\r\n                  mediaType: options.input.mediaType,\r\n                },\r\n              ],\r\n            },\r\n          ],\r\n          providerOptions: {\r\n            mistral: {\r\n              documentPageLimit: 10,\r\n            },\r\n          },\r\n        }),\r\n      {\r\n        retries: options.retries || 3,\r\n        timeout: options.timeout || 20000,\r\n      },\r\n    );\r\n\r\n    return {\r\n      success: true,\r\n      result: result.object as T,\r\n      duration: Date.now() - startTime,\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error : new Error(String(error)),\r\n      duration: Date.now() - startTime,\r\n    };\r\n  }\r\n}\r\n","import { generateObject } from \"ai\";\r\nimport { retryCall } from \"../utils.js\";\r\nimport type { ExtractOptions, ProviderResult } from \"./types.js\";\r\n\r\nlet unpdfModule: any;\r\n\r\nasync function extractTextFromPDF(buffer: Buffer): Promise<string> {\r\n  if (!unpdfModule) {\r\n    try {\r\n      unpdfModule = await import(\"unpdf\");\n    } catch {\r\n      throw new Error(\r\n        \"unpdf is not installed. Install it with: npm install unpdf\",\r\n      );\r\n    }\r\n  }\r\n\r\n  const { getDocumentProxy, extractText } = unpdfModule;\r\n  const pdf = await getDocumentProxy(buffer);\r\n  const { text } = await extractText(pdf, { mergePages: true });\r\n\r\n  // Clean up unsupported Unicode escape sequences\r\n  return text.replaceAll(\"\\u0000\", \"\");\r\n}\r\n\r\nexport async function extractWithOCRFallback<T>(\r\n  options: ExtractOptions<T>,\r\n  config?: { model?: string; apiKey?: string },\r\n): Promise<ProviderResult<T>> {\r\n  const startTime = Date.now();\r\n\r\n  try {\r\n    // Convert base64 to buffer\r\n    const buffer = Buffer.from(options.input.data, \"base64\");\r\n\r\n    // Extract text from PDF\r\n    let text: string;\r\n    if (options.input.mediaType === \"application/pdf\") {\r\n      text = await extractTextFromPDF(buffer);\r\n    } else {\r\n      // For images, we can't extract text directly, so this fallback won't work\r\n      // Return error indicating OCR fallback is only for PDFs\r\n      return {\r\n        success: false,\r\n        error: new Error(\"OCR fallback is only available for PDF documents\"),\r\n        duration: Date.now() - startTime,\r\n      };\r\n    }\r\n\r\n    // Update the prompt to indicate we're using extracted text\r\n    const textPrompt = `${options.prompt}\\n\\nExtract structured data from the following OCR text:`;\r\n\r\n    const result = await retryCall(\r\n      async () => {\r\n        const mistral = await import(\"@ai-sdk/mistral\");\n        const model = config?.model || \"mistral-medium-latest\";\r\n        const apiKey = config?.apiKey || process.env.MISTRAL_API_KEY;\r\n        if (!apiKey) {\r\n          throw new Error(\r\n            \"Mistral API key is required. Set MISTRAL_API_KEY or provide apiKey in config\",\r\n          );\r\n        }\r\n        const mistralModel = mistral.mistral(model, { apiKey });\r\n\r\n        return generateObject({\r\n          model: mistralModel,\r\n          schema: options.schema,\r\n          temperature: 0.1,\r\n          abortSignal: AbortSignal.timeout(options.timeout || 20000),\r\n          messages: [\r\n            {\r\n              role: \"system\",\r\n              content: textPrompt,\r\n            },\r\n            {\r\n              role: \"user\",\r\n              content: [\r\n                {\r\n                  type: \"text\",\r\n                  text: text,\r\n                },\r\n              ],\r\n            },\r\n          ],\r\n        });\r\n      },\r\n      {\r\n        retries: options.retries || 3,\r\n        timeout: options.timeout || 20000,\r\n      },\r\n    );\r\n\r\n    return {\r\n      success: true,\r\n      result: result.object as T,\r\n      duration: Date.now() - startTime,\r\n    };\r\n  } catch (error) {\r\n    return {\r\n      success: false,\r\n      error: error instanceof Error ? error : new Error(String(error)),\r\n      duration: Date.now() - startTime,\r\n    };\r\n  }\r\n}\r\n","import type { z } from \"zod\";\r\nimport type { QualityThreshold } from \"./types.js\";\r\n\r\n/**\r\n * Check if extracted data meets minimum quality standards\r\n */\r\nexport function validateQuality<T>(\r\n  result: T,\r\n  schema: z.ZodSchema<T>,\r\n  threshold?: QualityThreshold,\r\n): boolean {\r\n  const defaultThreshold: Required<QualityThreshold> = {\r\n    requireTotal: true,\r\n    requireCurrency: true,\r\n    requireVendor: true,\r\n    requireDate: true,\r\n  };\r\n\r\n  const config = { ...defaultThreshold, ...threshold };\r\n\r\n  // Parse and validate the result\r\n  const parsed = schema.safeParse(result);\r\n  if (!parsed.success) {\r\n    return false;\r\n  }\r\n\r\n  const data = parsed.data as Record<string, unknown>;\r\n\r\n  // Check critical fields\r\n  if (config.requireTotal) {\r\n    const total = data.total_amount;\r\n    if (!total || (typeof total === \"number\" && total <= 0)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if (config.requireCurrency) {\r\n    const currency = data.currency;\r\n    if (!currency || typeof currency !== \"string\" || currency.trim() === \"\") {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if (config.requireVendor) {\r\n    const vendor = data.vendor_name;\r\n    if (!vendor || typeof vendor !== \"string\" || vendor.trim() === \"\") {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if (config.requireDate) {\r\n    // Check for invoice_date, due_date, or date field\r\n    const invoiceDate = data.invoice_date;\r\n    const dueDate = data.due_date;\r\n    const date = data.date;\r\n\r\n    if (\r\n      (!invoiceDate ||\r\n        (typeof invoiceDate === \"string\" && invoiceDate.trim() === \"\")) &&\r\n      (!dueDate || (typeof dueDate === \"string\" && dueDate.trim() === \"\")) &&\r\n      (!date || (typeof date === \"string\" && date.trim() === \"\"))\r\n    ) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n","import { z } from \"zod\";\r\n\r\n// Line item schema for invoices and receipts\r\nconst lineItemSchema = z.object({\r\n  description: z.string().optional(),\r\n  quantity: z.number().optional(),\r\n  unit_price: z.number().optional(),\r\n  total: z.number().optional(),\r\n});\r\n\r\n// Invoice schema\r\nexport const invoiceSchema = z.object({\r\n  total_amount: z.number().nullable().optional(),\r\n  currency: z.string().nullable().optional(),\r\n  vendor_name: z.string().nullable().optional(),\r\n  invoice_date: z.string().nullable().optional(),\r\n  due_date: z.string().nullable().optional(),\r\n  invoice_number: z.string().nullable().optional(),\r\n  customer_name: z.string().nullable().optional(),\r\n  vendor_address: z.string().nullable().optional(),\r\n  customer_address: z.string().nullable().optional(),\r\n  email: z.string().nullable().optional(),\r\n  website: z.string().nullable().optional(),\r\n  tax_amount: z.number().nullable().optional(),\r\n  tax_rate: z.number().nullable().optional(),\r\n  tax_type: z.string().nullable().optional(),\r\n  payment_instructions: z.string().nullable().optional(),\r\n  notes: z.string().nullable().optional(),\r\n  language: z.string().nullable().optional(),\r\n  line_items: z.array(lineItemSchema).optional(),\r\n});\r\n\r\n// Receipt schema\r\nexport const receiptSchema = z.object({\r\n  total_amount: z.number().nullable().optional(),\r\n  currency: z.string().nullable().optional(),\r\n  vendor_name: z.string().nullable().optional(),\r\n  date: z.string().nullable().optional(),\r\n  transaction_id: z.string().nullable().optional(),\r\n  payment_method: z.string().nullable().optional(),\r\n  items: z.array(lineItemSchema).optional(),\r\n  tax_amount: z.number().nullable().optional(),\r\n  tax_rate: z.number().nullable().optional(),\r\n  subtotal: z.number().nullable().optional(),\r\n  tip: z.number().nullable().optional(),\r\n  notes: z.string().nullable().optional(),\r\n});\r\n\r\nexport type InvoiceData = z.infer<typeof invoiceSchema>;\r\nexport type ReceiptData = z.infer<typeof receiptSchema>;\r\n","export type DocumentType = \"invoice\" | \"receipt\";\r\n\r\nexport interface MistralConfig {\r\n  model?: string;\r\n  apiKey?: string;\r\n}\r\n\r\nexport interface GeminiConfig {\r\n  model?: string;\r\n  apiKey?: string;\r\n}\r\n\r\nexport interface ProviderConfig {\r\n  mistral?: MistralConfig;\r\n  gemini?: GeminiConfig;\r\n}\r\n\r\nexport interface OCROptions {\r\n  providers?: ProviderConfig;\r\n  timeout?: number;\r\n  retries?: number;\r\n  qualityThreshold?: QualityThreshold;\r\n}\r\n\r\nexport interface QualityThreshold {\r\n  requireTotal?: boolean;\r\n  requireCurrency?: boolean;\r\n  requireVendor?: boolean;\r\n  requireDate?: boolean;\r\n}\r\n\r\nexport interface ProviderAttempt {\r\n  provider: \"mistral\" | \"gemini\" | \"ocr-fallback\";\r\n  success: boolean;\r\n  error?: Error;\r\n  result?: unknown;\r\n  duration?: number;\r\n}\r\n\r\nexport class OCRError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public attempts: ProviderAttempt[],\r\n    public finalError?: Error,\r\n  ) {\r\n    super(message);\r\n    this.name = \"OCRError\";\r\n  }\r\n}\r\n\r\nexport type OCRInput = Buffer | string | File;\r\n","import type { z } from \"zod\";\r\nimport { mergeResults } from \"./merge.js\";\r\nimport { extractWithGemini } from \"./providers/gemini.js\";\r\nimport { extractWithMistral } from \"./providers/mistral.js\";\r\nimport { extractWithOCRFallback } from \"./providers/ocr-fallback.js\";\r\nimport { validateQuality } from \"./quality.js\";\r\nimport { invoiceSchema, receiptSchema } from \"./schemas.js\";\r\nimport type { OCRInput, OCROptions, ProviderAttempt } from \"./types.js\";\r\nimport { OCRError } from \"./types.js\";\r\nimport { normalizeInput } from \"./utils.js\";\r\n\r\n// Default prompts for invoice and receipt extraction\r\nconst INVOICE_PROMPT = `Extract structured data from this invoice document. Extract all relevant fields including vendor information, dates, amounts, line items, tax information, and payment details. Be accurate and complete.`;\r\n\r\nconst RECEIPT_PROMPT = `Extract structured data from this receipt document. Extract all relevant fields including vendor/merchant name, date, total amount, items purchased, payment method, and transaction details. Be accurate and complete.`;\r\n\r\nfunction getSchemaAndPrompt(\r\n  typeOrSchema: \"invoice\" | \"receipt\" | z.ZodSchema<any>,\r\n): { schema: z.ZodSchema<any>; prompt: string } {\r\n  if (typeof typeOrSchema === \"string\") {\r\n    if (typeOrSchema === \"invoice\") {\r\n      return { schema: invoiceSchema, prompt: INVOICE_PROMPT };\r\n    }\r\n    if (typeOrSchema === \"receipt\") {\r\n      return { schema: receiptSchema, prompt: RECEIPT_PROMPT };\r\n    }\r\n  }\r\n\r\n  // Custom schema - use generic prompt\r\n  return {\r\n    schema: typeOrSchema,\r\n    prompt:\r\n      \"Extract structured data from this document according to the provided schema. Be accurate and complete.\",\r\n  };\r\n}\r\n\r\nexport async function ocr<T extends Record<string, unknown>>(\r\n  input: OCRInput,\r\n  typeOrSchema: \"invoice\" | \"receipt\" | z.ZodSchema<T>,\r\n  options: OCROptions = {},\r\n): Promise<T> {\r\n  const attempts: ProviderAttempt[] = [];\r\n  const { schema, prompt } = getSchemaAndPrompt(typeOrSchema);\r\n  const normalizedInput = await normalizeInput(input);\r\n\r\n  const extractOptions = {\r\n    schema,\r\n    input: normalizedInput,\r\n    prompt,\r\n    timeout: options.timeout || 20000,\r\n    retries: options.retries ?? 3,\r\n  };\r\n\r\n  // Primary attempt: Mistral\r\n  let primaryResult: T | undefined;\r\n  let primaryError: Error | undefined;\r\n\r\n  try {\r\n    const mistralResult = await extractWithMistral(\r\n      extractOptions,\r\n      options.providers?.mistral,\r\n    );\r\n\r\n    attempts.push({\r\n      provider: \"mistral\",\r\n      success: mistralResult.success,\r\n      error: mistralResult.error,\r\n      result: mistralResult.result,\r\n      duration: mistralResult.duration,\r\n    });\r\n\r\n    if (mistralResult.success && mistralResult.result) {\r\n      primaryResult = mistralResult.result as T;\r\n\r\n      // Check quality\r\n      const isQualityGood = validateQuality(\r\n        primaryResult,\r\n        schema,\r\n        options.qualityThreshold,\r\n      );\r\n\r\n      if (isQualityGood) {\r\n        return primaryResult;\r\n      }\r\n\r\n      // Quality is poor, but we have a result - continue to fallback and merge\r\n    } else {\r\n      primaryError = mistralResult.error;\r\n    }\r\n  } catch (error) {\r\n    primaryError = error instanceof Error ? error : new Error(String(error));\r\n    attempts.push({\r\n      provider: \"mistral\",\r\n      success: false,\r\n      error: primaryError,\r\n    });\r\n  }\r\n\r\n  // Secondary attempt: Gemini\r\n  let fallbackResult: T | undefined;\r\n  let fallbackError: Error | undefined;\r\n\r\n  try {\r\n    const geminiResult = await extractWithGemini(\r\n      extractOptions,\r\n      options.providers?.gemini,\r\n    );\r\n\r\n    attempts.push({\r\n      provider: \"gemini\",\r\n      success: geminiResult.success,\r\n      error: geminiResult.error,\r\n      result: geminiResult.result,\r\n      duration: geminiResult.duration,\r\n    });\r\n\r\n    if (geminiResult.success && geminiResult.result) {\r\n      fallbackResult = geminiResult.result as T;\r\n\r\n      // If we have primary result, merge them\r\n      if (primaryResult) {\r\n        return mergeResults(primaryResult, fallbackResult);\r\n      }\r\n\r\n      // Check quality of fallback\r\n      const isQualityGood = validateQuality(\r\n        fallbackResult,\r\n        schema,\r\n        options.qualityThreshold,\r\n      );\r\n\r\n      if (isQualityGood) {\r\n        return fallbackResult;\r\n      }\r\n\r\n      // Quality is poor, continue to OCR fallback\r\n    } else {\r\n      fallbackError = geminiResult.error;\r\n    }\r\n  } catch (error) {\r\n    fallbackError = error instanceof Error ? error : new Error(String(error));\r\n    attempts.push({\r\n      provider: \"gemini\",\r\n      success: false,\r\n      error: fallbackError,\r\n    });\r\n  }\r\n\r\n  // Tertiary attempt: OCR + LLM (only for PDFs)\r\n  if (normalizedInput.mediaType === \"application/pdf\") {\r\n    try {\r\n      const ocrResult = await extractWithOCRFallback(\r\n        extractOptions,\r\n        options.providers?.mistral,\r\n      );\r\n\r\n      attempts.push({\r\n        provider: \"ocr-fallback\",\r\n        success: ocrResult.success,\r\n        error: ocrResult.error,\r\n        result: ocrResult.result,\r\n        duration: ocrResult.duration,\r\n      });\r\n\r\n      if (ocrResult.success && ocrResult.result) {\r\n        const ocrData = ocrResult.result as T;\r\n\r\n        // Merge with any existing results\r\n        if (primaryResult) {\r\n          return mergeResults(primaryResult, ocrData);\r\n        }\r\n        if (fallbackResult) {\r\n          return mergeResults(fallbackResult, ocrData);\r\n        }\r\n\r\n        return ocrData;\r\n      }\r\n    } catch (error) {\r\n      attempts.push({\r\n        provider: \"ocr-fallback\",\r\n        success: false,\r\n        error: error instanceof Error ? error : new Error(String(error)),\r\n      });\r\n    }\r\n  }\r\n\r\n  // If we have any result (even if quality is poor), return it\r\n  if (primaryResult) {\r\n    return primaryResult;\r\n  }\r\n  if (fallbackResult) {\r\n    return fallbackResult;\r\n  }\r\n\r\n  // All attempts failed\r\n  const finalError =\r\n    primaryError || fallbackError || new Error(\"All OCR providers failed\");\r\n\r\n  throw new OCRError(\r\n    `Failed to extract data from document: ${finalError.message}`,\r\n    attempts,\r\n    finalError,\r\n  );\r\n}\r\n"]}